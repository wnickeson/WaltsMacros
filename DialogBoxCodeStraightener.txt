'MacroName:DialogBoxCodeStraightener.2024.01
'MacroDescription:Aligns control coordinates in dialog box definitions and makes bulk
' changes in the coordinates of those controls.
'
' This macro was written by Walter F. Nickeson,
' University of Rochester, Rochester, NY
' wnickeson@library.rochester.edu
' https://orcid.org/0000-0003-0484-6938
'
' Last updated: 12 February 2024.
' Check for the latest versions of this and my other macros at
' https://github.com/wnickeson/WaltsMacros
' Please e-mail me with bug reports or to suggest improvements.
'
' This macro works for me with Connexion client 3.1 and Windows 11 Enterprise & 64-bit
' Windows 10 Pro, but no guarantees are promised or implied.
'
'****************************************************************************************
' How it works: This macro adds whitespace to lines of code copied from a dialog box
' definition to align the coordinates of dialog box controls and other information. Code
' in neat columns is easier to read, and makes relationships between the controls in the
' dialog box much clearer. The OCLC macro language dialog box editor produces a dense
' jumble of code when used to create a dialog box. This macro helps make sense of that
' mess. It can also help somewhat to align the controls in the displayed box.
'
' To use the macro: You do not need to be logged on to Connexion to run the macro, nor do
' you need to be working in the Macro Editor--except that otherwise you can't run the
' macro to check its results! Copy entire, contiguous lines of code (no partial lines)
' from a dialog box definition to the Windows Clipboard. Select the lines to be
' straightened by clicking and dragging with the mouse or using the [SHIFT] and down
' arrow keys. You don't have to include the "Begin Dialog" and "End Dialog" lines, but
' all the lines selected must form a single block. Copy the selection with the [CTRL-C]
' keys or use the buttons on the toolbar; using the right mouse button to copy the
' selection doesn't work. It's better not to cut the text, because if you run the macro
' and then decide the change isn't right, the copied text will be gone from the Clipboard
' and can't be retrieved.
'
' When the lines of code have been copied, run the macro. It displays the beginning of
' the copied text for confirmation that what is on the Clipboard is really from a dialog
' box definition--and if it isn't, you can tell what was actually copied, or at least the
' first part of it. The macro reads the text from the Clipboard and, by working from the
' commas in each line, adds whitespace to align the coordinates of the dialog box
' controls, as well as labels, IDs, and comments. Dialog box controls--push buttons,
' checkboxes, radio buttons, etc.--are defined by statements. All dialog box statements
' are indented two spaces from the beginning indention, which does not have to be the
' beginning of the line; any initial indention of the whole dialog box definition is
' preserved. Option button coordinates are indented a further space below the OptionGroup
' statement. If a ButtonGroup is defined, pushbuttons beneath it are indented too. The
' macro will also change the horizontal and vertical coordinates of the controls, if
' numbers are entered in the text boxes; the maximum change allowed is 999. To align the
' columns of code or change the positions of only some of the controls, select only the
' affected lines from the dialog box definition. For example, to move the bottom half of
' a dialog box down to make room for a new control in the top half, simply select those
' controls that need to move. (Because the selected lines must be contiguous, some
' rearranging of dialog box statements may be necessary to group together all affected
' controls.) If moving controls means the whole dialog box must expand, such as when you
' need to shift everything to the right by a certain amount, include the "Begin Dialog"
' line in the copied text. The dimensions of the dialog box will be expanded by the same
' amount, and in the same dimension(s), as the coordinates of the controls inside the
' box are shifted. Note that the dialog box will not shrink if its controls are moved
' inward or upward. Clicking the OK button replaces the original text on the Clipboard
' with the modified text. Finish by toggling back to the dialog box to paste in that
' text, which is a simple matter of pressing [CTRL-V] or using the "Paste" button in the
' ribbon at the top of the editor.
'
' The unit of measurement in the dialog definition for all these coordinates is the DLU,
' which in the horizontal dimension is 1/4 the average width of the system font, and in
' the vertical, 1/8 the height of the system font. The actual size in pixels of the
' dialog box and its controls will vary according to screen resolution.
'
' The macro offers several options to go along with its alignment of code. The first is
' to add the numeric identifiers of the controls. While it's usually better to identify
' controls with names, as names can carry meaning numbers can't, sometimes it can be
' convenient to use numbers instead, as when several controls appear in a regular
' pattern, and their states or values can be processed by some sort of iteration. Numeric
' identifiers appear as comments (marked by a preceding single quotation mark), starting
' at zero with the first statement. All statements except the "Caption" and the "Begin
' Dialog...End Dialog" statements have numeric identifiers. This is the case even if the
' controls are not actionable, such as the "Text" statement. All the macro does by adding
' the numeric identifiers is make them apparent, so you don't have to count lines to see
' the number of any control, or use the "DlgControlID" function to discover them. If the
' macro has already added control numbers, and the lines have been rearranged, the macro
' re-assigns the numbers. If only selected lines from the dialog box have been copied,
' the macro starts its numbering with the lowest number found, re-numbering the controls
' in order.
'
' The second option is what I call optimizing the controls. This option affects the
' appearance and placement of controls in the dialog box, not in the code, and it does
' two things. It makes certain controls a regular height (following some suggestions in
' old, unavailable documentation): The height of text boxes and radio buttons are made to
' be 12 DLUs, pushbuttons 14, and text areas multiples of 8. Selecting this option also
' makes the macro attempt to align controls within the dialog box. Controls that are
' within 8 DLUs of each other horizontally, and 6 vertically, will have their coordinates
' changed to align the controls along their left and top edges, respectively. Related
' controls, such as groups of radio buttons or checkboxes, are evenly spaced as they are
' aligned. Choosing this option makes the most sense when running the macro immediately
' after having used the dialog editor to create or edit controls. You can add controls
' and drag them around with the mouse to roughly achieve a functional and useful layout
' without having to position things exactly, and then run the macro to automatically do
' some of the lining up of controls as a first step in the editing process. However, the
' macro does not check for overlapping or even proper spacing of controls, and won't
' rearrange the lines in the code.
'
' The third option is to space controls evenly in the dialog box. This option works only
' on lines of code that contain controls, so the macro fails if, for example, an
' "OptionGroup" statement is is included in the copied lines. It is intended to help get
' correct or pleasing spacing for sets of similar controls, such as groups of checkboxes
' or radio buttons, although it works on any controls, whether they are the same kind or
' not. When this option is selected, the desired space between controls must be a number
' between 1 and 8. In the vertical dimension, the space is DLUs between the bottom edge
' of the control (or of the tallest control, if there is more than one control on the
' line) on the upper line, and the top edge of controls on the lower line. In the
' horizontal dimension, the space is between the right edge of the left control and the
' left edge of the right control. Note that choosing too great a space between controls
' could cause some controls to be misaligned with respect to other controls, or to be
' pushed out of the dialog box entirely. This option will not actually create nice
' columns of controls in the dialog box.
'
' As an example, if these lines of code are copied:
'
' Begin Dialog DialogBox 304, 341, "Align/Change dialog box coordinates", .Controll
'    OkButton  193, 320, 50, 14
'    CancelButton  247, 320, 50, 14
'    TextBox  125, 26, 24, 12, .TextBoxHoriz
'    TextBox  261, 26, 24, 12, .TextBoxVert
'    Text  13, 26, 108, 8, "Change horizontal coordinates by:"
'    Text  17, 34, 96, 16, "(negative numbers move controls left)"
'
' and "-2" is entered for the horizontal coordinate change, and "8" for the vertical, the
' macro produces this output, copied to the Clipboard for pasting in:
'
' Begin Dialog DialogBox  304, 349, "Align/Change dialog box coordinates", .Controll
'   OkButton      191, 328,  50,  14
'   CancelButton  245, 328,  50,  14
'   TextBox       123,  34,  24,  12,                                          .TextBoxHoriz
'   TextBox       259,  34,  24,  12,                                          .TextBoxVert
'   Text           11,  34, 108,   8, "Change horizontal coordinates by:"
'   Text           15,  42,  96,  16, "(negative numbers move controls left)"
'
' Note that the height of the dialog box has changed, because all controls were moved
' down 8 DLUs, but the width was not changed, because the macro will not shrink the
' dimensions of the box. Otherwise, some controls might find themselves outside of the
' box.
'
' In this next example, control numbers have been added. They appear for every control,
' named or not, actionable or otherwise, and the controls have numbers even if they are
' not shown:
'
' Begin Dialog Dialog1Definition  336, 172, WaltsMacros$, .Dialog1ControlFunction
'   PushButton    172, 148,  96,  14, "",                .AddReplace '0
'   CancelButton  274, 148,  50,  14                                 '1
'   PushButton     12, 148,  50,  14, "Re&set"                       '2
'   PushButton     69, 148,  64,  14, "&Update display", .Update     '3
'   CheckBox       18, 128, 280,  12, "",                .Replace    '4
'   GroupBox      232,  24,  92,  57, "Codes or terms?"              '5
'
' If no change in the positions of the controls is indicated, and control placement is
' not requested, the result is only the making of neat columns in the code.
'
' If the position of the dialog box on the screen is given, the macro ignores it.
'
' Blank lines within the dialog box, or lines beginning with the comment mark (a single
' quotation mark), are preserved.
'****************************************************************************************

Option Compare Text
Option Explicit

Declare Sub Help
Declare Sub OptimizeSub
Declare Sub SpaceSub( x As Integer, y As Integer, z As Integer )

Declare Function Dialog1ControlFunction( Id$, Action%, SVal& )
Declare Function Dialog2ControlFunction( Id$, Action%, SVal& )

Global Const aCONTROL_COMMENT     As Integer = 7
Global Const aCONTROL_HEIGHT      As Integer = 4
Global Const aCONTROL_HORIZ_COORD As Integer = 1
Global Const aCONTROL_ID          As Integer = 6
Global Const aCONTROL_LABEL       As Integer = 5
Global Const aCONTROL_NAME        As Integer = 0
Global Const aCONTROL_VERT_COORD  As Integer = 2
Global Const aCONTROL_WIDTH       As Integer = 3
Global Const aOPTIMIZED           As Integer = 8

Global DOUBLE_QUOTE As String*1

Global WaltsMacros$

Global BadInput

Global CodeLines() As String

'****************************************************************************************

Sub Main

Const CRITICAL_MESSAGE     As Integer = 16
Const DIALOG_BUTTON_CANCEL As Integer = 0
Const INFORMATION_MESSAGE  As Integer = 64
Const OUT_OF_STRING_SPACE  As Integer = 14
Const WARNING_MESSAGE      As Integer = 48

Dim CRLF              As String*2 : CRLF              = Chr$( 013 ) & Chr$( 010 )
Dim LABEL_PLACEHOLDER As String*1 : LABEL_PLACEHOLDER = Chr$( 182 )
Dim SEPARATOR         As String*1 : SEPARATOR         = ","
Dim SINGLE_QUOTE      As String*1 : SINGLE_QUOTE      = Chr$( 039 )

Dim ArrayElement$
Dim ChangeHorizontal%
Dim ChangeVertical%
Dim CharA%
Dim CharT$
Dim CommaCount%
Dim Comment$
Dim CommentLength%
Dim CommentOffset%
Dim ControlID_Number%
Dim ControlLabel$
Dim CurrentID%
Dim DisplayString$
Dim EndOfLine%
Dim FirstComma%
Dim HorizontalSpacing%
Dim IDDot%
Dim IndentLine%
Dim IndentWholeDialog$
Dim InputString$
Dim Legend$
Dim LenInputOrig%
Dim LenInputTrim%
Dim LineCount%
Dim LongestControlLabel%
Dim LongestControlName%
Dim LongestID_Name%
Dim LowestID_Number%
Dim OutputString$
Dim PosComment%
Dim QuoteCount%
Dim Start%
Dim Subfield$
Dim TempString$
Dim VerticalSpacing%
Dim WholeBox%
Dim WorkLine$

Dim ControlGroup                  : ControlGroup      = FALSE
Dim Skip

Dim i As Integer, j As Integer, p As Integer, q As Integer, z As Integer

Dim SpinnerV( 8 ) As String
SpinnerV( 0 ) = ""
SpinnerV( 1 ) = "1"
SpinnerV( 2 ) = "2"
SpinnerV( 3 ) = "3"
SpinnerV( 4 ) = "4"
SpinnerV( 5 ) = "5"
SpinnerV( 6 ) = "6"
SpinnerV( 7 ) = "7"
SpinnerV( 8 ) = "8"

Dim SpinnerH( 16 ) As String
SpinnerH( 0 )  = ""
SpinnerH( 1 )  = "1"
SpinnerH( 2 )  = "2"
SpinnerH( 3 )  = "3"
SpinnerH( 4 )  = "4"
SpinnerH( 5 )  = "5"
SpinnerH( 6 )  = "6"
SpinnerH( 7 )  = "7"
SpinnerH( 8 )  = "8"
SpinnerH( 9 )  = "9 "
SpinnerH( 10 ) = "10"
SpinnerH( 11 ) = "11"
SpinnerH( 12 ) = "12"
SpinnerH( 13 ) = "13"
SpinnerH( 14 ) = "14"
SpinnerH( 15 ) = "15"
SpinnerH( 16 ) = "16"

DOUBLE_QUOTE = Chr$( 034 )

WaltsMacros$ = "[Walt's macros] MacroTools:DialogBoxCodeStraightener"

BadInput     = FALSE

' First, check input. If the string is too long, or if it's of zero length, it can't be
' processed.

On Error Resume Next
InputString$ = Clipboard.GetText()
If Err = OUT_OF_STRING_SPACE Then
    MsgBox "There is too much text on the Clipboard!", CRITICAL_MESSAGE, WaltsMacros$
    Exit Sub
End If

If InputString$ = "" Then
    MsgBox "There is no text on the Clipboard!", CRITICAL_MESSAGE, WaltsMacros$
    Exit Sub
End If

' Trim the string. Assume leading spaces mean the dialog box code is indented, and
' restore that string of spaces after processing.

LenInputOrig%      = Len( InputString$ )
InputString$       = LTrim$( InputString$ )
LenInputTrim%      = Len( InputString$ )
IndentWholeDialog$ = Space$( LenInputOrig% - LenInputTrim% )
InputString$       = RTrim$( InputString$ )
DisplayString$     = InputString$

' Process the input string, line by line, a line being defined by a carriage return/line
' feed character combination. Remove each line from the input string, so when it becomes
' an empty string, all the lines have been processed.

LineCount% = 0
Do
  EndOfLine% = InStr( 1, InputString$, CRLF )
  If EndOfLine% = 0 Then
      WorkLine$    = InputString$
      InputString$ = ""
    Else
      WorkLine$    = Left$( InputString$, EndOfLine% - 1 )
      InputString$ = Mid$ ( InputString$, EndOfLine% + 2 )
  End If
  ReDim Preserve CodeLines( aOPTIMIZED, LineCount% )
  WorkLine$ = Trim$( WorkLine$ )

' A completely empty line receives special treatment to preserve it thoughout processing.

  If WorkLine$ = "" Then
      WorkLine$ = "$,,,,,,,"
  End If

' Check that subsequent lines begin with an appropriate letter; anything else means a
' mistake, perhaps an accidental invocation of the macro. Some mistakes, of course, will
' slip through.

  TempString$ = Left$( WorkLine$, 1 )
  If TempString$ Like "[!BCDEGLOPST$]" And TempString$ <> SINGLE_QUOTE Then
      BadInput       = TRUE
      Legend$        = "Problem input:"
      DisplayString$ = "This line doesn't seem as though it belongs in a dialog box definition:" & CRLF & CRLF & WorkLine$
      GoTo DialogBox:
  End If

' A comment at the end of a line is removed for adding back later.

  p = InStr( WorkLine$, SINGLE_QUOTE )
  If p <> 0 Then
      Comment$  = Trim$( Mid$( WorkLine$, p ) )
      WorkLine$ = Trim$( Left$( WorkLine$, p - 1 ) )
      If WorkLine$ = "" Then
          WorkLine$ = ",,,,,,,"
      End If
  End If

' Consider each line of the dialog box code to be a comma-delimited field of subfields,
' each subfield containing a dialog box control parameter. However, the field needs some
' preprocessing to make sure each subfield contains its appropriate piece of information.
' For most controls, the first subfield actually contains two bits of information, the
' name of the control and its horizontal position. These are separated by inserting a
' comma before the digits at the end of the subfield.

  p = InStr( 1, WorkLine$, SEPARATOR )
  If p <> 0 Then
      For i = p - 1 To 1 Step -1
        CharT$ = Mid$( WorkLine$, i, 1 )
        If CharT$ Like "[!0-9$]" Then
            WorkLine$ = Trim$( Left$( WorkLine$, i ) ) & SEPARATOR & Trim$( Mid$( WorkLine$, i ) )
            Exit For
        End If
      Next i

' The only controls that lack commas besides the "Begin" and "End" lines are the two
' grouping statements, and "Caption." The former will contain only a field name, and the
' latter will contain either a variable name or a string in quotation marks.

    Else
      If Mid$( WorkLine$, 7, 5 ) = "Group" Then
          WorkLine$ = Left$( WorkLine$, 11 ) & ",,,,," & Mid$( WorkLine$, 13 )
        ElseIf Left$( WorkLine$, 7 ) = "Caption" Then
          WorkLine$ = Left$( WorkLine$, 7 ) & ",,,,," & Trim$( Mid$( WorkLine$, 8 ) )
      End If
  End If

' A comma may be present as part of a label or text associated with a control. To prevent
' it from being considered as a subfield delimiter, remove all labels (anything within
' quotation marks) to preserve them as complete units. Replace them with a placeholder.
' Watch out for multiple sets of quotation marks, such as occurs when concatenating
' strings. The macro deals with this by examining each character in the string following
' the first quotation mark it finds. A comma falling outside a pair of quotation marks
' signals the end of the label. No comma means there is no following element, which would
' be the control ID, a field name, or the dialog function name.

  p = InStr( WorkLine$, DOUBLE_QUOTE )
  If p <> 0 Then
      QuoteCount% = 1
      For i = p + 1 To Len( WorkLine$ )
        CharT$ = Mid$( WorkLine$, i, 1 )
        Select Case CharT$
          Case ","
            If QuoteCount% Mod 2 = 0 Then
                q = i
                Exit For
            End If
          Case DOUBLE_QUOTE
            QuoteCount% = QuoteCount% + 1
        End Select
      Next i
      If QuoteCount% = 1 Then
          BadInput       = TRUE
          Legend$        = "Problem input:"
          DisplayString$ = "There is a missing quotation mark in a control label in this line:" & CRLF & CRLF & WorkLine$
          GoTo DialogBox:
        Else
          If q = 0 Then
              ControlLabel$ = Mid$( WorkLine$, p )
              WorkLine$     = Left$( WorkLine$, p - 1 ) & LABEL_PLACEHOLDER
            Else
              ControlLabel$ = Mid$( WorkLine$, p, q - p )
              WorkLine$     = Left$( WorkLine$, p - 1 ) & LABEL_PLACEHOLDER & Mid$( WorkLine$, q )
          End If
      End If
      q = 0
  End If

' Finally, count the commas to get the number of subfields in the string. Four controls
' or lines may have no commas, but all the other controls or lines must have at least
' one, so the absence of commas could signal an input problem.

  Start% = 1
  Do
    p = InStr( Start%, WorkLine$, SEPARATOR )
    If p <> 0 Then
        CommaCount% = CommaCount% + 1
        Start% = p + 1
    End If
  Loop Until p = 0
  If CommaCount% = 0 And Left$( WorkLine$, 1 ) Like "[!BCEO]" Then
      If Right$( WorkLine$, 1 ) = SINGLE_QUOTE Then
          WorkLine$ = WorkLine$ & Comment
      End If
      p = InStr( WorkLine$, LABEL_PLACEHOLDER )
      If p <> 0 Then
          WorkLine$ = Left$( WorkLine$, p - 1 ) & ControlLabel$ & Mid$( WorkLine$, q + 1 )
      End If
      BadInput       = TRUE
      Legend$        = "Problem input:"
      DisplayString$ = "One of the copied lines is missing at least one comma:" & CRLF & CRLF & WorkLine$
      GoTo DialogBox:
  End If

' Now move the subfields into an array of eight elements. Collecting all the information
' in an array, rather than keeping it in field strings, makes it easier to calculate some
' string lengths to nicely space the bits of the dialog box on the screen. Begin with the
' dialog box definition line. Process it separately, as it has more optional parameters
' than the controls within the dialog box. Start by examining the fourth subfield. If
' it's absent, we know that the only information given is the dimensions of the box. If
' the fourth subfield is a number, we know that is the width of the dialog box, and also
' that the position of the dialog box is present. (However, the macro ignores the dialog
' box's position, lumping the coordinates in with the name of the element.) If the fourth
' subfield begins with a letter, we know it is a caption or title; if it begins with a
' dot or a period, we know it is a dialog box control function and the caption or label
' is absent. In both of these latter cases the position of the box is not present.

  If Left$( WorkLine$, 12 ) = "Begin Dialog" Then
      WholeBox% = WholeBox% + 1
      Subfield$ = Trim$( GetField$( WorkLine$, 4, SEPARATOR ) )
      If Subfield$ = "" Then       'Only box size given
          CodeLines( aCONTROL_NAME, LineCount% )        = Trim$( GetField$( WorkLine$, 1, SEPARATOR ) )
          CodeLines( aCONTROL_HORIZ_COORD, LineCount% ) = Trim$( GetField$( WorkLine$, 2, SEPARATOR ) )
          CodeLines( aCONTROL_VERT_COORD, LineCount% )  = Trim$( GetField$( WorkLine$, 3, SEPARATOR ) )
        Else
          CharT$ = Left$( Subfield$, 1 )
          Select Case CharT$
            Case "0" To "9"        'Size of box: Box position given; put position in with label
              CodeLines( aCONTROL_NAME,        LineCount% ) = GetField$( WorkLine$, 1, SEPARATOR ) & "   " & GetField$( WorkLine$, 2, SEPARATOR ) & "   " & GetField$( WorkLine$, 3, SEPARATOR )
              CodeLines( aCONTROL_HORIZ_COORD, LineCount% ) = Trim$( GetField$( WorkLine$, 4, SEPARATOR ) )
              CodeLines( aCONTROL_VERT_COORD,  LineCount% ) = Trim$( GetField$( WorkLine$, 5, SEPARATOR ) )
            Case "."               'Dialog control function
              CodeLines( aCONTROL_NAME,        LineCount% ) = Trim$( GetField$( WorkLine$, 1, SEPARATOR ) )
              CodeLines( aCONTROL_HORIZ_COORD, LineCount% ) = Trim$( GetField$( WorkLine$, 2, SEPARATOR ) )
              CodeLines( aCONTROL_VERT_COORD,  LineCount% ) = Trim$( GetField$( WorkLine$, 3, SEPARATOR ) )
              CodeLines( aCONTROL_ID,          LineCount% ) = Trim$( GetField$( WorkLine$, 4, SEPARATOR ) )
            Case Else              'Dialog caption
              CodeLines( aCONTROL_NAME,        LineCount% ) = Trim$( GetField$( WorkLine$, 1, SEPARATOR ) )
              CodeLines( aCONTROL_HORIZ_COORD, LineCount% ) = Trim$( GetField$( WorkLine$, 2, SEPARATOR ) )
              CodeLines( aCONTROL_VERT_COORD,  LineCount% ) = Trim$( GetField$( WorkLine$, 3, SEPARATOR ) )
              If Trim$( GetField$( WorkLine$, 4, SEPARATOR ) ) = LABEL_PLACEHOLDER Then
                  CodeLines( aCONTROL_LABEL, LineCount% ) = Trim$( ControlLabel$ )
                Else
                  CodeLines( aCONTROL_LABEL, LineCount% ) = Trim$( GetField$( WorkLine$, 4, SEPARATOR ) )
              End If
              CodeLines( aCONTROL_ID,          LineCount% ) = Trim$( GetField$( WorkLine$, 5, SEPARATOR ) )
           End Select
      End If

' For the other controls, adjust the indents prior to processing. Indent everything two
' spaces except for members of option groups, which get indented three spaces.

    Else
      Subfield$   = Trim$( GetField$( WorkLine$, 1, SEPARATOR ) )
      TempString$ = Left$( Subfield$, 4 )
      Select Case TempString$
        Case "End "
          IndentLine% = 0
          WholeBox%   = WholeBox% + 1
        Case "Opti", "Butt"
          If Mid$( Subfield$, 7, 1 ) = "G" Then
              ControlGroup = TRUE
              IndentLine%  = 2
            ElseIf Mid$( Subfield$, 7, 1 ) = "B" Or Left$( Subfield$, 6 ) = "Button" Then
              If ControlGroup = TRUE Then
                  IndentLine% = 3
              End If
          End If
        Case "Push"
          If ControlGroup Then
              IndentLine% = 3
            Else
              IndentLine% = 2
          End If
        Case "$"
          IndentLine% = 0
        Case Else
          IndentLine% = 2
      End Select
      CodeLines( aCONTROL_NAME, LineCount% ) = Space$( IndentLine% ) & Subfield$

' Then go through the workstring and put each subfield into its own element of the array.
' The four parameters of position and size are straightforward to deal with, being
' required for all controls except grouping commands.

      For i = aCONTROL_HORIZ_COORD To aCONTROL_HEIGHT
        CodeLines( i, LineCount% ) = Trim$( GetField$( WorkLine$, i + 1, SEPARATOR ) )
      Next i

' The remainder of the non-empty subfields go into the slots of the array depending on
' the value of their first character.

      For i = aCONTROL_LABEL To CommaCount%
        Subfield$ = ( Trim$( GetField$( WorkLine$, i + 1, SEPARATOR ) ) )
        If Subfield$ <> "" Then
            If Subfield$ = "0" Or Subfield$ = "3" Then     'Values unique to the Picture control
                CodeLines( aCONTROL_LABEL, LineCount% ) = CodeLines( aCONTROL_LABEL, LineCount% ) & SEPARATOR & "   " & Subfield$
              Else
                CharA% = Asc( Left$( Subfield$, 1 ) )
                Select Case CharA%

                  Case 46                       'Period, signalling a control ID
                    CodeLines( aCONTROL_ID, LineCount% ) = Subfield$

                  Case 182                      'Placeholder for a (previously removed) text string as label
                    CodeLines( aCONTROL_LABEL, LineCount% ) = ControlLabel$

                  Case Else
                    CodeLines( aCONTROL_LABEL, LineCount% ) = Subfield$

                End Select
              End If
         End If
      Next i
    End If

' Finally, add back any comment. If the whole line is a comment, add it as the first
' piece of the element of the array. Check comments for numeric values. If found, assume
' they are existing control ID numbers, and keep track of the lowest one. If no starting
' control ID number is given in the dialog box, the lowest ID number found in a comment
' will become the starting one.

    If Comment$ <> "" Then
        If Trim$( CodeLines( aCONTROL_NAME, LineCount% ) ) = "" Then
            CodeLines( aCONTROL_NAME, LineCount% ) = Comment$
          Else
            CodeLines( aCONTROL_COMMENT, LineCount% ) = Comment$
            CommentLength% = Len( Comment$ )
            If CommentLength% > 1 And CommentLength% < 4 Then
                CurrentID% = Val( Mid$( Comment$, 2 ) )
                If CurrentID% < 256 Then
                    If LowestID_Number% = 0 Then
                        LowestID_Number% = CurrentID%
                      Else
                        If CurrentID% < LowestID_Number% Then
                            LowestID_Number% = CurrentID%
                        End If
                    End If
                End If
            End If
        End If
    End If

  LineCount%  = LineCount% + 1
  CommaCount% = 0
  Comment$    = ""
Loop Until Len( InputString$ ) = 0

Legend$ = "Beginning of copied text:"

DialogBox:

Begin Dialog Dialog1Definition  332, 254, WaltsMacros$, .Dialog1ControlFunction
  OkButton       210, 230,  52,  14
  CancelButton   270, 230,  52,  14
  TextBox        130,  18,  24,  12,                                              .TextBoxHoriz
  TextBox        130,  34,  24,  12,                                              .TextBoxVert
  Text            18,  19, 108,   8, "Change hori&zontal coordinates by:",        .ChangeHorizText
  Text            18,  35, 108,   8, "Change &vertical coordinates by:",          .ChangeVertText
  CheckBox        18,  54, 120,  12, "&Add/change numeric control IDs",           .AddNumbers
  OptionGroup                                                                     .OptionGroupOptimizeAndSpace
   OptionButton  178,  18,  64,  12, "&No adjustment",                            .OptionButtonNone
   OptionButton  178,  32, 138,  12, "Align controls and &optimize control size", .OptionButtonOptimize
   OptionButton  178,  46,  88,  12, "&Space controls evenly",                    .OptionButtonSpace
  OptionGroup                                                                     .OptionGroupSpace
   OptionButton  192,  62,  72,  12, "H&orizontal spacing:",                      .OptionButtonHorizontalSpace
   OptionButton  192,  78,  72,  12, "V&ertical spacing:",                        .OptionButtonVerticalSpace
  DropListBox    271,  65,  28,  96, SpinnerV(),                                  .SpinnerHorizontal
  DropListBox    271,  81,  28, 160, SpinnerH(),                                  .SpinnerVertical
  Text            10, 212, 224,   8, "",                                          .Instructions
  Text            16, 122, 300,  80, DisplayString$
   PushButton     10, 230,  52,  14, "&Help",                                     .Help
  GroupBox        10,   4, 152,  98, "Align code/Move controls"
  GroupBox       170,   4, 152,  98, "Space controls"
  GroupBox        10, 107, 312, 102, Legend$
End Dialog

Dim Dialog1 As Dialog1Definition
If Dialog( Dialog1 ) = DIALOG_BUTTON_CANCEL Or BadInput = TRUE Then Exit Sub

' Get any change in the coordinates of the controls.

ChangeHorizontal% = Val( Trim$( Dialog1.TextBoxHoriz ) )
ChangeVertical%   = Val( Trim$( Dialog1.TextBoxVert ) )

' If a spacing or alignment option has been chosen, run its sub.

If Dialog1.OptionGroupOptimizeAndSpace = 1 Then
    OptimizeSub
  ElseIf Dialog1.OptionGroupOptimizeAndSpace = 2 Then
    HorizontalSpacing% = Val( SpinnerH( Dialog1.SpinnerHorizontal ) )
    VerticalSpacing%   = Val( SpinnerV( Dialog1.SpinnerVertical ) )
    If HorizontalSpacing% > 0 Then
        Call SpaceSub( aCONTROL_HORIZ_COORD, aCONTROL_WIDTH, HorizontalSpacing% )
    End If
    If VerticalSpacing% > 0 and BadInput = FALSE Then
        Call SpaceSub( aCONTROL_VERT_COORD, aCONTROL_HEIGHT, VerticalSpacing% )
    End If
    If BadInput = TRUE Then
        MsgBox "Please select only lines containing controls.", CRITICAL_MESSAGE, WaltsMacros$
        Exit Sub
    End If
End If

' If the option has been chosen to add control ID numbers (that is, to make them
' apparent), add them now. Numeric control IDs are kept as comments. If the copied text
' include comments that appear to be only numbers, they must be replaced by comments
' containing new ID numbers, even if those numbers are the same. (They will be different
' if the controls have been rearranged in the dialog box.) The comments have already been
' tested for numeric value, so the lowest one found will be the new starting control ID.
' If a comment contains other text, it will be retained, but with a control ID prefixed
' to it. The "Begin Dialog" and "End Dialog" lines are the only ones (besides empty
' lines) that won't get numbers--because, of course, they are not controls.

If Dialog1.AddNumbers = 1 Then
    If Left$( CodeLines( aCONTROL_NAME, 0 ), 5 ) = "Begin" Then
        ControlID_Number% = 0
      Else
        ControlID_Number% = LowestID_Number%
    End If
    i = 0
    Do
      Comment$ = CodeLines( aCONTROL_COMMENT, i )
      If Comment$ <> "" Then
          If Comment$ Like "[']" Or Comment$ Like "[ '0-9]#" Or Comment$ Like "[ '0-9][ 0-9]#" Then
              Comment$ = ""
            Else
              If Len( Comment$ ) > 3 Then
                  For j = 1 To 3
                    CharT$ = Mid$( Comment$, j, 1 )
                    If CharT$ Like "[! '0-9]" Then
                        Comment$ = " " & Mid$( Comment$, 2 )
                        Exit For
                      Else
                        If j = 3 Then
                            Comment$ = " " & Mid$( Comment$, 4 )
                        End If
                    End If
                  Next j
              End If
          End If
      End If
      If CodeLines( aCONTROL_NAME, i ) = "$" Or InStr( CodeLines( aCONTROL_NAME, i ), "Caption" ) > 0 Then
          Skip = TRUE
      End If
      If Left$( CodeLines( aCONTROL_NAME, i ), 5 ) <> "Begin" And _
         Left$( CodeLines( aCONTROL_NAME, i ), 3 ) <> "End" Then
          If Skip = FALSE Then
              CodeLines( aCONTROL_COMMENT, i ) = SINGLE_QUOTE & Trim$( Str$( ControlID_Number% ) ) & Comment$
              ControlID_Number%                = ControlID_Number% + 1
            Else
              CodeLines( aCONTROL_COMMENT, i ) = ""
              Skip = FALSE
          End If
      End If
      i = i + 1
    Loop Until i > UBound( CodeLines, 2 )
End If

' Now make adjustments to the coordinates in the array. If the controls are to be moved,
' add to or subtract from those figures to achieve that. If the "Begin Dialog" line is
' included but not the "End Dialog", don't shrink the whole box! That might leave some
' controls not copied outside the new dimensions. That danger doesn't apply, of course,
' if the change is to increase the size.

If ChangeHorizontal% <> 0 Then
    For i = 0 To UBound( CodeLines, 2 )
      z = Val( CodeLines( aCONTROL_HORIZ_COORD, i ) )
      If z <> 0 Then
          z = z + ChangeHorizontal%
          If z < 1 Then
               MsgBox "Control on line " & Trim$( Str$( i + 1 ) ) & " will be out of the dialog box!", CRITICAL_MESSAGE, WaltsMacros$
               Exit Sub
          End If
          CodeLines( aCONTROL_HORIZ_COORD, i ) = Trim$( Str$( z ) )
          If WholeBox% < 2 And InStr( CodeLines( aCONTROL_NAME, i ), "Begin" ) <> 0 And ChangeHorizontal% < 0 Then
              CodeLines( aCONTROL_HORIZ_COORD, i ) = Trim$( Str$( Val( CodeLines( aCONTROL_HORIZ_COORD, i ) ) - ChangeHorizontal% ) )
          End If
      End If
    Next i
End If

If ChangeVertical% <> 0 Then
    For i = 0 To UBound( CodeLines, 2 )
      z = Val( CodeLines( aCONTROL_VERT_COORD, i ) )
      If z <> 0 Then
          z = z + ChangeVertical%
          If z < 1 Then
              MsgBox "Control on line " & Trim$( Str$( i + 1 ) ) & " will be out of the dialog box!", CRITICAL_MESSAGE, WaltsMacros$
              Exit Sub
          End If
          CodeLines( aCONTROL_VERT_COORD, i ) = Trim$( Str$( z ) )
          If WholeBox% < 2 And InStr( CodeLines( aCONTROL_NAME, i ), "Begin" ) <> 0 And ChangeVertical% < 0 Then
              CodeLines( aCONTROL_VERT_COORD, i ) = Trim$( Str$( Val( CodeLines( aCONTROL_VERT_COORD, i ) ) - ChangeVertical% ) )
          End If
      End If
    Next i
End If

' The alignment of the first comma must be far enough to the right to clear all the
' control names, so the longest control name (which can range from 4 to 14 characters,
' "Text" to "StaticComboBox") determines the position of that first comma. Arbitrarily
' set the length of the longest control name to start the process. The longest name and
' the longest label together determine where the control IDs will line up. The "Begin
' Dialog" line and lines for the OptionGroups are ignored for this.

LongestControlName%  = 11
LongestControlLabel% = 0
For i = 0 To UBound( CodeLines, 2 )
  TempString$ = CodeLines( aCONTROL_NAME, i )
  If InStr( TempString$, "Begin" ) = 0 And InStr( TempString$, "nGroup" ) = 0 Then
      z = Len( TempString$ )
      If z > LongestControlName% Then
          LongestControlName% = z
      End If

' Scan for the longest label and the longest ID name (the string identifier).

      TempString$ = CodeLines( aCONTROL_LABEL, i )
      If TempString$ <> "" Then
          z = Len( TempString$ )
          If z > LongestControlLabel% Then
              LongestControlLabel% = z
          End If
      End If

      TempString$ = CodeLines( aCONTROL_ID, i )
      If TempString$ <> "" Then
          z = Len( TempString$ )
          If z > LongestID_Name% Then
              LongestID_Name% = z
          End If
      End If

  End If
Next i

FirstComma% = LongestControlName% + 5                  'Produces 2 spaces between control name and horizontal coordinate.
IDDot%      = FirstComma% + LongestControlLabel% + 18  'Produces at least 1 space between longest label and ID, or at least 3 spaces between
                                                       ' ID and last coordinate if there are no labels.
PosComment% = IDDot% + LongestID_Name% + 2             'Lines up the comments.

' Reassemble the coordinates for each line, adding spaces for proper alignment.

For LineCount% = 0 To UBound( CodeLines, 2 )

  WorkLine$ = CodeLines( aCONTROL_NAME, LineCount% )

  ArrayElement$ = CodeLines( aCONTROL_HORIZ_COORD, LineCount% )
  If ArrayElement$ <> "" Then
      If Left$( WorkLine$, 5 ) = "Begin" Then
          WorkLine$ = WorkLine$ & "  " & ArrayElement$
        Else
          z         = Len( ArrayElement$ )
          WorkLine$ = WorkLine$ & Space$( ( FirstComma% - z ) - Len( WorkLine$ ) ) & ArrayElement$
      End If
  End If

' These elements are all coordinates and need to be right-aligned on the comma.

  For i = aCONTROL_VERT_COORD To aCONTROL_HEIGHT
    ArrayElement$ = CodeLines( i, LineCount% )
    If ArrayElement$ <> "" Then
        z         = Len( ArrayElement$ )
        WorkLine$ = WorkLine$ & SEPARATOR & Space$( 4 - z ) & ArrayElement$
    End If
  Next i

' The next two elements are left-aligned.

  ArrayElement$ = CodeLines( aCONTROL_LABEL, LineCount% )
  If ArrayElement$ <> "" Then
      If InStr( WorkLine$, "Caption" ) Then
          z         = FirstComma% - 8
          WorkLine$ = WorkLine$ & Space$( z ) & ArrayElement$
        Else
          WorkLine$ = WorkLine$ & Separator & " " & ArrayElement$
      End If
  End If

  ArrayElement$ = CodeLines( aCONTROL_ID, LineCount% )
  If ArrayElement$ <> "" Then
      If Left$( WorkLine$, 5 ) = "Begin" Then
          WorkLine$ = WorkLine$ & SEPARATOR & " " & ArrayElement$
        Else
          z = IDDot% - Len( WorkLine$ )
          If z = 0 Then
              z = 5
          End If
          If InStr( WorkLine$, "onGro" ) Then
              WorkLine$ = WorkLine$ & Space$( z + 1 ) & ArrayElement$
            Else
              WorkLine$ = WorkLine$ & SEPARATOR & Space$( z ) & ArrayElement$
          End If
      End If
  End If

  ArrayElement$ = CodeLines( aCONTROL_COMMENT, LineCount% )
  If ArrayElement$ <> "" Then
      CommentOffset% = PosComment% - Len( WorkLine$ )
      If CommentOffset% < 0 Then CommentOffset% = 1
      WorkLine$      = WorkLine$ & Space$( CommentOffset% ) & ArrayElement$
  End If

  WorkLine$ = RTrim$( WorkLine$ )
  If WorkLine$ = "$" Then
      WorkLine$ = ""
    Else
      If Right$( WorkLine$, 1 ) = SEPARATOR Then
          WorkLine$ = Left$( WorkLine$, Len( WorkLine$ ) - 1 )
      End If
  End If

' Add back the indent, if any, of the whole dialog box.

  OutputString$ = OutputString$ & IndentWholeDialog$ & WorkLine$ & CRLF

' Clear the workline for the next line of the array.

  WorkLine$     = ""

Next LineCount%

Clipboard.Clear
Clipboard.SetText OutputString$

MsgBox "Straightened text copied to Clipboard!", INFORMATION_MESSAGE, WaltsMacros$

End Sub

'****************************************************************************************

Sub OptimizeSub

' Optimize placement and size of controls. Make some controls a standard size, following
' suggestions in the OML help file (which differ a little from Microsoft's GUI
' guidelines). Round up text area heights to the next multiple of 8; give checkboxes,
' textboxes, and option buttons a height of 12; make pushbuttons a minimum height of 14;
' size drop list boxes to be at least 64 (if a drop list box is a size smaller than about
' 16, its contents will be hidden). Align controls that have coordinates within 8 DLUs of
' each other.

' Mark a control with "H" to indicate it's been optimized for horizontal positioning, "V"
' for vertical. Controls with those letters will be ignored. Some controls will start out
' with both letters to show they are completely excluded from optimization.

Const aCOORD               As Integer = 2  'If optimizing horizontal coordinate, holds vertical, and vice versa
Const aROW                 As Integer = 1
Const HEIGHT_CHECKBOX      As Integer = 12
Const HEIGHT_PUSHBUTTON    As Integer = 14
Const HEIGHT_TEXTLINE      As Integer = 8
Const VAR_HORIZONTAL       As Integer = 5  '1 more than half the separation distance from which to grab controls.
Const VAR_VERTICAL         As Integer = 4

Dim ControlCount%
Dim ControlHeight%
Dim ControlLabel$
Dim CurrentCoord%
Dim CurrentRow%
Dim Difference%
Dim HorizontalCoordSum%
Dim MeanHorizontalCoord%
Dim MeanVerticalCoord%
Dim NewCoord$
Dim NextCoord%
Dim NextRow%
Dim SpaceBetween%
Dim TargetRow%
Dim Temp1$, Temp2$, Temp3$
Dim TempString$
Dim UBCodeLines%
Dim UBOptimizedLines%
Dim VerticalCoordSum%

Dim Swapped

Dim OptimizedLines() As String

Dim i As Integer, j As Integer, k As Integer, m As Integer, p As Integer, z As Integer

UBCodeLines% = UBound( CodeLines, 2 )
For i = 0 To UBCodeLines%' - 1
  TempString$ = Trim$( CodeLines( aCONTROL_NAME, i ) )
  p = InStr( TempString$, " " )
  If p <> 0 Then
      TempString$ = Left$( TempString$, p - 1 )
  End If
  ReDim Preserve OptimizedLines( aCOORD, i )
  ControlHeight% = Val( CodeLines( aCONTROL_HEIGHT, i ) )

' First, go through all the controls in the dialog box and adjust their height to the
' minimum values.

  Select Case TempString$

' Some lines can't be optimized. Mark them as being done already.

    Case "Begin", "End", "OptionGroup", "ButtonGroup", "Caption"
      CodeLines( aOPTIMIZED, i ) = "HV"

' If a text area is only one or two DLUs over a multiple of 8, take those extra DLUs off;
' otherwise, round up the height to the next multiple of 8.

    Case "Text"
      z = Int( ControlHeight% / HEIGHT_TEXTLINE )
      If ControlHeight% Mod HEIGHT_TEXTLINE > 2 Then
          CodeLines( aCONTROL_HEIGHT, i ) = Trim$( Str$( ( z + 1 ) * HEIGHT_TEXTLINE ) )
        Else
          CodeLines( aCONTROL_HEIGHT, i ) = Trim$( Str$( ( z * HEIGHT_TEXTLINE ) ) )
      End If

' Checkboxes, text boxes, and option buttons should be 12 DLUs in height.

    Case "CheckBox", "TextBox", "OptionButton"
      If ControlHeight% <> HEIGHT_CHECKBOX Then
          CodeLines( aCONTROL_HEIGHT, i ) = Trim$( Str$( HEIGHT_CHECKBOX ) )
      End If

' Drop list boxes should be a minimum of 64 to ensure their contents display.

    Case "DropComboBox", "DropListBox"
      If ControlHeight% < 64 Then
          CodeLines( aCONTROL_HEIGHT, i ) = "64"
      End If

' The two command buttons "OK" and "Cancel" are made a standard 50 x 14 size.

    Case "CancelButton", "OKButton"
      If ControlHeight% <> HEIGHT_PUSHBUTTON Then
          CodeLines( aCONTROL_HEIGHT, i ) = Trim$( Str$( HEIGHT_PUSHBUTTON ) )
      End If
      If CodeLines( aCONTROL_WIDTH, i ) <> "50" Then
          CodeLines( aCONTROL_WIDTH, i ) = "50"
      End If

' Other command buttons are made a minimum of 14 DLUs in height.

    Case "Button", "PushButton"
      If ControlHeight% <> HEIGHT_PUSHBUTTON Then
          CodeLines( aCONTROL_HEIGHT, i ) = Trim$( Str$( HEIGHT_PUSHBUTTON ) )
      End If

  End Select

Next i

' Then build an array of controls whose horizontal coordinates are within 8 DLUs of each
' other, a number fairly aggressive at bringing varyingly positioned controls into
' alignment. Put the first control into this secondary array and compare its horizontal
' position to that of all the other controls. If the position of this subsequent control
' is within 4 on each side of the first control, add it to the secondary array, and take
' the average of the horizontal positions for comparison to the next control. It may be
' that each time a control's position matches, the average horizontal position changes.
' If a control is added to the array, remove it from further consideration by adding "H"
' to the main array of controls. The secondary array contains the control name, the
' number of its row in the main array, and its vertical coordinate, so as to make sure
' the vertical spacing meets minimum requirements.

For i = 0 To UBCodeLines% - 1
  If InStr( CodeLines( aOPTIMIZED, i ), "H" ) = 0 Then
      ReDim OptimizedLines( 2, 0 )
      OptimizedLines( aCONTROL_NAME, 0 ) = Trim$( CodeLines( aCONTROL_NAME, i ) )
      OptimizedLines( aROW, 0 )          = Str$( i )
      OptimizedLines( aCOORD, 0 )        = CodeLines( aCONTROL_VERT_COORD, i )
      MeanHorizontalCoord%               = Val( CodeLines( aCONTROL_HORIZ_COORD, i ) )
      HorizontalCoordSum%                = MeanHorizontalCoord%
      ControlCount%                      = 1
      For j = i + 1 To UBCodeLines%
        z = Val( CodeLines( aCONTROL_HORIZ_COORD, j ) )
        If z < MeanHorizontalCoord% + VAR_HORIZONTAL And z > MeanHorizontalCoord% - VAR_HORIZONTAL Then
            ControlCount%                                      = ControlCount% + 1
            HorizontalCoordSum%                                = HorizontalCoordSum% + z
            MeanHorizontalCoord%                               = HorizontalCoordSum% / ControlCount%
            ReDim Preserve OptimizedLines( 2, ControlCount% - 1 )
            OptimizedLines( aCONTROL_NAME, ControlCount% - 1 ) = Trim$( CodeLines( aCONTROL_NAME, j ) )
            OptimizedLines( aROW, ControlCount% - 1 )          = Str$( j )
            OptimizedLines( aCOORD, ControlCount% - 1 )        = CodeLines( aCONTROL_VERT_COORD, j )
        End If
      Next j

' If after going through all the controls, none are found to be close to the first one,
' it is marked as having been analyzed with the "H", the secondary array is cleared, and
' the next available control is put in as the first element to repeat the process.
' Otherwise, change the horizontal coordinates of all the controls in the main array to
' the average of all the close elements.

      If ControlCount% = 1 Then
          CodeLines( aOPTIMIZED, i ) = CodeLines( aOPTIMIZED, i ) & "H"
        Else
          UBOptimizedLines% = UBound( OptimizedLines, 2 )
          NewCoord$         = Trim$( Str$( MeanHorizontalCoord% ) )
          For k = 0 To UBOptimizedLines%
            If MeanHorizontalCoord% > 0 Then
                TargetRow%                                    = Val( OptimizedLines( aROW, k ) )
                CodeLines( aCONTROL_HORIZ_COORD, TargetRow% ) = NewCoord$
                CodeLines( aOPTIMIZED, TargetRow% )           = CodeLines( aOPTIMIZED, TargetRow% ) & "H"
            End If
          Next k

' Sort the secondary array by vertical coordinate. Use a simple-to-code bubble sort.

         Do
           Swapped = FALSE
           For m = 0 To UBOptimizedLines% - 1
             If Val( OptimizedLines( aCOORD, m ) ) > Val( OptimizedLines( aCOORD, m + 1 ) ) Then
                 Temp1$                                 = OptimizedLines( aCONTROL_NAME, m )
                 Temp2$                                 = OptimizedLines( aROW, m )
                 Temp3$                                 = OptimizedLines( aCOORD, m )
                 OptimizedLines( aCONTROL_NAME, m )     = OptimizedLines( aCONTROL_NAME, m + 1 )
                 OptimizedLines( aROW, m )              = OptimizedLines( aROW, m + 1 )
                 OptimizedLines( aCOORD, m )            = OptimizedLines( aCOORD, m + 1 )
                 OptimizedLines( aCONTROL_NAME, m + 1 ) = Temp1$
                 OptimizedLines( aROW, m + 1 )          = Temp2$
                 OptimizedLines( aCOORD, m + 1 )        = Temp3$
                 Swapped = TRUE
             End If
           Next m
         Loop Until Swapped = FALSE

' Then check that each subsequent control is appropriately spaced above its predecessor.
' A set of the same controls (a group of option buttons, for example, or text areas) will
' all be spaced evenly apart. Otherwise, just make sure the next control is a minimum
' distance away from the current control (so the spacing between those controls may not
' be uniform).

          For m = 0 To UBOptimizedLines% - 1
            CurrentRow%   = Val( OptimizedLines( aROW, m ) )
            NextRow%      = Val( OptimizedLines( aROW, m + 1 ) )
            CurrentCoord% = Val( CodeLines( aCONTROL_VERT_COORD, CurrentRow% ) )
            NextCoord%    = Val( CodeLines( aCONTROL_VERT_COORD, NextRow% ) )
            Difference%   = NextCoord% - CurrentCoord%
            ControlLabel$ = OptimizedLines( aCONTROL_NAME, m )

            If OptimizedLines( aCONTROL_NAME, m + 1 ) = ControlLabel$ Then

                Select Case ControlLabel$

                  Case "Text"
                    ControlHeight% = Val( CodeLines( aCONTROL_HEIGHT, CurrentRow% ) )
                    SpaceBetween%  = 8

                  Case "CheckBox", "TextBox", "OptionButton"
                    ControlHeight% = 12
                    SpaceBetween%  = 2

                  Case "Button", "CancelButton", "OKButton", "PushButton"
                    ControlHeight% = 14
                    SpaceBetween%  = 4

                End Select

' If the next control name is the same as the current one, make the distance between them
' a constant.

                CodeLines( aCONTROL_VERT_COORD, NextRow% ) = Trim$( Str$( CurrentCoord% + ControlHeight% + SpaceBetween% ) )
                CodeLines( aOPTIMIZED, NextRow% )          = CodeLines( aOPTIMIZED, NextRow% ) & "V"

' Otherwise, if the next control name is different from the current one, just make sure
' the distance between them is at least a certain number.

              Else

                Select Case ControlLabel$

                  Case "Button", "CancelButton", "OKButton", "PushButton"
                    If Difference% < 16 Then
                        CodeLines( aCONTROL_VERT_COORD, NextRow% ) = Trim$( Str$( CurrentCoord% + HEIGHT_PUSHBUTTON + 2 ) )
                        CodeLines( aOPTIMIZED, NextRow% )          = CodeLines( aOPTIMIZED, NextRow% ) & "V"
                    End If

                  Case "CheckBox", "TextBox", "OptionButton"
                    If Difference% < 14 Then
                        CodeLines( aCONTROL_VERT_COORD, NextRow% ) = Trim$( Str$( CurrentCoord% + HEIGHT_CHECKBOX + 2 ) )
                        CodeLines( aOPTIMIZED, NextRow% )          = CodeLines( aOPTIMIZED, NextRow% ) & "V"
                    End If

                  Case "Text"
                    If Difference% < 10 Then
                        CodeLines( aCONTROL_VERT_COORD, NextRow% ) = Trim$( Str$( CurrentCoord% + HEIGHT_TEXTLINE + 2 ) )
                        CodeLines( aOPTIMIZED, NextRow% )          = CodeLines( aOPTIMIZED, NextRow% ) & "V"
                    End If

                End Select

            End If

          Next m
     End If
  End If
Next i

' Now go through the array of controls again to align close ones vertically, exactly as with the
' horizontal alignment. Add "V" to indicate a control has been analyzed.

For i = 0 To UBCodeLines% - 1
  If InStr( CodeLines( aOPTIMIZED, i ), "V" ) = 0 Then
      ReDim OptimizedLines( 2, 0 )
      OptimizedLines( aCONTROL_NAME, 0 ) = Trim$( CodeLines( aCONTROL_NAME, i ) )
      OptimizedLines( aROW, 0 )          = Str$( i )
      OptimizedLines( aCOORD, 0 )        = CodeLines( aCONTROL_HORIZ_COORD, i )
      MeanVerticalCoord%                 = Val( CodeLines( aCONTROL_VERT_COORD, i ) )
      VerticalCoordSum%                  = MeanVerticalCoord%
      ControlCount%                      = 1
      For j = i + 1 To UBCodeLines%
        If InStr( CodeLines( aOPTIMIZED, j ), "V" ) = 0 Then
            z = Val( CodeLines( aCONTROL_VERT_COORD, j ) )
            If z < MeanVerticalCoord% + VAR_VERTICAL And z > MeanVerticalCoord% - VAR_VERTICAL Then
                ControlCount%                                      = ControlCount% + 1
                VerticalCoordSum%                                  = VerticalCoordSum% + z
                MeanVerticalCoord%                                 = VerticalCoordSum% / ControlCount%
                ReDim Preserve OptimizedLines( 2, ControlCount% - 1 )
                OptimizedLines( aCONTROL_NAME, ControlCount% - 1 ) = Trim$( CodeLines( aCONTROL_NAME, j ) )
                OptimizedLines( aROW, ControlCount% - 1 )          = Str$( j )
                OptimizedLines( aCOORD, ControlCount% - 1 )        = CodeLines( aCONTROL_HORIZ_COORD, j )
            End If
        End If
      Next j

' If no other element is close enough to align with the first one, mark it as having been
' analyzed already, and go on to the next one. Otherwise, change the horizontal
' coordinates of all the controls in the main array to the average of all the close
' elements. Also mark the elements of the array so they aren't processed again. Since the
' horizontal dimensions of controls can vary widely, don't bother trying to space them
' nicely, as was done in the vertical dimension.

      If ControlCount% = 1 Then
          CodeLines( aOPTIMIZED, i ) = CodeLines( aOPTIMIZED, i ) & "V"
        Else
          UBOptimizedLines%          = UBound( OptimizedLines, 2 )
          NewCoord$                  = Trim$( Str$( MeanVerticalCoord% ) )
          For k = 0 To UBOptimizedLines%
            If MeanVerticalCoord% > 0 Then
                TargetRow%                                   = Val( OptimizedLines( aROW, k ) )
                CodeLines( aCONTROL_VERT_COORD, TargetRow% ) = NewCoord$
                CodeLines( aOPTIMIZED, TargetRow% )          = CodeLines( aOPTIMIZED, TargetRow% ) & "V"
            End If
          Next k
      End If
  End If
Next i

End Sub

'****************************************************************************************

Sub Help

Const DLG_STATEMENT_CANCEL As Integer = 102

Dim AlignHelp$
Dim IDHelp$
Dim OptimizeHelp$
Dim SpaceHelp$

AlignHelp$    = "Leave both boxes empty to simply align control coordinates in the copied lines of code. "
AlignHelp$    = AlignHelp$ & "Enter a number in the first box to move controls right by that amount. "
AlignHelp$    = AlignHelp$ & "Enter a number in the second box to move controls down. Negative numbers "
AlignHelp$    = AlignHelp$ & "move controls left, or up. Include the " & DOUBLE_QUOTE & "Begin Dialog" & DOUBLE_QUOTE
AlignHelp$    = AlignHelp$ & "line to expand the whole dialog box; however, entering negative numbers "
AlignHelp$    = AlignHelp$ & "will not make the dialog box shrink."

IDHelp$       = "Check the checkbox to add numeric identifiers as comments to each line of code in the "
IDHelp$       = IDHelp$ & "copied text."

OptimizeHelp$ = "This option makes the macro attempt to align controls that are already nearly aligned "
OptimizeHelp$ = OptimizeHelp$ & "with each other--within 8 DLUs horizontally, and 6 DLUs vertically. "
OptimizeHelp$ = OptimizeHelp$ & "(This is not the same as aligning them to a grid.) The macro also "
OptimizeHelp$ = OptimizeHelp$ & "re-sizes controls to standard heights: Text boxes and radio buttons are "
OptimizeHelp$ = OptimizeHelp$ & "set to 12 DLUs; pushbuttons, to 14; and text areas, to multiples of 8. "
OptimizeHelp$ = OptimizeHelp$ & "Horizontal dimensions are not affected."

SpaceHelp$    = "This option makes the space between controls a constant amount. Enter a number between 1 "
SpaceHelp$    = SpaceHelp$ & "and 16 to space controls evenly across, and between 1 and 8 to space "
SpaceHelp$    = SpaceHelp$ & "controls evenly up and down. NOTE that increasing the space by too much may "
SpaceHelp$    = SpaceHelp$ & "move controls out of the dialog box, causing it to not run."

Begin Dialog Dialog2Definition  256, 318, WaltsMacros$, .Dialog2ControlFunction
  OkButton       194, 296,  52,  14
  CancelButton   245, 309,   1,   1
  GroupBox        12,   4, 152,  27, "Align code/Move controls"
  Text            20,  17, 108,   8, "Change hori&zontal coordinates by:"
  TextBox        132,  16,  24,  12,                                              .TextBox
  Text            10,  29, 160,   3, ""
  Text            10,  36, 236,  48, AlignHelp$
  CheckBox        12,  98, 120,  12, "&Add/change numeric control IDs",           .CheckBox
  Text            10, 116, 236,  16, IDHelp$
  OptionGroup                                                                     .OptionGroup1
   OptionButton   12, 146, 188,  12, "Align controls and &optimize control size"
  Text            10, 164, 236,  48, OptimizeHelp$
  OptionGroup                                                                     .OptionGroup2
   OptionButton   12, 226,  88,  12, "&Space controls evenly"
  Text            12, 244, 236,  40, SpaceHelp$
End Dialog

Dim Dialog2 As Dialog2Definition
On Error Resume Next
Dialog Dialog2
If Err = DLG_STATEMENT_CANCEL Then Exit Sub

End Sub

'****************************************************************************************

Sub SpaceSub( WhichCoordinate%, ControlDimension%, Separation% )

Const COORDINATE   As Integer = 0
Const CONTROL_SIZE As Integer = 1
Const INDEX        As Integer = 2

Dim CurrentBaseline%
Dim Greatest%
Dim PreviousBaseline%
Dim SpaceBetween%
Dim UBCodeLines%

Dim i As Integer, j As Integer, k As Integer, x As Integer, z As Integer

Dim TempArray() As Integer

UBCodeLines% = UBound( CodeLines, 2 )
ReDim TempArray( 2, UBCodeLines% )
For i = 0 To UBCodeLines%
  If i = 0 Then
      TempArray( COORDINATE, i )   = Val( CodeLines( WhichCoordinate%, i ) )
      TempArray( CONTROL_SIZE, i ) = Val( CodeLines( ControlDimension%, i ) )
      TempArray( INDEX, i )        = i
    Else
      For j = 0 To i
        x = Val( CodeLines( WhichCoordinate%, i ) )
        If x < TempArray( COORDINATE, j ) Then
            For k = i To j + 1 Step -1
              TempArray( COORDINATE, k )   = TempArray( COORDINATE, k - 1 )
              TempArray( CONTROL_SIZE, k ) = TempArray( CONTROL_SIZE, k - 1 )
              TempArray( INDEX, k )        = TempArray( INDEX, k - 1 )
            Next k
            TempArray( COORDINATE, j )   = Val( CodeLines( WhichCoordinate%, i ) )
            TempArray( CONTROL_SIZE, j ) = Val( CodeLines( ControlDimension%, i ) )
            TempArray( INDEX, j )        = i
            Exit For
          Else
            If TempArray( COORDINATE, j ) = 0 Then
                TempArray( COORDINATE, j )   = Val( CodeLines( WhichCoordinate%, i ) )
                TempArray( CONTROL_SIZE, j ) = Val( CodeLines( ControlDimension%, i ) )
                TempArray( INDEX, j )        = i
                Exit For
            End If
        End If
      Next j
  End If
  If TempArray( CONTROL_SIZE, i ) = 0 Then
      BadInput = TRUE
      Exit Sub
  End If
Next i

SpaceBetween%     = 0
i = 0
CurrentBaseline%  = TempArray( COORDINATE, i )
PreviousBaseline% = TempArray( COORDINATE, i )
Do
  If TempArray( COORDINATE, i ) = CurrentBaseline% Then
      TempArray( COORDINATE, i ) = PreviousBaseline% + SpaceBetween%
      z = TempArray( CONTROL_SIZE, i )
      If z > Greatest% Then
          Greatest% = z
      End If
    Else
      PreviousBaseline% = TempArray( COORDINATE, i - 1)
      SpaceBetween%     = Greatest% + Separation%
      Greatest%         = 0
      CurrentBaseline%  = TempArray( COORDINATE, i )
      i = i - 1
  End If
  i = i + 1
Loop Until i > UBCodeLines%

For i = 0 To UBCodeLines%
  CodeLines( WhichCoordinate%, TempArray( INDEX, i ) ) = Trim$( Str$( TempArray( COORDINATE, i ) ) )
Next i

End Sub

'****************************************************************************************

Function Dialog1ControlFunction( Id$, Action%, SVal& )

Const CHECKED        As Integer = 1
Const CONTROL_CHANGE As Integer = 2
Const DISABLED       As Integer = 0
Const ENABLED        As Integer = 1
Const INITIALIZE     As Integer = 1
Const KEEP_DLG_OPEN  As Integer = -1
Const UNCHECKED      As Integer = 0

Select Case Action%

  Case INITIALIZE

    If BadInput = FALSE Then
        DlgText   "Instructions",       "Click OK to process the copied text and place it on the Clipboard."
      Else
        DlgText   "Instructions",       "The macro cannot process the input string. Click OK or Cancel to exit."
    End If
    DlgValue  "AddNumbers",                  UNCHECKED
    DlgEnable "OptionButtonHorizontalSpace", DISABLED
    DlgEnable "OptionButtonVerticalSpace",   DISABLED
    DlgEnable "SpinnerHorizontal",           DISABLED
    DlgEnable "SpinnerVertical",             DISABLED
    If UBound( CodeLines, 2 ) = 0 Then
        DlgEnable "OptionButtonNone",            DISABLED
        DlgEnable "OptionButtonOptimize",        DISABLED
        DlgEnable "OptionButtonSpace",           DISABLED
    End If
    If BadInput Then
        DlgEnable "AddNumbers",                  DISABLED
        DlgEnable "ChangeHorizText",             DISABLED
        DlgEnable "ChangeVertText",              DISABLED
        DlgEnable "OptionButtonHorizontalSpace", DISABLED
        DlgEnable "OptionButtonVerticalSpace",   DISABLED
        DlgEnable "TextBoxHoriz",                DISABLED
        DlgEnable "TextBoxVert",                 DISABLED
    End If


  Case CONTROL_CHANGE

    Select Case Id$

      Case "Help"
        Help
        Dialog1ControlFunction = KEEP_DLG_OPEN

      Case "OptionButtonNone", "OptionButtonOptimize", "OptionButtonSpace"

        Select Case DlgValue( "OptionGroupOptimizeAndSpace" )

          Case 0 To 1
            DlgEnable "OptionButtonHorizontalSpace", DISABLED
            DlgEnable "OptionButtonVerticalSpace",   DISABLED
            DlgValue  "SpinnerHorizontal",           0
            DlgEnable "SpinnerHorizontal",           DISABLED
            DlgValue  "SpinnerVertical",             0
            DlgEnable "SpinnerVertical",             DISABLED

          Case 2
            DlgEnable "OptionButtonHorizontalSpace", ENABLED
            DlgEnable "OptionButtonVerticalSpace",   ENABLED
            DlgEnable "SpinnerHorizontal",           ENABLED
            DlgEnable "SpinnerVertical",             ENABLED

        End Select

      Case "OptionButtonHorizontalSpace"
        If DlgValue( "OptionGroupSpace" ) = 0 Then
            DlgFocus  "SpinnerHorizontal"
          Else
            DlgValue  "SpinnerHorizontal",           0
        End If

      Case "OptionButtonVerticalSpace"
        If DlgValue( "OptionGroupSpace" ) = 1 Then
            DlgFocus  "SpinnerVertical"
          Else
            DlgValue  "SpinnerVertical",             0
        End If

      Case "SpinnerHorizontal"
        DlgValue  "OptionGroupSpace",                0
        DlgValue  "SpinnerVertical",                 0

      Case "SpinnerVertical"
        DlgValue  "OptionGroupSpace",                1
        DlgValue  "SpinnerHorizontal",               0

    End Select

End Select

End Function

'****************************************************************************************

Function Dialog2ControlFunction( Id$, Action%, SVal& )

Const CHECKED      As Integer = 1
Const FOCUS_CHANGE As Integer = 4
Const INITIALIZE   As Integer = 1

Select Case Action%

  Case INITIALIZE

    DlgValue "CheckBox", CHECKED


  Case FOCUS_CHANGE

    If Id$ <> "Cancel" Then
        DlgFocus "OK"
    End If

End Select

End Function
'145665628
