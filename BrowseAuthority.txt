' MacroName:BrowseAuthority.2025.04
' MacroDescription:Browses the Authority File using an existing heading or selected text
' within a field, and retrieves authority records for headings in authority 5XX fields.
'
' This macro was written by Walter F. Nickeson and last updated 9 May 2025.
' It was developed in Connexion client 3.1 running in Windows 11 Enterprise and 64-bit
' Windows 10 Pro.
' Walt's macros for the Connexion client: https://github.com/wnickeson/WaltsMacros
' wfnickeson@zohomail.com
'
' Copyright 2025 Walter F. Nickeson.
'
' Permission is hereby granted, free of charge, to any person obtaining a copy of this
' software and associated documentation files (the "Software"), to deal in the Software
' without restriction, including without limitation the rights to use, copy, modify,
' merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
' permit persons to whom the Software is furnished to do so, subject to the following
' conditions:
'
' The above copyright notice and this permission notice shall be included in all copies
' or substantial portions of the Software.
'
' THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
' INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
' PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
' HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
' CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
' THE USE OR OTHER DEALINGS IN THE SOFTWARE.
'
'****************************************************************************************
' How it works: This macro and my "GetAuthority" macro work together to efficiently add
' authorized headings to a bibliographic record. Use this macro, "BrowseAuthority", to
' search the Authority File, and use "GetAuthority" to paste an authorized heading into
' the bibliographic record in the right place.
'
' In a bibliographic or authority record, place the cursor anywhere in a heading field,
' or select text within a field, and run the macro. It browses the Authority File with
' the content of that heading field, or with the selected text. The result is a browse
' list that places the heading in its alphabetical context. In an authority record, if no
' text is selected, or if the cursor is not placed in a heading field, the macro can be
' run to retrieve the record for the heading in a 5XX field, if one is present, or to
' browse for a heading referred to in certain note fields, if present. If the authority
' record contains no notes or 5XX fields, the macro will browse for the base authorized
' heading. For a name, the "base heading" is the name without a title or a corporate name
' without subordinate units, and for a subject, it is the term without subdivisions.
'
' The macro cannot browse with text in non-Latin script, or text that contains Unicode
' characters. If the selection contains characters encoded as Windows-1252, rather than
' as OCLC-MARC, the macro's browse will probably fail.
'
' The maximum length of a browse string is 60 characters. The macro truncates any string
' longer than that limit, and shows that in the dialog box by putting the characters "<!"
' after the truncated string. Using this macro to browse long names, such as a corporate
' body with several levels in a hierarchy, might not return proper results; it might be
' better to employ a keyword search, such as used by my "SearchAuthority" macro.
'
' In a bibliographic record, heading fields are 1XX, 490, 600 to 653, 655, 700 to 730,
' and 800 to 830. The cursor must be placed within one of these fields to browse its
' contents. Fields 647, 648, and 655 can be browsed on by this macro only if they are
' coded as being LCSH (second indicator value "0"). Field 653 will be browsed on as if
' it were LCSH, but you have to tell the macro what kind of browse to do.
'
' In an authority record, heading fields are 1XX, 4XX, and 5XX (with the exceptions of
' X47, X48, X55, and X62). These heading fields may be browsed by placing the cursor in
' them and running the macro, just as in a bibliographic record. If the macro is run
' with the cursor not placed in a heading field, the macro displays the 5XX fields,
' grouped according to the relationship codes in subfield $w. Select a heading to
' retrieve its authority record. Headings may also be found embedded in note fields 260,
' 360, 680, and 681, as terms related to the established heading. The macro collects all
' such "referred to" headings and displays them, separately from the headings in the 5XX
' fields, in alphabetical order, with subdivisions appearing first. Select a heading to
' browse on. Because the authorized heading is presented as an option for browsing, minus
' any additions, in some cases a corporate body may appear twice in the macro's dialog
' box: as the base heading with its subordinate unit(s) removed, to be browsed upon, and
' also as the hierarchical superior of the authorized heading in the record, whose
' authority record may be retrieved.
'
' The macro fetches the authority record for a heading in a 5XX field by means of a
' search, rather than a browse. Because searching the Authority File is done by keywords,
' the macro may have to scroll through several screens to arrive at the desired record.
' For example, a search on the broader term "Plants" in a 550 field retrieves over 2500
' records. The Client displays 100 records per page, and it must show about 16 pages
' before it reaches the one containing the record for "Plants". It is possible to use the
' macro "Browse" command to get to such a heading much more quickly, but that approach
' will not always work, and the programming involved is more complex.
'
' If the cursor is placed in a heading field that consists of a simple name or title, or
' an undivided subject term, the macro executes the browse immediately, choosing the
' index in which to browse according to the field's tag. In a bibliographic record, the
' macro ignores an initial subfield $i, as well as linking, control, and relator
' subfields. For other headings browsed upon from the cursor being positioned in the
' heading field, the macro presents these options:
'
'  + For a corporate body with subordinate units: To browse the Corporate/Conference
'    Names index for each level of the hierarchy, starting from the complete heading in
'    the field up to the main body only (subfield $a).
'
'  + For a name/title heading: To browse the appropriate Name index for the name alone,
'    the Titles index for the title alone, or the appropriate Name index with the title
'    added as an expanded scan. The content of subfield $k (a form subheading, e.g.,
'    "Manuscript" or "Selections") is considered a title in any case. The same options
'    are available if the cursor is placed in a 240 field.
'
'  + For a subject heading with subdivisions: To browse the LCSH index for the main
'    heading (subfield $a), the Subdivision Headings index for any of the subject
'    subdivisions and for some of their combinations, or the LCSH index for the main
'    heading with the subdivision(s) added as an expanded scan.
'
'  + For a genre/form term: The macro language doesn't allow for browsing the genre
'    index, so for any genre term, the only option is to browse the LCSH index as a
'    subject term. If the term is identified as being LCSH, whether by the second
'    indicator value of zero or by the presence of "lcsh" in subfield $2, it is browsed
'    immediately in the Subject index; if not, a message box pops up asking for
'    confirmation to proceed.
'
' In all these options, the headings to be browsed are presented in normalized form (all
' capitals, with diacritical marks and punctuation removed) in editable text boxes for
' review and modification, if desired, before searching.
'
' In a bibliographic record, a 720 field marked as a personal name will be treated as if
' it were a 700 field and browsed as such. A 720 field with no indication of what type of
' name it is will be treated as a selection. In that case, the presence of a comma
' suggests that the heading is a personal name in inverted form, so the macro offers that
' as the first search option. Otherwise, the macro considers that name to be in direct
' order, and browses the LC Names index.
'
' If text within a field has been selected, the macro displays the normalized string and
' asks whether to browse in the LC Names, LCSH, or Titles indexes with the selection. If
' the selection is of two or three words, an additional option is offered: to invert the
' selection and browse the Personal Names index by the last word (or the last two, if
' they are joined by a hyphen, or if the middle word is one of the prefixes "De", "Du",
' "Le", "St.", "Van", or "Von"--see RDA Appendix F, 11.4, or AACR2 22.5D1). This option
' is based on the assumption that such a selection is likely to be the name of a person.
' The macro also looks in a text selection for some words that might indicate a corporate
' body, such as "&", "of", "Commission", names of certain cities and countries, etc. If
' such words are found, the macro chooses the Corporate/Conference Name index as the
' default database in which to browse. If the selection contains a forward slash
' surrounded by spaces--such as might be found in a contents note (e.g., "Clair de lune /
' $r Claude Debussy")--the macro treats the part before the slash as a title, and the
' part following as a statement of responsibility. The macro thus considers the selection
' to be a name/title field, and can browse for it as if it were such a field, presenting
' the option of inverting a two- or three-word "statement of responsibility" as described
' above. As with some of the field browses, the search string is able to be edited before
' starting the browse.
'
' Keep a selection within a field. A selection can span subfields, but the subfield codes
' are ignored, and the whole selection is treated as a phrase for browsing. Don't include
' initial articles in a selection, although if the macro recognizes them (in English,
' French, German, Spanish, and Italian) it will remove them and offer a title browse as
' the default option--unless there is an apparent statement of responsibility, as
' described above.
'
' The 5XX fields in authority records for juvenile subject headings (identified by "sj"
' as the LCCN prefix in field 010) are searched as regular LC subject headings.
'
' If no matching heading is found for a selection, but the selection should be added to a
' bibliographic record as a name heading anyway, my macro "PasteInverted" will paste the
' selection without having to select and copy it again. That macro also offers the option
' of inverting a term of two or three words before pasting.
'
' The "normalization" of the search string follows NACO normalization rules, found at
' http://www.loc.gov/aba/pcc/naco/normrule-2.html. Text does not need to be normalized
' before Connexion searches the Authority File, but the process helps with display within
' the limited capabilities of the dialog box.
'****************************************************************************************

Option Explicit

Declare Sub Fill5XXArrays( WhichArray%, InArray() As String, Index%, ArrayLabel$, ArrayCount% )
Declare Sub FillStopwords
Declare Sub FillStoreRefs( InString$ )

Declare Function AssignLabels                 ( InString$ )       As String
Declare Function BrowseFromAuthorityRecord                        As String
Declare Function BrowseFromSelectedText                           As String
Declare Function ChooseBrowse                 ( OptionParam1$, _
                                                OptionParam2$, _
                                                OptionParam3$ )   As Integer
Declare Function DisplayAuthorityRecordBrowses( OutString$ )      As String
Declare Function DoubleSpaceErase             ( SomeString$ )     As String
Declare Function FlatSharpFix                 ( SomeString$, _
                                                Switch% )         As String
Declare Function InitialArticle               ( SomeString$ )     As String
Declare Function InvertOption                 ( SomeString$ )     As Integer
Declare Function Normalize                    ( InString$, _
                                                KeepDelimiter )   As String
Declare Function Plural                       ( Label$, n% )      As String

Declare Function Dialog2ControlFunction            ( Id$, Action%, SVal& )
Declare Function Dialog3_1_ListBoxControlFunction  ( Id$, Action%, SVal& )
Declare Function Dialog3_2_ListBoxesControlFunction( Id$, Action%, SVal& )
Declare Function Dialog3_3_ListBoxesControlFunction( Id$, Action%, SVal& )
Declare Function Dialog3_4_ListBoxesControlFunction( Id$, Action%, SVal& )

Global CS As Object

Global Const DLG_STATEMENT_CANCEL       As Integer = 102
Global Const FOCUS_CHANGE               As Integer = 4
Global Const INITIALIZE                 As Integer = 1

Global Const aHEADING_TAG               As Integer = 2
Global Const aNORMALIZED_HEADING        As Integer = 1
Global Const aRAW_HEADING               As Integer = 0
Global Const aRELATION_CODE             As Integer = 4
Global Const aRELATION_TERM             As Integer = 3
Global Const AUTHORITY_FILE             As String  = "AF"
Global Const BROWSE_AUTHORIZED_HEADING  As String  = "1"
Global Const BROWSE_REFERRED_TO_HEADING As String  = "2"
Global Const CURSOR_IN_240              As Integer = -1
Global Const FIELD_DATA_BEGINS          As Integer = 6
Global Const GET_5XX_HEADING            As String  = "3"
Global Const HEADING_NAME_TITLE         As Integer = 1
Global Const INVERTIBLE_AS_OPTION       As Integer = 1   'The case of a selection being partly stopwords, i.e., inverting is an option.
Global Const INVERTIBLE_BY_DEFAULT      As Integer = 2   'The case of a selection containing no stopwords, i.e., inverting is the first possibility.
Global Const MUSIC_SIGN_TO_WORD         As Integer = 0   'A flag to tell the function to convert the music flat and sharp signs
                                                         ' to the words "-flat" and "-sharp".
Global Const NAME_INVERTED              As Integer = 4
Global Const NAME_SELECT                As Integer = 3
Global Const NOT_INVERTIBLE             As Integer = 0   'The case of a selection being all stopwords, i.e., not being invertible at all.
Global Const NOT_NAME_TITLE             As Integer = 0
Global Const NO_SELECTION               As Integer = -1
Global Const SELECTION_NAME_TITLE       As Integer = 2
Global Const STOPWORD_COUNT             As Integer = 367
Global Const TITLE_SELECT               As Integer = 6

Global COMMA                            As String*1
Global DASH                             As String*1
Global DELIMITER                        As String*1
Global ESC                              As String*1
Global FAILURE                          As String*1
Global QUIT                             As String*1
Global SUBJ_SUBDIV                      As String*1

Global AFIndex$
Global BaseHeading$
Global BrowseRefs$
Global CountOf5XX%
Global CountOfNames%
Global CountOfReferredTo%
Global CountOfSubdivisions%
Global Display5XX_1Count%
Global Display5XX_1Label$
Global Display5XX_2Count%
Global Display5XX_2Label$
Global Display5XX_3Count%
Global Display5XX_3Label$
Global Invertibility%
Global Language$
Global MatchString$
Global NameString$
Global NameTitleSplit%
Global NameTitleType%
Global NormalizedString$
Global SearchOption1$
Global SearchOption2$
Global SearchOption3$
Global SearchTerm1$
Global SearchTerm2$
Global SubjectString$
Global TitleHeading$
Global TitleString$
Global WaltsMacros$

Global ProbableTitle
Global TextSelection

Global Display5XX_1() As String
Global Display5XX_2() As String
Global Display5XX_3() As String
Global DisplayRefs()  As String
Global Names()        As String
Global Stopwords()    As String
Global Store5XX()     As String
Global StoreRefs()    As String
Global Subdivisions() As String

'****************************************************************************************

Sub Main

ReDim Display5XX_1( 0 )
ReDim Display5XX_2( 0 )
ReDim Display5XX_3( 0 )

On Error Resume Next
Set CS = GetObject( , "Connex.Client" )
On Error GoTo 0
If CS Is Nothing Then Set CS = CreateObject( "Connex.Client" )

COMMA          = Chr$( 044 )
DASH           = Chr$( 016 )
DELIMITER      = Chr$( 223 )
ESC            = Chr$( 027 )
FAILURE        = Chr$( 006 )
QUIT           = Chr$( 007 )
SUBJ_SUBDIV    = Chr$( 008 )

BrowseRefs$    = "Browse headings referred to:"
NameTitleType% = NOT_NAME_TITLE
ProbableTitle  = FALSE
TextSelection  = FALSE
WaltsMacros$   = "[Walt's macros] Essentials:BrowseAuthority"

Const CRITICAL_MESSAGE            As Integer = 16
Const WARNING_QUERY               As Integer = 32

Const DISPLAY_FF_AT_TOP           As Integer = 1
Const FIXED_FIELD                 As Integer = 0
Const LCSH_INDICATOR              As String  = "0"
Const MAX_LEN_SEARCH_STRING       As Integer = 60
Const MSGBOX_RETURN_CANCEL        As Integer = 2
Const MSGBOX_SETBUTTONS_OK_CANCEL As Integer = 1
Const MUSIC_WORD_TO_SIGN          As Integer = 1   'A flag to tell the function to convert the words "-flat" and "-sharp" to
                                                   ' music flat and sharp signs.
Const REC_OFFSET                  As Integer = 0   'To browse the Authority File using an expanded scan: "That is, specify a
                                                   ' heading and subheading for an Authority File browse."
Const RECORDS_PER_PAGE            As Integer = 100

' Values for different types of search terms:

Const CONFERENCE_NAME             As Integer = 3
Const CORPORATE_NAME              As Integer = 2
Const PERSONAL_NAME               As Integer = 1
Const SUBJECT                     As Integer = 0
Const UNCONTROLLED_NAME           As Integer = 5
Const UNIFORM_TITLE               As Integer = 4
Const UNKNOWN_NAME                As Integer = 6

Dim CR           As String*1 : CR              = Chr$( 013 )
Dim SINGLE_QUOTE As String*1 : SINGLE_QUOTE    = Chr$( 039 )

Dim CharT$
Dim Col%
Dim FieldData$
Dim FieldData240$
Dim Filing%
Dim FirstDelimiter%
Dim FunctionReturn$
Dim Indicators$
Dim LenSearchString%
Dim ListRecordsFound%
Dim MaxPages!
Dim NextDelimiter%
Dim OptionParam1$
Dim OptionParam2$
Dim OptionParam3$
Dim PageCount%
Dim PosFF%
Dim RawString$
Dim ResumePoint%
Dim Row%
Dim Search653$
Dim SearchLabel$
Dim SearchRecordsFound%
Dim SearchString$
Dim SelectedText$
Dim Start%
Dim StartC%
Dim Subfield$
Dim SubfieldCode$
Dim SubjHeadingSystem$
Dim Tag$
Dim TempString$
Dim TypeOfHeading%
Dim WhatFailed$
Dim WindowType%
Dim XBooleanTerm$

Dim Advance
Dim AuthorityRecord
Dim ChangedFFView            : ChangedFFView   = FALSE
Dim LCSubject                : LCSubject       = TRUE
Dim NotHeadingField          : NotHeadingField = FALSE
Dim SubjectHeading           : SubjectHeading  = FALSE
Dim TruncateString           : TruncateString  = FALSE

Dim i As Integer, j As Integer, p As Integer, q As Integer

' First check to see if any text has been selected; if so, that will become the search
' string. This line must come first because any macro code preceding it seems to cause
' the loss of part of the selection. If text has been selected, put it on the clipboard
' for possible manipulation by the macro "PasteInverted". This can be useful for when the
' browse results in no authorized heading found; that other macro can paste in the copied
' text as a heading, in the form it was browsed.

TextSelection = CS.GetSelectedText( SelectedText$ )

' Weed out unsearchable strings of selected text. Text containing non-Latin script or
' Unicode characters are not searchable.

If TextSelection Then
    If SelectedText$ = "Data contains non-latin script" Then
        MsgBox "The selected text is not searchable because it contains non-Latin script. This macro works only with characters in Latin script.", CRITICAL_MESSAGE, WaltsMacros$
        GoTo Done:
      Else
        If InStr( SelectedText$, "&#x" ) > 0 Then
            MsgBox "The selected text is not searchable because it contains Unicode characters.", CRITICAL_MESSAGE, WaltsMacros$
            GoTo Done:
        End If
    End If
    Clipboard.Clear
    Clipboard.SetText SelectedText$
End If

' Get the cursor position for further checks.

Row% = CS.CursorRow
Col% = CS.CursorColumn

' Next make sure that the type of window is bibliographic or authority; if it is any
' other type, exit the macro.

WindowType% = CS.ItemType
Select Case WindowType%
  Case -1, 5 To 11, 13, 15 To 16, 21 To 25
    MsgBox "Sorry, this macro works only in a bibliographic or authority record. Open a record to select text or browse or search on a heading.", CRITICAL_MESSAGE, WaltsMacros$
    GoTo Done:
  Case 3 To 4, 14, 18, 20
    AuthorityRecord = TRUE
  Case Else
    AuthorityRecord = FALSE
End Select

' Get the Language code from the fixed field, to use in evaluating initial articles. Also
' get the "Subject heading system/thesaurus" code from the element "Subj" (008/11). This
' code differentiates between LC and other kinds of subject heading schemes.

PosFF% = CS.FixedFieldPosition
If PosFF% <> DISPLAY_FF_AT_TOP Then
    CS.FixedFieldPosition = DISPLAY_FF_AT_TOP
    ChangedFFView         = TRUE
End If
If CS.GetFixedField( "Lang", Language$ ) Then
End If
If CS.GetFixedField( "Subj", SubjHeadingSystem$ ) Then
End If

If ChangedFFView Then CS.FixedFieldPosition = PosFF%

' If the type of window is correct, then verify that the selection was not made in the
' fixed field or the tag or indicator cells of a variable field. For these locations, the
' Client automatically selects the element or the cell when it is first clicked. The test
' for these selections seems to be that the column position of any selected element in
' the fixed field is 0 and the column position of a selected tag cell is 1. If the tag or
' indicator cells are selected, assume the whole field is meant to be browsed upon, and
' ignore the selection. After this check, make sure the selection is limited to within
' one field; text that spans fields won't be considered. If the selection passes all
' these tests, proceed to normalize the string.

If Col% = FIXED_FIELD Then
    MsgBox "The cursor seems to be in the fixed field! Please select text in a variable field or click in a heading to browse.", CRITICAL_MESSAGE, WaltsMacros$
    GoTo Done:
  ElseIf TextSelection = TRUE And Col% >= FIELD_DATA_BEGINS Then
    SelectedText$ = Trim$( SelectedText$ )
    If InStr( SelectedText$, CR ) Then
        MsgBox "The selection is not searchable because it spans multiple fields. Please limit text selection to within one field only.", CRITICAL_MESSAGE, WaltsMacros$
        GoTo Done:
    End If
    GoTo Normalize:
  ElseIf TextSelection = TRUE And Col% < FIELD_DATA_BEGINS Then
    TextSelection = FALSE
End If

' If no text has been selected, the whole field in which the cursor is placed becomes the
' browse string.

If CS.GetField( "...", Row%, FieldData$ ) Then
    If FieldData$ = "Data contains non-latin script" Then
        MsgBox "The heading in this field is not searchable because it contains non-Latin script. This macro works only with characters in Latin script.", CRITICAL_MESSAGE, WaltsMacros$
        GoTo Done:
      Else
        If InStr( FieldData$, "&#x" ) > 0 Then
            MsgBox "The selected text is not searchable because it contains characters encoded as Unicode.", CRITICAL_MESSAGE, WaltsMacros$
            GoTo Done:
        End If
    End If
  Else
    MsgBox "To run this macro, either click in a heading field or select some text in any variable field.", CRITICAL_MESSAGE, WaltsMacros$
    GoTo Done:
End If

GetLine:

' The field's tag and indicators guide the macro's execution.

Tag$        = Left$( FieldData$, 3 )
Indicators$ = Mid$( FieldData$, 4, 2 )

Select Case Tag$

'#####  LC subject heading (or reference)  ##############################################

  Case "150", "151", "450", "451", "550", "551", "650", "651"
    TypeOfHeading% = SUBJECT
    SubjectHeading = TRUE
    If Right$( Indicators$, 1 ) <> LCSH_INDICATOR And AuthorityRecord = FALSE Then LCSubject = FALSE

'#####  Index Term--Uncontrolled   ######################################################

  Case "653"
    TypeOfHeading% = SUBJECT
    SubjectHeading = TRUE
    LCSubject      = FALSE

'#####  Index Term--Genre/Form   ########################################################

' It is not possible for a macro to browse genre terms, so they must be searched as
' subjects. In a bibliographic record, search a genre term from LCSH as a subject; for
' all other terms, and for headings in authority records, ask before proceeding.

  Case "155", "555", "655"
    TypeOfHeading% = SUBJECT
    SubjectHeading = TRUE
    If AuthorityRecord Then
        LCSubject = FALSE
      Else
        If Right$( Indicators$, 1 ) <> LCSH_INDICATOR Then
            If Right$( Indicators$, 1 ) = "7" Then
                Start% = FIELD_DATA_BEGINS
                Do
                  p = InStr( Start%, FieldData$, DELIMITER )
                  If p <> 0 Then
                      SubfieldCode$ = Mid$( FieldData$, p + 1, 1 )
                      If SubfieldCode$ = "2" Then
                          If Mid$( FieldData$, p + 1, 6 ) <> "2 lcsh" Then
                              LCSubject = FALSE
                          End If
                      End If
                  End If
                  Start% = p + 1
                Loop Until p = 0
            End If
        End If
    End If

'#####  Personal name heading  ##########################################################

  Case "100", "400", "700", "800"
    TypeOfHeading% = PERSONAL_NAME

'#####  Personal name heading as subject  ###############################################

  Case "600"
    TypeOfHeading% = PERSONAL_NAME
    SubjectHeading = TRUE
    If Right$( Indicators$, 1 ) <> LCSH_INDICATOR Then LCSubject = FALSE

'#####  Personal name heading, authority records only  ##################################

  Case "500"
    If AuthorityRecord Then
        TypeOfHeading% = PERSONAL_NAME
      Else
        MsgBox "This is not a heading field!", CRITICAL_MESSAGE, WaltsMacros$
        GoTo Done:
    End If

'#####  Corporate name heading  #########################################################

  Case "110", "410", "710", "810"
    TypeOfHeading% = CORPORATE_NAME

'#####  Corporate name heading, authority records only  #################################

  Case "510"
    If AuthorityRecord Then
        TypeOfHeading% = CORPORATE_NAME
      Else
        MsgBox "This is not a heading field!", CRITICAL_MESSAGE, WaltsMacros$
        GoTo Done:
    End If

'#####  Corporate name heading as subject  ##############################################

  Case "610"
    TypeOfHeading% = CORPORATE_NAME
    SubjectHeading = TRUE
    If Right$( Indicators$, 1 ) <> LCSH_INDICATOR Then LCSubject = FALSE

'#####  Conference name heading  ########################################################

  Case "111", "411", "711", "811"
    TypeOfHeading% = CONFERENCE_NAME

'#####  Conference name heading, authority records only  ################################

  Case "511"
    If AuthorityRecord Then
        TypeOfHeading% = CONFERENCE_NAME
      Else
        MsgBox "This is not a heading field!", CRITICAL_MESSAGE, WaltsMacros$
        GoTo Done:
    End If

'#####  Conference name heading as subject  #############################################

  Case "611"
    TypeOfHeading% = CONFERENCE_NAME
    SubjectHeading = TRUE
    If Right$( Indicators$, 1 ) <> LCSH_INDICATOR Then LCSubject = FALSE

'#####  Title heading  ##################################################################

' Where present, get the indicator for non-filing characters.

  Case "130", "430", "440", "490", "730", "740", "830"
    TypeOfHeading% = UNIFORM_TITLE
      Select Case Tag$
        Case "430", "440", "830"
          Filing%   = Val( Right$( Indicators$, 1 ) )
          LCSubject = FALSE
        Case "130"
          If AuthorityRecord Then
              Filing% = Val( Right$( Indicators$, 1 ) )
            Else
              Filing% = Val( Left$( Indicators$, 1 ) )
          End If
        Case "490"
          Filing%   = 0
          LCSubject = FALSE
        Case Else
          Filing% = Val( Left$( Indicators$, 1 ) )
      End Select

'#####  Uniform title following main entry  #############################################

' Make this into a name/title heading by getting the preceding field (what was called,
' before RDA, the "main entry") first, and then getting the data from the 240 later.

  Case "240"
    FieldData240$   = FieldData$
    NameTitleSplit% = CURSOR_IN_240
    For i = 1 To 2
      If CS.GetField( "...", Row% - i, FieldData$ ) Then
          If Left$( FieldData$, 1 ) = "1" Then
              Exit For
          End If
      End If
    Next i
    If Left$( FieldData$, 1 ) <> "1" Then
        MsgBox "Sorry, could not get a name to go with this title.", CRITICAL_MESSAGE, WaltsMacros$
        Exit Sub
      Else
        Tag$ = Left$( FieldData$, 3 )
        Select Case Tag$
          Case "100"
            TypeOfHeading% = PERSONAL_NAME
          Case "110"
            TypeOfHeading% = CORPORATE_NAME
          Case "111"
            TypeOfHeading% = CONFERENCE_NAME
          Case Else
            TypeOfHeading% = UNIFORM_TITLE
        End Select
    End If

'#####  Title heading, authority records only  ##########################################

  Case "530"
    If AuthorityRecord Then
        TypeOfHeading% = UNIFORM_TITLE
      Else
        MsgBox "This is not a heading field!", CRITICAL_MESSAGE, WaltsMacros$
        GoTo Done:
    End If

'#####  Title heading as subject  #######################################################

  Case "630"
    TypeOfHeading% = UNIFORM_TITLE
    SubjectHeading = TRUE
    If Right$( Indicators$, 1 ) <> LCSH_INDICATOR Then LCSubject = FALSE
    Filing%        = Val( Left$( Indicators$, 1 ) )

'#####  Subject subdivisions  ###########################################################

  Case "180", "181", "182", "185", "480", "481", "482", "485", "580", "581", "582", "585"
    TypeOfHeading%  = SUBJECT
    SubjectHeading  = TRUE
    LCSubject       = TRUE
    NotHeadingField = TRUE

'#####  Added Entry: Uncontrolled Name  #################################################

' The 720 field distinguishes only between personal names and all others, and does not
' require any particular structure for a name. This macro attempts to determine which
' unspecified names might be personal names, and browses with them as with any other 700
' field.

  Case "720"
    If Left$( Indicators$, 1 ) = "1" Then
        TypeOfHeading% = PERSONAL_NAME

' If the first indicator does not specify that the heading is a personal name, look for a
' comma in the field. If it doesn't precede a delimiter, or it does precede a digit
' ("1" or "2", either of which suggests a birth year), treat the name as a personal name.
' Otherwise, the name will be browsed in the general names index as a selection.

      Else
        p = InStr( FIELD_DATA_BEGINS, FieldData$, COMMA )
        If p = 0 Then
            TypeOfHeading% = UNCONTROLLED_NAME
          Else
            CharT$ = Mid$( FieldData$, p + 2 )
            If CharT$ = DELIMITER Then
                TypeOfHeading% = UNCONTROLLED_NAME
              ElseIf CharT$ Like "[12]" Then
                TypeOfHeading% = PERSONAL_NAME
            End If
        End If
    End If

'#####  All other fields  ###############################################################

  Case Else

' In a bibliographic record, if the cursor is in a field that does not contain a
' searchable heading, the macro quits. In an authority record, however, the macro is able
' to offer browsing on the established heading, on headings referred to in some note
' fields, on and most of the 5XX fields, no matter where the cursor is positioned. This
' is not true for non-LC subject headings; the macro language can't browse or search for
' them, so the only options are to browse as LC subject headings--in which case the
' cursor must be in a heading field--or to quit.

    If AuthorityRecord Then
        If SubjHeadingSystem$ <> "a" Then
            If MsgBox( "Although this subject heading is not LC, it will be treated as such by this macro. Continue?", WARNING_QUERY + MSGBOX_SETBUTTONS_OK_CANCEL, WaltsMacros$ ) = MSGBOX_RETURN_CANCEL Then
                GoTo Done:
            End If
        End If
        NotHeadingField = TRUE

' When running this macro in an authority record, the action selected in the
' "BrowseFromAuthorityRecord" function results in one of four values. If the chosen
' action was to browse on headings referred to, the function will report the values for
' success or failure, after which the macro stops. If the action was to browse on the
' authorized heading, the macro goes back near the beginning and repeats getting
' information from the field. If getting the authority record for a see also from heading
' (a 5XX field) was the chosen action, that search happens now.

        FunctionReturn$ = BrowseFromAuthorityRecord
        If FunctionReturn$ = FAILURE Then
            WhatFailed$ = "browse"
            GoTo Failure:
          ElseIf FunctionReturn$ = QUIT Then
            GoTo Done:
          ElseIf Left$( FunctionReturn$, 1 ) = BROWSE_AUTHORIZED_HEADING Then
            FieldData$ = Mid$( FunctionReturn$, 2 )
            GoTo GetLine:
          ElseIf Left$( FunctionReturn$, 1 ) = GET_5XX_HEADING Then
            SearchString$ = Mid$( FunctionReturn$, 2 )

' If retrieving an authority record (requiring the "Search" command), clean up the search
' string. First, remove dashes.

            Do
              p = InStr( SearchString$, " -- " )
              If p > 0 Then
                  SearchString$ = Left$( SearchString$, p - 1 ) & Mid$( SearchString$, p + 3 )
              End If
            Loop Until p = 0

' To include the Boolean terms "and", "or", and "not" in a search, they must be enclosed
' in single quotation marks.

            For i = 1 To 3
              Do
                Select Case i
                  Case 1
                    XBooleanTerm$ = "AND"
                    ResumePoint%  = 4
                  Case 2
                    XBooleanTerm$ = "OR"
                    ResumePoint%  = 3
                  Case 3
                    XBooleanTerm$ = "NOT"
                    ResumePoint%  = 4
                End Select
                p = InStr( SearchString$, " " & XBooleanTerm$ & " " )
                If p > 0 Then
                    SearchString$ = Left$( SearchString$, p ) & SINGLE_QUOTE & XBooleanTerm$ & SINGLE_QUOTE & Mid$( SearchString$, p + ResumePoint% )
                End If
              Loop Until p = 0
            Next i

' Searching a name/title heading requires creating two separate search strings.

            If Mid$( MatchString$, 2, 2 ) Like "[01][01]" Then
                p = InStr( MatchString$, DELIMITER & "t" )
                If p > 0 Then
                    NameTitleType% = HEADING_NAME_TITLE
                    NameString$    = Trim$( Left$( MatchString$, p - 1 ) )
                    NameString$    = Normalize( Mid$( NameString$, FIELD_DATA_BEGINS ), FALSE )
                    TitleString$   = Normalize( Trim$( Mid$( MatchString$, p + 2 ) ), FALSE )
                End If
            End If

            Tag$          = "1" & Mid$( MatchString$, 2, 2 )
            MatchString$  = Mid$( MatchString$, 6 ) & " " & "[" & Tag$ & "]"

            Select Case Tag$

              Case "100"
                SearchLabel$ = "pn:"

              Case "110"
                SearchLabel$ = "co:"

              Case "111"
                SearchLabel$ = "cn:"

              Case "130"
                SearchLabel$ = "ti:"

              Case "150"
                SearchLabel$ = "to:"

' THERE APPEARS TO BE A BUG; GEOGRAPHIC NAMES MUST BE SEARCHED AS SUBJECTS IN MACROS.
' BROWSING SEEMS TO BE UNAFFECTED.
'             Case "151"
'               SearchLabel$ = "gg:"

              Case "180", "185"
                SearchLabel$ = "sb:"

              Case Else
                SearchLabel$ = "su:"

            End Select

            If NameTitleType% > NOT_NAME_TITLE Then
                SearchString$       = SearchLabel$ & NameString$ & " AND " & "ti:" & TitleString$
                SearchRecordsFound% = CS.Search( AUTHORITY_FILE, SearchString$ )
              Else
                SearchRecordsFound% = CS.Search( AUTHORITY_FILE, SearchLabel$ & SearchString$ )
            End If
            If SearchRecordsFound% > 0 Then
'               If CS.ItemType = 10 Then   'Authority brief list
'                   BrowseFromAuthorityRecord = QUIT
'                   Exit Function
'               End If
                MaxPages! = SearchRecordsFound% / RECORDS_PER_PAGE
                If MaxPages! > Int( MaxPages! ) Then
                    MaxPages! = Int( MaxPages! ) + 1
                End If
                PageCount% = 1
                Do
                  ListRecordsFound% = CS.SearchList( MatchString$, "Description", TRUE )
                  If ListRecordsFound% = 0 Then
                      If PageCount% < MaxPages! Then
                          Advance    = CS.GetNext100Records
                          PageCount% = PageCount% + 1
                        Else
                          WhatFailed$ = "search"
                          GoTo Failure:
                      End If
                    Else
                      Advance = CS.GetFirstSelectedItem
                      Exit Do
                  End If
                Loop Until ListRecordsFound% > 0
                WindowType% = CS.ItemType
                If WindowType% <> 3 Then
                    MsgBox "Sorry, the authority record could not be retrieved.", CRITICAL_MESSAGE, WaltsMacros$
                End If
                GoTo Done:
              Else
                WhatFailed$ = "search"
                GoTo Failure:
            End If
        End If
      Else
        MsgBox "This is not a heading field!", CRITICAL_MESSAGE, WaltsMacros$
        GoTo Done:
    End If

End Select

' After analyzing the heading, deal with some special cases. For a name main entry, check
' for a 240 field. If found, combine the two fields into a single name/title field.

If Left$( Tag$, 1 ) = "1" And ( TypeOfHeading% = CORPORATE_NAME Or TypeOfHeading% = PERSONAL_NAME ) Then
    If FieldData240$ <> "" Then
        Indicators$ = Mid$( FieldData240$, 4, 2 )
        Filing%     = Val( Right$( Indicators$, 1 ) )
        FieldData$  = FieldData$ & " " & DELIMITER & "t " & Mid$( FieldData240$, FIELD_DATA_BEGINS + Filing% )
    End If
End If

' For a subject field, check the thesaurus used for the term (identified by the value of
' the second indicator). A non-LC heading requires confirmation before proceeding. The
' second indicator in a 653 field may specify the type of heading in the field, so use
' that as the basis for a search. If the second indicator does not specify the type of
' heading, offer a choice of how to search it.

If SubjectHeading = TRUE And LCSubject = FALSE Then

    If Tag$ = "655" Or Tag$ = "555" Then
        If MsgBox( "This genre heading must be searched as an LC subject. Continue?", WARNING_QUERY + MSGBOX_SETBUTTONS_OK_CANCEL, WaltsMacros$ ) = MSGBOX_RETURN_CANCEL Then
            GoTo Done:
        End If

      ElseIf Tag$ = "653" Then
        Search653$ = Right$( Indicators$, 1 )
        If Search653$ = " " Then
            Begin Dialog Dialog1Definition  184, 134, WaltsMacros$
              OkButton        62,  110,  52,  14
              CancelButton   122,  110,  52,  14
              Text            10,   6, 160,   8, "Search this 653 field as what kind of subject?"
              OptionGroup                                            .OptionGroup
               OptionButton   18,  18, 128,  12, "&Topical",         .OptionButton1
               OptionButton   18,  32, 128,  12, "&Personal name",   .OptionButton2
               OptionButton   18,  46, 128,  12, "&Corporate name",  .OptionButton3
               OptionButton   18,  60, 128,  12, "Co&nference name", .OptionButton4
               OptionButton   18,  74, 128,  12, "&Geographic name", .OptionButton5
               OptionButton   18,  88, 128,  12, "&Uniform title",   .OptionButton6
            End Dialog

            Dim Dialog1 As Dialog1Definition
            On Error Resume Next
            Dialog Dialog1
            If Err = DLG_STATEMENT_CANCEL Then GoTo Done:
            Select Case Dialog1.OptionGroup
              Case 0
                Search653$ = "su"
              Case 1
                Search653$ = "pn"
              Case 2
                Search653$ = "co"
              Case 3
                Search653$ = "cn"
              Case 4
                Search653$ = "gg"
              Case 5
                Search653$ = "ti"
            End Select
          Else
            Select Case Search653$
              Case "0"
                Search653$ = "su"
              Case "1"
                Search653$ = "pn"
              Case "2"
                Search653$ = "co"
              Case "3"
                Search653$ = "cn"
              Case "5"
                Search653$ = "gg"
              Case Else
                If MsgBox( "This genre heading must be searched as an LC subject. Continue?", WARNING_QUERY + MSGBOX_SETBUTTONS_OK_CANCEL, WaltsMacros$ ) = MSGBOX_RETURN_CANCEL Then
                    GoTo Done:
                End If
            End Select
        End If

      Else
        If MsgBox( "This heading is not an LC subject heading. Continue search anyway?", WARNING_QUERY + MSGBOX_SETBUTTONS_OK_CANCEL, WaltsMacros$ ) = MSGBOX_RETURN_CANCEL Then
            GoTo Done:
        End If
    End If
End If

' For a title field, strip initial articles, as determined by the indicator for non-
' filing characters.

If TypeOfHeading% = UNIFORM_TITLE Then
    FieldData$ = Mid$( FieldData$, FIELD_DATA_BEGINS + Filing% )
  Else
    FieldData$ = Mid$( FieldData$, FIELD_DATA_BEGINS )
End If

'########################################################################################
' Normalize the search string.
'########################################################################################

Normalize:

If TextSelection = FALSE Then
    RawString$ = FieldData$
  Else
    RawString$ = SelectedText$
End If

NormalizedString$ = Normalize( RawString$, TRUE )

If NormalizedString$ = FAILURE Then
    WhatFailed$ = "browse"
    GoTo Failure:
  ElseIf NormalizedString$ = QUIT Then
    GoTo Done:
End If

' If a title has been identified, it's because the search string is a selection and the
' macro has interpreted a " / " string within the selection as ISBD punctuation
' separating a title from a statement of responsibility. Split the selection into name
' and title strings and clean them up.

If TitleString$ <> "" Then
    NameString$    = DoubleSpaceErase( Mid$( NormalizedString$, NameTitleSplit% ) )
    TitleString$   = DoubleSpaceErase( Left$( NormalizedString$, NameTitleSplit% - 1 ) )
    NameTitleType% = SELECTION_NAME_TITLE
    TypeOfHeading% = UNKNOWN_NAME
End If

NormalizedString$ = DoubleSpaceErase( NormalizedString$ )

' The 490 field is considered a title field, but it lacks an indicator for non-filing
' characters. Test the first word to see if it is one of the few initial articles this
' macro knows about, and if it is, remove it.

If Tag$ = "490" Then
    NormalizedString$ = InitialArticle( NormalizedString$ )
End If

If TextSelection Then
    FunctionReturn$ = BrowseFromSelectedText
    If FunctionReturn$ = FAILURE Then
        WhatFailed$ = "browse"
        GoTo Failure:
      ElseIf FunctionReturn$ = QUIT Then
        GoTo Done:
      ElseIf FunctionReturn$ = "GoToNameTitleBrowse" Then
        GoTo NameTitleBrowse:
    End If
End If

'########################################################################################
' Build the search string, by subfield.
'########################################################################################

' For browsing by field, go through the normalized string a subfield at a time, modifying
' or deleting them to end up with the searchable string, and filling the arrays for
' display of headings with multiple subfields. Start by making the field begin with the
' delimiter character and subfield code "a", if there is not already a subfield code.

If Left$( NormalizedString$, 1 ) <> DELIMITER Then NormalizedString$ = DELIMITER & "A" & NormalizedString$

' From this point on the normalized string is put into one or both of the two arrays. The
' Names array holds the main heading of all non-title fields, including subjects. It also
' holds all subfields associated with a name heading as well as different forms of the
' same name. For a personal name, that means storing the name in both direct and inverted
' order. For a corporate name, that means storing separately each level of a hierarchy.
' The Subdivisions array holds all the subject subdivision subfields that follow the main
' heading, and many of their permutations. Titles and their associated subfields are
' stored in a simple string variable.

Start% = 1

Do
  FirstDelimiter% = InStr( Start%, NormalizedString$, DELIMITER )
  If FirstDelimiter% <> 0 Then
      SubfieldCode$  = Mid$( NormalizedString$, FirstDelimiter% + 1, 1 )
      NextDelimiter% = InStr( FirstDelimiter% + 1, NormalizedString$, DELIMITER )
      If NextDelimiter% <> 0 Then
          Subfield$ = Trim$( Mid$( NormalizedString$, FirstDelimiter% + 2, NextDelimiter% - FirstDelimiter% - 2 ) )
        Else
          Subfield$ = Trim$( Mid$( NormalizedString$, FirstDelimiter% + 2 ) )
      End If
      If Len( NameString$ ) = 0 Then
          LenSearchString% = Len( TitleString$ )
        Else
          LenSearchString% = Len( NameString$ )
      End If
      If LenSearchString% + Len( Subfield$ ) > MAX_LEN_SEARCH_STRING Then
          Subfield$      = Trim$( Left$( Subfield$, 59 - LenSearchString% ) ) & " <!"
          TruncateString = TRUE
      End If

      Select Case SubfieldCode$

        Case "A"

' Only the first comma in subfield $a is retained in the search; all other commas in the
' string are omitted.

          StartC% = 1
          Do
            p = InStr( StartC%, Subfield$, COMMA )
            If p <> 0 Then
                If StartC% <> 1 Then Subfield$ = Left$( Subfield$, p - 1 ) & Mid$( Subfield$, p + 1 )
            End If
            StartC% = p + 1
          Loop Until p = 0
          If NextDelimiter% > 0 Then
              StartC% = NextDelimiter%
              Do
                p = InStr( StartC%, NormalizedString$, COMMA )
                If p <> 0 Then NormalizedString$ = Left$( NormalizedString$, p - 1 ) & Mid$( NormalizedString$, p + 1 )
                StartC% = p + 1
              Loop Until p = 0
          End If

          NormalizedString$ = DoubleSpaceErase( NormalizedString$ )

' For a corporate or conference heading, begin filling the Names array with the name of
' the corporate body at the highest level (i.e., whatever is in subfield $a).

          If TypeOfHeading% = CORPORATE_NAME Or TypeOfHeading% = CONFERENCE_NAME Then
              ReDim Names( CountOfNames% )
              Names( CountOfNames% ) = Subfield$
              CountOfNames%          = CountOfNames% + 1
          End If
          If TypeOfHeading% = UNIFORM_TITLE Then
              TitleString$ = Subfield$
            Else
              NameString$  = Subfield$
          End If
          If TruncateString Then Exit Do

' Continue adding to the array with each subsequent subfield $b found in an X10 field.
' Copy the first element of the array to the second row (bumping up every row that
' follows), and add to that first element the new subfield $b, preceded by a period for
' easier reading in the dialog box display. Thus, the filled array proceeds from the
' lowest, particular unit (the longest string), to the highest, basic corporate name (the
' shortest string).

        Case "B"
          If TypeOfHeading% = CORPORATE_NAME Then
              NameString$ = NameString$ & " " & Subfield$
              ReDim Preserve Names( CountOfNames% )
              For i = CountOfNames% To 1 Step -1
                Names( i ) = Names( i - 1 )
              Next i
              CountOfNames% = CountOfNames% + 1
              Names( 0 )    = Names( 1 ) & ". " & Subfield$
            ElseIf TypeOfHeading% = PERSONAL_NAME Then
              NameString$   = NameString$ & " " & Subfield$
          End If
          If TruncateString Then Exit Do

' Subfields associated with either a name or a title heading: Add these subfields to the
' name heading string being constructed, but to the title heading string only if that
' string has already been established.

        Case "C", "D", "G", "N", "Q"
          If TypeOfHeading% = CORPORATE_NAME Or TypeOfHeading% = CONFERENCE_NAME Then
              Names( 0 ) = Names( 0 ) & " " & Subfield$
          End If
          NameString$ = NameString$ & " " & Subfield$
          If TitleString$ <> "" Then TitleString$ = TitleString$ & " " & Subfield$
          If TruncateString Then Exit Do

' Subfields marking a title field:

        Case "K", "T"
          If TypeOfHeading% <> UNIFORM_TITLE Then
              NameTitleType% = HEADING_NAME_TITLE
          End If
          TitleString$ = TitleString$ & " " & Subfield$
          If TruncateString Then Exit Do

' Subfields associated with a title heading:

        Case "F", "L", "M", "O", "P", "R", "S"
          TitleString$ = TitleString$ & " " & Subfield$
          If TruncateString Then Exit Do

' Subject subdivisions are kept in the Subdivisions array. Each time a subdivision is
' encountered, it is put in the first element of the array at the end of the subject
' subdivision string that preceded it, a copy of which now is moved up one row. Separate
' each subfield in the concatenated string by a dash for easier viewing in the dialog box
' display. Thus, in the filled array, the first element contains the whole subdivision
' string, and the last element contains only the first subdivision.

        Case "V", "X", "Y", "Z"
          If SubjectHeading Then
              ReDim Preserve Subdivisions( CountOfSubdivisions% )
              If CountOfSubdivisions% > 0 Then
                  For i = CountOfSubdivisions% To 1 Step -1
                    Subdivisions( i ) = Subdivisions( i - 1 )
                  Next i
                  Subdivisions( 0 ) = Subdivisions( i ) & " -- " & Subfield$
                Else
                  Subdivisions( 0 ) = Subfield$
                  If SubjectHeading Then SubjectString$ = NameString$
              End If
              CountOfSubdivisions% = CountOfSubdivisions% + 1
              If TruncateString Then Exit Do
            Else

' A subfield $v in a non-subject heading marks the end of the input string.

              Exit Do
          End If

' Subfield $e has a completely different meaning for a conference heading than it does
' for the other name headings; it is added to the string for a conference name, but
' ignored (and therefore omitted) otherwise.

        Case "E"
          If TypeOfHeading% = CONFERENCE_NAME Then NameString$ = NameString$ & " " & Subfield$

      End Select
  End If
  Start% = FirstDelimiter% + 1

Loop Until FirstDelimiter% = 0

' A personal name will not have been put in the name array; but when all the subfields
' have been processed, add it. First, delete a comma at the end of a name.

NameString$ = Trim$( NameString$ )
If NameString$ <> "" Then
    If Right$( NameString$, 1 ) = COMMA Then
        NameString$ = Trim$( Left$( NameString$, Len( NameString$ ) - 1 ) )
    End If
    If CountOfNames% = 0 Then
        ReDim Names( CountOfNames% )
        Names( CountOfNames% ) = NameString$
        CountOfNames%          = CountOfNames% + 1
    End If
End If

' If a heading is tagged as a subject but has no subdivisions (e.g., a 610 for a
' corporate body whose history is the subject of a work), do not treat it as a subject.

If TypeOfHeading% > SUBJECT And CountOfSubdivisions% = 0 Then SubjectHeading = FALSE

' The subject subdivisions array now holds the string of subdivisions in diminishing
' lengths, so each element of the array is one subdivision shorter than the preceding
' element. To enable browsing on any individual subdivision in the heading, out of its
' original context in a specific sequence, insert those subdivisions into further rows of
' the array.

If CountOfSubdivisions% > 1 Then
    p = UBound( Subdivisions )

' To make room for these individual elements, start by doubling the size of the array.

    q = p * 2
    ReDim Preserve Subdivisions( q )

' Put the last subdivision of the subdivision string into the new, empty last element of
' the array. Follow that by putting the penultimate subdivision into the penultimate
' element of the array. Repeat until the first subdivision is reached, which is already
' in the array, as the original last element.

    For i = 1 To p
      Subdivisions( q + 1 - i ) = Trim$( Mid$( Subdivisions( -1 + i ), Len( Subdivisions( 0 + i ) ) + 4 ) )
    Next i
End If

' After a 720 heading has been normalized and any relator subfields removed, if it is not
' a personal name, treat it as a selection, thus enabling it to be tested for inversion
' or for the marks of a corporate body. Otherwise, treat it as a 700 field.

If TypeOfHeading% = UNCONTROLLED_NAME Then
    TextSelection     = TRUE
    NormalizedString$ = NameString$
    FunctionReturn$   = BrowseFromSelectedText
    If FunctionReturn$ = FAILURE Then
        WhatFailed$ = "browse"
        GoTo Failure:
      ElseIf FunctionReturn$ = QUIT Then
        GoTo Done:
    End If
End If

'########################################################################################
' Browse by field.
'########################################################################################

' For each type of browse, supply the appropriate labels for the dialog box. Start with a
' name/title heading, which is never treated as a subject. The first thing to do with a
' title string in a field is to check it for the music flat and sharp signs, and if
' found, changing them to words. Assume that any initial article either was never
' supplied or was accounted for in the non-filing characters indicator.

If NameTitleType% > NOT_NAME_TITLE Then

    TitleHeading$ = FlatSharpFix( TitleString$, MUSIC_SIGN_TO_WORD )

NameTitleBrowse:

    OptionParam1$ = "Name heading"
    OptionParam2$ = "Title heading"
    OptionParam3$ = "(name + title)"

    Select Case ChooseBrowse( OptionParam1$, OptionParam2$, OptionParam3$ )

      Case DLG_STATEMENT_CANCEL
        GoTo Done:

' Search the name portion only:

      Case 0, 4, 5
        SearchString$ = SearchTerm1$
        GoTo SimpleBrowse:

' If the name/title field is a subject heading, remove any subject subdivisions and
' search the title part simply as a title.

      Case 1
        SearchString$ = SearchTerm2$
        SearchString$ = FlatSharpFix( SearchString$, MUSIC_WORD_TO_SIGN )
        If Len( SearchString$) > MAX_LEN_SEARCH_STRING Then SearchString$ = Left$( SearchString$, MAX_LEN_SEARCH_STRING )
        If CS.Browse( AUTHORITY_FILE, "ti", SearchString$ ) = FALSE Then
            WhatFailed$ = "browse"
            GoTo Failure:
        End If

' Search the name portion with the title added for an expanded browse. Distinguish
' between a personal name and a corporate/conference name.

      Case 2
        If TypeOfHeading% = PERSONAL_NAME Then
            AFIndex$ = "pn"
          ElseIf TypeOfHeading% = CORPORATE_NAME Or TypeOfHeading% = CONFERENCE_NAME Then
            AFIndex$ = "co"
          ElseIf TypeOfHeading% = UNKNOWN_NAME Then
            AFIndex$ = "nw"
        End If
        If Len( SearchTerm1$) > MAX_LEN_SEARCH_STRING Then SearchTerm1$ = Left$( SearchTerm1$, MAX_LEN_SEARCH_STRING )
        If Len( SearchTerm2$) > MAX_LEN_SEARCH_STRING Then SearchTerm2$ = Left$( SearchTerm2$, MAX_LEN_SEARCH_STRING )
        If CS.BrowseAuthorityExpanded( REC_OFFSET, AFIndex$, SearchTerm1$, SearchTerm2$ ) = FALSE Then
            WhatFailed$ = "browse"
            GoTo Failure:
        End If

    End Select

  ElseIf SubjectHeading Then

' Continue with subject headings. If a subject heading contains no subject subdivisions,
' search it immediately as is; otherwise, call up the dialog box to choose how to browse
' those subdivisions.

    Select Case TypeOfHeading%

      Case SUBJECT
        If CountOfSubdivisions% = 0 Then
            SearchString$ = NameString$
            GoTo SimpleBrowse:
          Else
            OptionParam1$ = "Main heading"
            OptionParam3$ = "(main heading + subject subdivision)"
        End If

      Case PERSONAL_NAME, CORPORATE_NAME, CONFERENCE_NAME
        If CountOfSubdivisions% = 0 Then
            SearchString$ = NameString$
            GoTo SimpleBrowse:
          Else
            OptionParam1$ = "Name heading"
            OptionParam3$ = "(name heading + subject subdivision)"
        End If

      Case UNIFORM_TITLE
        If CountOfSubdivisions% = 0 Then
            SearchString$ = TitleString$
            GoTo SimpleBrowse:
          Else
            SubjectString$ = TitleString$
            OptionParam1$  = "Title heading"
            OptionParam3$  = "(title heading + subject subdivision)"
        End If

    End Select

' For a subject browse, the second button in the dialog box displays only when the field
' contains one or more subject subdivisions.

    If CountOfSubdivisions% = 1 Then
        OptionParam2$ = "Subject subdivision"
      ElseIf CountOfSubdivisions% > 1 Then
        OptionParam2$ = "Subject subdivision(s)"
    End If

    Select Case ChooseBrowse( OptionParam1$, OptionParam2$, OptionParam3$ )

      Case DLG_STATEMENT_CANCEL
        GoTo Done:

' Browse on main heading only: This will be a straightforward search.

      Case 0
        If TypeOfHeading% <> UNIFORM_TITLE Then
            SearchString$ = SearchTerm1$
            GoTo SimpleBrowse:
        End If
        If Len( SearchTerm1$) > MAX_LEN_SEARCH_STRING Then SearchTerm1$ = Left$( SearchTerm1$, MAX_LEN_SEARCH_STRING )
        If CS.Browse( AUTHORITY_FILE, "ti", SearchTerm1$ ) = FALSE Then
            WhatFailed$ = "browse"
            GoTo Failure:
        End If

' Browse on subdivision(s) only:

      Case 1
        If Len( SearchTerm2$) > MAX_LEN_SEARCH_STRING Then SearchTerm2$ = Left$( SearchTerm2$, MAX_LEN_SEARCH_STRING )
        If CS.Browse( AUTHORITY_FILE, "sb", SearchTerm2$ ) = FALSE Then
            WhatFailed$ = "browse"
            GoTo Failure:
        End If

' Browse on main heading but send expanded term to refine the browse:

      Case 2
        If Len( SearchTerm1$) > MAX_LEN_SEARCH_STRING Then SearchTerm1$ = Left$( SearchTerm1$, MAX_LEN_SEARCH_STRING )
        If Len( SearchTerm2$) > MAX_LEN_SEARCH_STRING Then SearchTerm2$ = Left$( SearchTerm2$, MAX_LEN_SEARCH_STRING )
        If CS.BrowseAuthorityExpanded( REC_OFFSET, "su", SearchTerm1$, SearchTerm2$ ) = FALSE Then
            WhatFailed$ = "browse"
            GoTo Failure:
        End If

    End Select

' Corporate bodies: Choose whether to browse on the whole heading or part of it only,
' when there are subordinate units in the name.

  ElseIf TypeOfHeading% = CORPORATE_NAME Then

    If CountOfNames% > 1 Then
        Select Case ChooseBrowse( "Name heading", "", "" )

          Case DLG_STATEMENT_CANCEL
            GoTo Done:

          Case 0
            If Len( SearchTerm1$) > MAX_LEN_SEARCH_STRING Then SearchTerm1$ = Left$( SearchTerm1$, MAX_LEN_SEARCH_STRING )
            If CS.Browse( AUTHORITY_FILE, "co", SearchTerm1$ ) = FALSE Then
                WhatFailed$ = "browse"
                GoTo Failure:
        End If

        End Select
      Else
        SearchString$ = NameString$
        GoTo SimpleBrowse:
    End If

' Titles:

  ElseIf TypeOfHeading% = UNIFORM_TITLE Then
    If Len( TitleString$) > MAX_LEN_SEARCH_STRING Then TitleString$ = Left$( TitleString$, MAX_LEN_SEARCH_STRING )
    If CS.Browse( AUTHORITY_FILE, "ti", TitleString$ ) = FALSE Then
        WhatFailed$ = "browse"
        GoTo Failure:
    End If

' Anything else is just a simple name.

  Else
    SearchString$ = NameString$
    GoTo SimpleBrowse:

End If

GoTo Done:

' A straightforward browse:

SimpleBrowse:

If Len( SearchString$) > MAX_LEN_SEARCH_STRING Then SearchString$ = Left$( SearchString$, MAX_LEN_SEARCH_STRING )

Select Case Tag$

  Case "100", "400", "500", "600", "700", "800", "720"
    AFIndex$ = "pn"

  Case "110", "410", "510", "610", "710", "810"
    AFIndex$ = "co"

  Case "111", "411", "511", "611", "711", "811"
    AFIndex$ = "cn"

  Case "150", "450", "550", "650", "655"
    AFIndex$ = "su"

  Case "151", "451", "551", "651"
    AFIndex$ = "gg"

  Case "653"
    AFIndex$ = Search653$

' The only case of a field being browsed without a tag is if the field were actually a
' selection sent to the dialog box as a name/title field. Set the index to browse by the
' presence of a comma. If present, browse the personal name index; otherwise, browse it
' as a general name.

  Case Else
    If InStr( SearchString$, COMMA ) Then
        AFIndex$ = "pn"
      Else
        AFIndex$ = "nw"
    End If

End Select

If CS.Browse( AUTHORITY_FILE, AFIndex$, SearchString$ ) Then
    GoTo Done:
  Else
    WhatFailed$ = "browse"
    GoTo Failure:
End If

Failure:

MsgBox "Sorry, the " & WhatFailed$ & " failed.", CRITICAL_MESSAGE, WaltsMacros$

Done:

End Sub

'****************************************************************************************

Sub Fill5XXArrays( WhichArray%, InArray() As String, Store5XXIndex%, ArrayLabel$, ArrayCount% )

' Given the sub-array to fill (1, 2, or 3, corresponding to the three list boxes
' available), and the index of the main array, this routine fills the sub-arrays from the
' main array and selects a relationship term or phrase for the caption of each list box.

Dim InitialRelationshipCode$
Dim InitialRelationshipTerm$
Dim SubsequentRelationshipCode$
Dim SubsequentRelationshipTerm$

Dim Mixed                    : Mixed = FALSE

Dim i As Integer, j As Integer

' Starting with the previous sub-array's ending row (which will of course be 0 for the
' first array), add terms to the array if they match what's already in the array (which
' will be nothing if the array is just beginning to be filled). As soon as a new
' relationship is found, it goes into the next sub-array.

For i = Store5XXIndex% To CountOf5XX%
  If j = 0 Then
      InitialRelationshipCode$    = Store5XX( aRELATION_CODE, Store5XXIndex% )
      InitialRelationshipTerm$    = Store5XX( aRELATION_TERM, Store5XXIndex% )
    Else
      SubsequentRelationshipCode$ = Store5XX( aRELATION_CODE, i )
      SubsequentRelationshipTerm$ = Store5XX( aRELATION_TERM, i )
  End If

' If the relationship code matches, check the relationship term.

  If ( j = 0 ) Or ( SubsequentRelationshipCode$ = InitialRelationshipCode$ Or WhichArray% = 3 ) Then
      If InitialRelationshipTerm$ = "Unspecified relationship:" Then
          Mixed = TRUE
      End If

' If the term matches, add the heading to the array, and set the label for that
' relationship.

      If ( j = 0 ) Or ( SubsequentRelationshipTerm$ = InitialRelationshipTerm$ Or WhichArray% = 3 ) Then
          ReDim Preserve InArray( j )
          InArray( j )   = Store5XX( aNORMALIZED_HEADING, Store5XXIndex% )
          j              = j + 1
          Store5XXIndex% = Store5XXIndex% + 1
        Else
          Exit For
      End If
    Else
      Exit For
  End If
Next i

ArrayCount% = j

' If there is more than one term in an array, make its label plural.

If WhichArray% < 3 Then
    ArrayLabel$ = Plural( InitialRelationshipTerm$, j )
  Else
    If Mixed Then
        ArrayLabel$ = "Other/Unspecified relationship"
      Else
        If SubsequentRelationshipTerm$ = "" Or InitialRelationshipTerm$ = SubsequentRelationshipTerm$ Then 'only 1 term processed
            ArrayLabel$ = Plural( InitialRelationshipTerm$, j )
          Else
            ArrayLabel$ = "Other relationship"
        End If
    End If
End If

ArrayLabel$ = LCase( Left$( ArrayLabel$, 1 ) ) & Mid$( ArrayLabel$, 2 ) & "):"

End Sub

'****************************************************************************************

Sub FillStoreRefs( InString$ )

' The subroutine takes the headings found in references in the authority record and puts
' them into an array, sorting them and discarding duplicates, and putting subdivisions
' first.

Const STRING1_EQUAL_TO     As Integer = 0
Const STRING1_GREATER_THAN As Integer = 1
Const STRING1_LESS_THAN    As Integer = -1

Dim DisplayTerm$
Dim FirstTerm$
Dim HeadingSeparator%
Dim Start%
Dim TempString$

Dim Subdivision

Dim i As Integer, k As Integer, p As Integer, q As Integer

TempString$ = InString$

If Left$( TempString$, 1 ) = SUBJ_SUBDIV Then
    Subdivision = TRUE
  Else
    Subdivision = FALSE
End If

' Some instructions in a 680 field include a string that contains multiple numbered
' headings, like this one: "Works on an individual style in a specific locality are
' entered under two headings, one for the style and one for the locality, e.g. $a 1.
' Cooking, American--Southern style. 2. Cooking--Georgia--Savannah." Replace the
' numbering with the standard semicolon separator so the individual headings can be
' browsed.

If Left$( InString$, 3 ) = "1. " Then
  TempString$ = Trim$( Mid$( TempString$, 3 ) )
  Start%      = 1
  i           = 2
  Do
    p = InStr( Start%, TempString$, " " & Trim$( Str$( i ) ) & ". " )
    If p > Start% Then
        TempString$ = Trim$( Left$( TempString$, p - 1 ) ) & "; " & Trim$( Mid$( TempString$, p + 4 ) )
    End If
    i      = i + 1
    Start% = p + 4
  Loop Until p = 0
End If

Do

' If the string contains several headings separated by a semicolon (e.g., "$a Cooking,
' American--Southern style; Cooking, Chinese--Sichuan style;") it is easy to separate
' them.

  HeadingSeparator% = InStr( TempString$, ";" )
  If HeadingSeparator% <> 0 Then
      FirstTerm$  = Trim$( Left$( TempString$, HeadingSeparator% - 1 ) )
      TempString$ = Trim$( Mid$( TempString$, HeadingSeparator% + 1 ) )
      If Subdivision Then
          If TempString$ <> "" Then
              TempString$ = SUBJ_SUBDIV & TempString$
          End If
      End If
    Else
      FirstTerm$ = Trim$( TempString$ )
      If FirstTerm$ = "" Then
          Exit Sub
      End If
  End If

  If Right$( FirstTerm$, 1 ) Like "[.,]" Then
      FirstTerm$ = Left$( FirstTerm$, Len( FirstTerm$ ) - 1 )
  End If
  Do
    p = InStr( FirstTerm$, "--" )
    If p > 0 Then
        If p <> 2 Then
            FirstTerm$ = Left$( FirstTerm$, p - 1 ) & DASH & Mid$( FirstTerm$, p + 2 )
          Else
            FirstTerm$ = Left$( FirstTerm$, p - 1 ) & Mid$( FirstTerm$, p + 2 )
        End If
    End If
  Loop Until p = 0

  DisplayTerm$ = Normalize( FirstTerm$, FALSE )

  If Left$( FirstTerm$, 1 ) = SUBJ_SUBDIV Then
  q = Asc( Mid$( FirstTerm$, 2, 1 ) )
      If Mid$( FirstTerm$, 2, 1 ) <> DASH Then
      DisplayTerm$ = "-- " & DisplayTerm$
      End If
  End If
  p = InStr( DisplayTerm$, "--[" )
  If p <> 0 Then
      q = InStr( p + 3, DisplayTerm$, "]" )
      If q = Len( DisplayTerm$ ) Then
          DisplayTerm$ = Trim$( Left$( DisplayTerm$, p - 1 ) )
      End If
  End If

  ReDim Preserve StoreRefs( 1, CountOfReferredTo% )
  If CountOfReferredTo% = 0 Then
      StoreRefs( aRAW_HEADING, CountOfReferredTo% )     = FirstTerm$
      StoreRefs( aNORMALIZED_HEADING, CountOfReferredTo% ) = DisplayTerm$
    Else
      For i = 0 To CountOfReferredTo%
        Select Case StrComp( FirstTerm$, StoreRefs( aRAW_HEADING, i ), 0 )

          Case STRING1_LESS_THAN    'Newest string less than older string
            For k = CountOfReferredTo% To i + 1 Step - 1
              StoreRefs( aRAW_HEADING, k )     = StoreRefs( aRAW_HEADING, k - 1 )
              StoreRefs( aNORMALIZED_HEADING, k ) = StoreRefs( aNORMALIZED_HEADING, k - 1 )
            Next k
            StoreRefs( aRAW_HEADING, i )     = FirstTerm$
            StoreRefs( aNORMALIZED_HEADING, i ) = DisplayTerm$
            Exit For

          Case STRING1_EQUAL_TO
            CountOfReferredTo% = CountOfReferredTo% - 1
            Exit For

          Case STRING1_GREATER_THAN
            If i = CountOfReferredTo% - 1 Then
                StoreRefs( aRAW_HEADING, i + 1 )     = FirstTerm$
                StoreRefs( aNORMALIZED_HEADING, i + 1 ) = DisplayTerm$
                Exit For
            End If

        End Select
      Next i
  End If
  CountOfReferredTo% = CountOfReferredTo% + 1
Loop Until HeadingSeparator% = 0

End Sub

'****************************************************************************************

Sub FillStopwords

' This sub simply fills the array with the words that likely indicate a selection is the
' name of a corporate body.

ReDim Stopwords( STOPWORD_COUNT )

Stopwords( 0   ) = " & "
Stopwords( 1   ) = " ABIDJAN "
Stopwords( 2   ) = " ADDIS ABABA "
Stopwords( 3   ) = " AGENCY "
Stopwords( 4   ) = " AHMEDABAD "
Stopwords( 5   ) = " ALABAMA "
Stopwords( 6   ) = " ALASKA "
Stopwords( 7   ) = " ALBUQUERQUE "
Stopwords( 8   ) = " ALEXANDRIA "
Stopwords( 9   ) = " ALGERIA "
Stopwords( 10  ) = " AMERICA "
Stopwords( 11  ) = " AMERICAN "
Stopwords( 12  ) = " AN "
Stopwords( 13  ) = " AND "
Stopwords( 14  ) = " ANGOLA "
Stopwords( 15  ) = " ANKARA "
Stopwords( 16  ) = " ARGENTINA "
Stopwords( 17  ) = " ARIZONA "
Stopwords( 18  ) = " ARKANSAS "
Stopwords( 19  ) = " ARLINGTON "
Stopwords( 20  ) = " ARMY "
Stopwords( 21  ) = " ASSOCIATION "
Stopwords( 22  ) = " AT "
Stopwords( 23  ) = " ATLANTA "
Stopwords( 24  ) = " AUSTIN "
Stopwords( 25  ) = " AUSTRALIA "
Stopwords( 26  ) = " AUTHORITY "
Stopwords( 27  ) = " BAGHDAD "
Stopwords( 28  ) = " BALTIMORE "
Stopwords( 29  ) = " BAND "
Stopwords( 30  ) = " BANDUNG "
Stopwords( 31  ) = " BANGALORE "
Stopwords( 32  ) = " BANGKOK "
Stopwords( 33  ) = " BANK "
Stopwords( 34  ) = " BEIJING "
Stopwords( 35  ) = " BELGIUM "
Stopwords( 36  ) = " BELO HORIZONTE "
Stopwords( 37  ) = " BERLIN "
Stopwords( 38  ) = " BOARD "
Stopwords( 39  ) = " BOGOR "
Stopwords( 40  ) = " BOGOTA "
Stopwords( 41  ) = " BOLIVIA "
Stopwords( 42  ) = " BOMBAY "
Stopwords( 43  ) = " BOSTON "
Stopwords( 44  ) = " BRASILIA "
Stopwords( 45  ) = " BRAZIL "
Stopwords( 46  ) = " BRIGADE "
Stopwords( 47  ) = " BRITAIN "
Stopwords( 48  ) = " BUCURESTI "
Stopwords( 49  ) = " BUDAPEST "
Stopwords( 50  ) = " BUENOS AIRES "
Stopwords( 51  ) = " BUREAU "
Stopwords( 52  ) = " CAIRO "
Stopwords( 53  ) = " CALCUTTA "
Stopwords( 54  ) = " CALI "
Stopwords( 55  ) = " CALIFORNIA "
Stopwords( 56  ) = " CANADA "
Stopwords( 57  ) = " CARACAS "
Stopwords( 58  ) = " CASABLANCA "
Stopwords( 59  ) = " CHANGCHUN "
Stopwords( 60  ) = " CHARLOTTE "
Stopwords( 61  ) = " CHENGDU "
Stopwords( 62  ) = " CHICAGO "
Stopwords( 63  ) = " CHILE "
Stopwords( 64  ) = " CHINA "
Stopwords( 65  ) = " CHINESE "
Stopwords( 66  ) = " CHONGQING "
Stopwords( 67  ) = " CHORUS "
Stopwords( 68  ) = " CHURCH "
Stopwords( 69  ) = " CIE "
Stopwords( 70  ) = " CIREBON "
Stopwords( 71  ) = " CLEVELAND "
Stopwords( 72  ) = " CLUB "
Stopwords( 73  ) = " CO "
Stopwords( 74  ) = " COALITION "
Stopwords( 75  ) = " COLLEGE "
Stopwords( 76  ) = " COLLOQUIUM "
Stopwords( 77  ) = " COLOMBIA "
Stopwords( 78  ) = " COLORADO "
Stopwords( 79  ) = " COLORADO SPRINGS "
Stopwords( 80  ) = " COLUMBUS "
Stopwords( 81  ) = " COMMISSION "
Stopwords( 82  ) = " COMMITTEE "
Stopwords( 83  ) = " COMMONWEALTH "
Stopwords( 84  ) = " COMPANY "
Stopwords( 85  ) = " CONFERENCE "
Stopwords( 86  ) = " CONGRESS "
Stopwords( 87  ) = " CONNECTICUT "
Stopwords( 88  ) = " CONSORTIUM "
Stopwords( 89  ) = " COOPERATIVE "
Stopwords( 90  ) = " CORPORATION "
Stopwords( 91  ) = " CORPS "
Stopwords( 92  ) = " COUNCIL "
Stopwords( 93  ) = " DALIAN "
Stopwords( 94  ) = " DALLAS "
Stopwords( 95  ) = " DELAWARE "
Stopwords( 96  ) = " DELHI "
Stopwords( 97  ) = " DENVER "
Stopwords( 98  ) = " DEPARTMENT "
Stopwords( 99  ) = " DEPT "
Stopwords( 100 ) = " DETROIT "
Stopwords( 101 ) = " DHAKA "
Stopwords( 102 ) = " DIVISION "
Stopwords( 103 ) = " EAST "
Stopwords( 104 ) = " ECUADOR "
Stopwords( 105 ) = " EGYPT "
Stopwords( 106 ) = " EL PASO "
Stopwords( 107 ) = " ENGLAND "
Stopwords( 108 ) = " ENGLISH "
Stopwords( 109 ) = " ENSEMBLE "
Stopwords( 110 ) = " ESTABLISHMENT "
Stopwords( 111 ) = " ETHIOPIA "
Stopwords( 112 ) = " FAISALABAD "
Stopwords( 113 ) = " FAMILY "
Stopwords( 114 ) = " FEDERAL "
Stopwords( 115 ) = " FEDERATION "
Stopwords( 116 ) = " FELLOWSHIP "
Stopwords( 117 ) = " FLORIDA "
Stopwords( 118 ) = " FOR "
Stopwords( 119 ) = " FORCE "
Stopwords( 120 ) = " FORT WORTH "
Stopwords( 121 ) = " FORTALEZA "
Stopwords( 122 ) = " FOUNDATION "
Stopwords( 123 ) = " FRANCE "
Stopwords( 124 ) = " FRENCH "
Stopwords( 125 ) = " FRESNO "
Stopwords( 126 ) = " GEORGIA "
Stopwords( 127 ) = " GERMAN "
Stopwords( 128 ) = " GERMANY "
Stopwords( 129 ) = " GHANA "
Stopwords( 130 ) = " GIZA "
Stopwords( 131 ) = " GREAT "
Stopwords( 132 ) = " GROUP "
Stopwords( 133 ) = " GROUP "
Stopwords( 134 ) = " GUANGZHOU "
Stopwords( 135 ) = " GUAYAQUIL "
Stopwords( 136 ) = " GUILD "
Stopwords( 137 ) = " HAERBIN "
Stopwords( 138 ) = " HAVANA "
Stopwords( 139 ) = " HAWAII "
Stopwords( 140 ) = " HO CHI MINH CITY "
Stopwords( 141 ) = " HONG KONG "
Stopwords( 142 ) = " HONGKONG "
Stopwords( 143 ) = " HOSPITAL "
Stopwords( 144 ) = " HOUSE "
Stopwords( 145 ) = " HOUSTON "
Stopwords( 146 ) = " HYDERABAD "
Stopwords( 147 ) = " IDAHO "
Stopwords( 148 ) = " ILLINOIS "
Stopwords( 149 ) = " IN "
Stopwords( 150 ) = " INC "
Stopwords( 151 ) = " INCHON "
Stopwords( 152 ) = " INDIA "
Stopwords( 153 ) = " INDIANA "
Stopwords( 154 ) = " INDIANAPOLIS "
Stopwords( 155 ) = " INDONESIA "
Stopwords( 156 ) = " INSTITUTE "
Stopwords( 157 ) = " INSTITUTION "
Stopwords( 158 ) = " INTERNATIONAL "
Stopwords( 159 ) = " IOWA "
Stopwords( 160 ) = " IRAN "
Stopwords( 161 ) = " IRAQ "
Stopwords( 162 ) = " ISRAEL "
Stopwords( 163 ) = " ISTANBUL "
Stopwords( 164 ) = " ITALY "
Stopwords( 165 ) = " IZMIR "
Stopwords( 166 ) = " JACKSONVILLE "
Stopwords( 167 ) = " JAKARTA "
Stopwords( 168 ) = " JAPAN "
Stopwords( 169 ) = " JAPANESE "
Stopwords( 170 ) = " JINAN "
Stopwords( 171 ) = " JOINT "
Stopwords( 172 ) = " KANPUR "
Stopwords( 173 ) = " KANSAS "
Stopwords( 174 ) = " KANSAS CITY "
Stopwords( 175 ) = " KARACHI "
Stopwords( 176 ) = " KENTUCKY "
Stopwords( 177 ) = " KENYA "
Stopwords( 178 ) = " KIEV "
Stopwords( 179 ) = " KINSHASA "
Stopwords( 180 ) = " LAHORE "
Stopwords( 181 ) = " LAS VEGAS "
Stopwords( 182 ) = " LEAGUE "
Stopwords( 183 ) = " LIMA "
Stopwords( 184 ) = " LIMITED "
Stopwords( 185 ) = " LOCAL "
Stopwords( 186 ) = " LONDON "
Stopwords( 187 ) = " LONG BEACH "
Stopwords( 188 ) = " LOS ANGELES "
Stopwords( 189 ) = " LOUISIANA "
Stopwords( 190 ) = " LOUISVILLE "
Stopwords( 191 ) = " LTD "
Stopwords( 192 ) = " MADRAS "
Stopwords( 193 ) = " MADRID "
Stopwords( 194 ) = " MAINE "
Stopwords( 195 ) = " MALANG "
Stopwords( 196 ) = " MALAYSIA "
Stopwords( 197 ) = " MARYLAND "
Stopwords( 198 ) = " MASHHAD "
Stopwords( 199 ) = " MASSACHUSETTS "
Stopwords( 200 ) = " MEDAN "
Stopwords( 201 ) = " MEDELLIN "
Stopwords( 202 ) = " MEETING "
Stopwords( 203 ) = " MEMPHIS "
Stopwords( 204 ) = " MESA "
Stopwords( 205 ) = " MEXICAN "
Stopwords( 206 ) = " MEXICO "
Stopwords( 207 ) = " MEXICO CITY "
Stopwords( 208 ) = " MIAMI "
Stopwords( 209 ) = " MICHIGAN "
Stopwords( 210 ) = " MILWAUKEE "
Stopwords( 211 ) = " MINNEAPOLIS "
Stopwords( 212 ) = " MINNESOTA "
Stopwords( 213 ) = " MISSION "
Stopwords( 214 ) = " MISSISSIPPI "
Stopwords( 215 ) = " MISSOURI "
Stopwords( 216 ) = " MONTANA "
Stopwords( 217 ) = " MOROCCO "
Stopwords( 218 ) = " MOSCOW "
Stopwords( 219 ) = " MOSKVA "
Stopwords( 220 ) = " MUSEUM "
Stopwords( 221 ) = " NAGOYA "
Stopwords( 222 ) = " NANJING "
Stopwords( 223 ) = " NASHVILLE "
Stopwords( 224 ) = " NATIONAL "
Stopwords( 225 ) = " NATIONS "
Stopwords( 226 ) = " NEBRASKA "
Stopwords( 227 ) = " NETHERLANDS "
Stopwords( 228 ) = " NEVADA "
Stopwords( 229 ) = " NEW HAMPSHIRE "
Stopwords( 230 ) = " NEW JERSEY "
Stopwords( 231 ) = " NEW MEXICO "
Stopwords( 232 ) = " NEW YORK "
Stopwords( 233 ) = " NEW ZEALAND "
Stopwords( 234 ) = " NIGERIA "
Stopwords( 235 ) = " NORTH "
Stopwords( 236 ) = " NORTH CAROLINA "
Stopwords( 237 ) = " NORTH DAKOTA "
Stopwords( 238 ) = " OAKLAND "
Stopwords( 239 ) = " OF "
Stopwords( 240 ) = " OFFICE "
Stopwords( 241 ) = " OHIO "
Stopwords( 242 ) = " OKLAHOMA "
Stopwords( 243 ) = " OKLAHOMA CITY "
Stopwords( 244 ) = " OMAHA "
Stopwords( 245 ) = " ON "
Stopwords( 246 ) = " ORCHESTRA "
Stopwords( 247 ) = " ORDER "
Stopwords( 248 ) = " OREGON "
Stopwords( 249 ) = " ORGANISATION "
Stopwords( 250 ) = " ORGANIZATION "
Stopwords( 251 ) = " OSAKA "
Stopwords( 252 ) = " PAKISTAN "
Stopwords( 253 ) = " PARAGUAY "
Stopwords( 254 ) = " PARIS "
Stopwords( 255 ) = " PARLIAMENT "
Stopwords( 256 ) = " PARTNERSHIP "
Stopwords( 257 ) = " PARTY "
Stopwords( 258 ) = " PENNSYLVANIA "
Stopwords( 259 ) = " PERU "
Stopwords( 260 ) = " PHILADELPHIA "
Stopwords( 261 ) = " PHILHARMONIC "
Stopwords( 262 ) = " PHILIPPINES "
Stopwords( 263 ) = " PHOENIX "
Stopwords( 264 ) = " POLAND "
Stopwords( 265 ) = " PORTLAND "
Stopwords( 266 ) = " PRESS "
Stopwords( 267 ) = " PRINTING "
Stopwords( 268 ) = " PTY "
Stopwords( 269 ) = " PUBLISHING "
Stopwords( 270 ) = " PUSAN "
Stopwords( 271 ) = " PYONGYANG "
Stopwords( 272 ) = " QINGDAO "
Stopwords( 273 ) = " QUARTET "
Stopwords( 274 ) = " QUEZON CITY "
Stopwords( 275 ) = " QUINTET "
Stopwords( 276 ) = " RALEIGH "
Stopwords( 277 ) = " RHODE ISLAND "
Stopwords( 278 ) = " RIO DE JANEIRO "
Stopwords( 279 ) = " ROMA "
Stopwords( 280 ) = " RUSSIA "
Stopwords( 281 ) = " RUSSIAN "
Stopwords( 282 ) = " SACRAMENTO "
Stopwords( 283 ) = " SALVADOR "
Stopwords( 284 ) = " SAN ANTONIO "
Stopwords( 285 ) = " SAN DIEGO "
Stopwords( 286 ) = " SAN FRANCISCO "
Stopwords( 287 ) = " SAN JOSE "
Stopwords( 288 ) = " SANTIAGO "
Stopwords( 289 ) = " SAO PAULO "
Stopwords( 290 ) = " SAUDI ARABIA "
Stopwords( 291 ) = " SCHOOL "
Stopwords( 292 ) = " SEATTLE "
Stopwords( 293 ) = " SECRETARIAT "
Stopwords( 294 ) = " SEMARANG "
Stopwords( 295 ) = " SEMINAR "
Stopwords( 296 ) = " SENATE "
Stopwords( 297 ) = " SEOUL "
Stopwords( 298 ) = " SERVICES "
Stopwords( 299 ) = " SHANGHAI "
Stopwords( 300 ) = " SHENYANG "
Stopwords( 301 ) = " SINGAPORE "
Stopwords( 302 ) = " SOCIETY "
Stopwords( 303 ) = " SOUTH "
Stopwords( 304 ) = " SOUTH AFRICA "
Stopwords( 305 ) = " SOUTH CAROLINA "
Stopwords( 306 ) = " SOUTH DAKOTA "
Stopwords( 307 ) = " SOUTH KOREA "
Stopwords( 308 ) = " SPAIN "
Stopwords( 309 ) = " SPANISH "
Stopwords( 310 ) = " SRI LANKA "
Stopwords( 311 ) = " ST. PETERSBURG "
Stopwords( 312 ) = " STATE "
Stopwords( 313 ) = " STATES "
Stopwords( 314 ) = " STIFTUNG "
Stopwords( 315 ) = " SUBCOMMITTEE "
Stopwords( 316 ) = " SUKABUMI "
Stopwords( 317 ) = " SURABAYA "
Stopwords( 318 ) = " SYDNEY "
Stopwords( 319 ) = " SYMPHONY "
Stopwords( 320 ) = " SYMPOSIUM "
Stopwords( 321 ) = " SYNDICATE "
Stopwords( 322 ) = " SYSTEM "
Stopwords( 323 ) = " TAEGU "
Stopwords( 324 ) = " TAIPEI "
Stopwords( 325 ) = " TAIWAN "
Stopwords( 326 ) = " TAIYUAN "
Stopwords( 327 ) = " TASHKENT "
Stopwords( 328 ) = " TEAM "
Stopwords( 329 ) = " TEHRAN "
Stopwords( 330 ) = " TENNESSEE "
Stopwords( 331 ) = " TEXAS "
Stopwords( 332 ) = " THAILAND "
Stopwords( 333 ) = " THE "
Stopwords( 334 ) = " TIANJIN "
Stopwords( 335 ) = " TOKYO "
Stopwords( 336 ) = " TORONTO "
Stopwords( 337 ) = " TRIO "
Stopwords( 338 ) = " TUCSON "
Stopwords( 339 ) = " TULSA "
Stopwords( 340 ) = " TUNISIA "
Stopwords( 341 ) = " TURKEY "
Stopwords( 342 ) = " U.N. "
Stopwords( 343 ) = " U.S. "
Stopwords( 344 ) = " UAE "
Stopwords( 345 ) = " UNITED "
Stopwords( 346 ) = " UNITED KINGDOM "
Stopwords( 347 ) = " UNITED STATES "
Stopwords( 348 ) = " UNIVERSITY "
Stopwords( 349 ) = " URUGUAY "
Stopwords( 350 ) = " US "
Stopwords( 351 ) = " UTAH "
Stopwords( 352 ) = " VENEZUELA "
Stopwords( 353 ) = " VERMONT "
Stopwords( 354 ) = " VIRGINIA "
Stopwords( 355 ) = " VIRGINIA BEACH "
Stopwords( 356 ) = " WASHINGTON "
Stopwords( 357 ) = " WEST "
Stopwords( 358 ) = " WEST VIRGINIA "
Stopwords( 359 ) = " WICHITA "
Stopwords( 360 ) = " WISCONSIN "
Stopwords( 361 ) = " WORKSHOP "
Stopwords( 362 ) = " WUHAN "
Stopwords( 363 ) = " WYOMING "
Stopwords( 364 ) = " XIAN "
Stopwords( 365 ) = " YANGON "
Stopwords( 366 ) = " YOKOHAMA "
Stopwords( 367 ) = " ZIBO "

End Sub

'****************************************************************************************

Function AssignLabels( InString$ ) As String

' This function pairs the most common relationship designations with alphabetic codes, so
' as to sort the headings into a more desirable order, as well as to provide appropriate
' labels for the listboxes.

Dim TempString$

  Select Case InString$

    Case "a"
      TempString$ = "aEarlier heading"
    Case "b"
      TempString$ = "bLater heading"
    Case "g"
      TempString$ = "cBroader term"
    Case "Predecessor:"
      TempString$ = "cPredecessor"
    Case "h"
      TempString$ = "dNarrower term"
    Case "n"
      TempString$ = "nOther heading"
    Case "t"
      TempString$ = "tHierarchical superior"
    Case "Hierarchical superior:"
      TempString$ = "tHierarchical superior"
    Case "Successor:"
      TempString$ = "dSuccessor"
    Case "z"
      TempString$ = "zUnspecified relationship"
    Case Else
      TempString$ = "y" & InString$

  End Select

AssignLabels = TempString$

End Function

'****************************************************************************************

Function BrowseFromAuthorityRecord As String

' If the record in view is an authority record, but the cursor is not in a heading field,
' the macro will offer to browse on the the base authorized heading (the heading shorn of
' extra subfields, such as subject subdivisions, or a title following a name), headings
' referred to in fields 260, 360, 680, or 681, and "see also from" headings in the 5XX
' fields able to be searched by macros (unsearchable tags are 547, 548, 555, 562, and
' 582). Any 5XX field can of course be browsed on by placing the cursor in the field and
' running the macro, so displaying them in a dialog box is only a small saver of time or
' effort.
'
' Subject subdivisions can't be browsed using an expanded term. For example, a browse on
' "bibliography" with "catalogs" as an expanded term just produces a list with
' "Bibliography--Bibliography" as the first entry. But the browse string "bibliography
' catalogs" produces a list with that entry in the middle, highlighted.
'
' These are the different outputs of this function:
'
' BROWSE_AUTHORIZED_HEADING Browse on the authorized heading minus title, subordinate
'   units, and subject subdivisions.
'
' BROWSE_REFERRED_TO_HEADING Browse for the selected heading referred to in a note. A
'   browse is done because a search retrieves headings that contain the term anywhere,
'   arranging them alphabetically, and because there is no way to refine the search--
'   headings referred to have no content coding to help--the browse is the only way to
'   find the heading quickly.
'
' GET_5XX_HEADING Exit the function and retrieve the authority record for the selected
'   see also heading.

Dim ArrayNumber%
Dim AuthorizedHeading$
Dim BrowseIndex$
Dim BrowseString$
Dim CharT$
Dim FieldData$
Dim FunctionReturn$
Dim HeadingString$
Dim IndexStore5XX%
Dim LineCount%
Dim RelationshipInformation$
Dim Remainder$
Dim SearchableFields1$
Dim SearchableFields2$
Dim SearchString$
Dim Start%
Dim SubfieldCode$
Dim SubjSubfieldCodesString$
Dim Tag$
Dim TempString$
Dim Temp_DISPLAY_HEADING$
Dim Temp_HEADING_TAG$
Dim Temp_RAW_HEADING$
Dim Temp_RELATIONSHIP$
Dim Temp_RELATION_INFO$
Dim TracingNote$

Dim FoundField
Dim SubdivRef
Dim Swapped

Dim i As Integer, p As Integer, q As Integer

SearchableFields1$       = "[0135][01]"
SearchableFields2$       = "[015]"
SubjSubfieldCodesString$ = "vxyz"

SubdivRef = FALSE

' Start by going through the record, line by line.

CountOf5XX% = -1
LineCount%  = 1
Do
  FoundField = CS.GetField( "...", LineCount%, FieldData$ )
  If FoundField Then
      Tag$ = Left$( FieldData$, 3 )

' Get the authorized heading, as that may be the subject of a browse, and it wasn't
' captured earlier in the macro, which was only looking at data if the cursor was in a
' heading field. Delete title, subordinate unit, and subject subdivision subfields,
' because the browse on the authorized heading is intended to be on the base heading,
' without any additions, so you can see what other possibilities might be available for
' it.

      If Tag$ Like ( "1" & SearchableFields1$ ) Or Tag$ Like ( "18" & SearchableFields2$ ) Then
          AuthorizedHeading$ = FieldData$
          p = InStr( AuthorizedHeading$, DELIMITER & "t" )
          If p > 0 Then
              AuthorizedHeading$ = Trim$( Left$( AuthorizedHeading$, p - 1 ) )
          End If
          For i = 1 To 4
            p = InStr( 9, AuthorizedHeading$, DELIMITER & Mid$( SubjSubfieldCodesString$, i, 1 ) )
            If p > 0 Then
                AuthorizedHeading$ = Trim$( Left$( AuthorizedHeading$, p - 1 ) )
            End If
          Next i
          If Left$( Tag$, 2 ) = "11" Then
              p = InStr( AuthorizedHeading$, DELIMITER & "b" )
              If p > 0 Then
                  AuthorizedHeading$ = Trim$( Left$( AuthorizedHeading$, p - 1 ) )
              End If
          End If
          BaseHeading$ = Normalize( AuthorizedHeading$, FALSE )

          Select Case Left$( Tag$, 2 )
            Case "10", "11"
              BaseHeading$ = Tag$& Trim$( Mid$( BaseHeading$, 6 ) )
            Case "13"
              BaseHeading$ = Tag$ & Trim$( Mid$( BaseHeading$, 6 ) )
            Case "18"
              BaseHeading$ = Tag$ & Trim$( Mid$( BaseHeading$, 5 ) )
            Case "15"
              BaseHeading$ = Tag$ & Trim$( Mid$( BaseHeading$, 5 ) )
          End Select
          BaseHeading$ = Trim$( BaseHeading$ )

' Terms referred to are in subfield $a in fields 260, 360, 680, and 681. Store any terms
' found in those subfields in an array for display.

        ElseIf Tag$ Like "[23]60" Or Tag$ Like "68[01]" Then
          TracingNote$ = Mid$( FieldData$, FIELD_DATA_BEGINS )
          If Left$( TracingNote$, 1 ) <> DELIMITER Then
              TracingNote$ = DELIMITER & "a " & TracingNote$
          End If
          Start% = 1
          Do
            p = InStr( Start%, TracingNote$, DELIMITER )
            If p <> 0 Then
                If Mid$( TracingNote$, p + 1, 1 ) = "a" Then
                    q = InStr( p + 2, TracingNote$, DELIMITER )
                    If q <> 0 Then
                        HeadingString$ = Trim$( Mid$( TracingNote$, p + 2, q - p - 2 ) )
                      Else
                        HeadingString$ = Trim$( Mid$( TracingNote$, p + 2 ) )
                    End If

' If the word "subdivision" appears in the preceding subfield $i (as in: "$i subdivision
' $a Politics and government $i under names of countries, cities, etc."), consider the
' string to be a subdivision. The macro can find subdivisions in two subfields $a
' separated by an "and" in subfield $i, but any grammatical construction more complex is
' beyond its scope.

                    If p > 1 Then
                        TempString$ = Trim$( Mid$( TracingNote$, Start% + 1, p - Start% - 1 ) )
                    End If
                    If InStr( TempString$, "subdivision" ) Then
                        SubdivRef      = TRUE
                        HeadingString$ = SUBJ_SUBDIV & HeadingString$
                      ElseIf TempString$ = "and" Then
                        If SubdivRef Then
                            HeadingString$ = SUBJ_SUBDIV & HeadingString$
                            SubdivRef      = FALSE
                        End If
                    End If
                End If
                If HeadingString$ <> "" Then
                    Call FillStoreRefs( HeadingString$ )
                End If
            End If
            Start% = p + 1
          Loop Until p = 0

' Store all the searchable 5XX fields in an array. In this case, "searchable" means able
' to be searched, or browsed, by a macro. The macro language doesn't yet have the
' capability, for example, to browse genre headings.

        ElseIf Tag$ Like ( "5" & SearchableFields1$ ) Or Tag$ Like ( "58" & SearchableFields2$ ) Then
          If Mid$( FieldData$, FIELD_DATA_BEGINS, 1 ) <> DELIMITER Then
              FieldData$ = Left$( FieldData$, 5 ) & DELIMITER & "a " & Mid$( FieldData$, FIELD_DATA_BEGINS )
          End If

' Get rid of control subfields by finding the first occurrence of one and truncating the
' string there and then.

          Start% = 1
          Do
            p = InStr( Start%, FieldData$, DELIMITER )
            If p > 0 Then
                SubfieldCode$ = Mid$( FieldData$, p + 1, 1 )
                If SubfieldCode$ Like "[0-9]" Then
                    FieldData$ = Trim$( Left$( FieldData$, p - 1 ) )
                    Exit Do
                End If
              Start% = p + 1
            End If
          Loop Until p = 0

' Look for a subfield $w in each 5XX field. If present, it can contain a single-letter
' code or a string of codes. If the single letter is not "r," it is the old code for
' earlier, later, broader, or narrower (this last code provided for but not implemented
' by LC). The code "r" means that the relationship is named in subfield $i. If a string
' of codes is present, it begins with "n" and simply means, for purposes of this macro,
' that the relationship between the headings is not identified. If no subfield $w is
' present, add one, using the code "z" to mean no relationship is specified.

          p = InStr( FieldData$, DELIMITER & "w" )
          If p > 0 Then
              RelationshipInformation$ = Trim$( Mid$( FieldData$, p + 2, 3 ) )
              FieldData$               = Left$( FieldData$, p - 1 ) & Mid$( FieldData$, p + 5 )
              If RelationshipInformation$ = "r" Then
                  p = InStr( FieldData$, DELIMITER & "i" )
                  If p > 0 Then
                      q = InStr( p + 1, FieldData$, DELIMITER )
                      If q > 0 Then
                          RelationshipInformation$ = Trim$( Mid$( FieldData$, p + 2, q - p - 2 ) )
                          FieldData$               = Left$( FieldData$, p - 1 ) & Mid$( FieldData$, q + 3 )
                        Else
                          BrowseFromAuthorityRecord = FAILURE
                          Exit Function
                      End If
                    Else
                      BrowseFromAuthorityRecord = FAILURE
                      Exit Function
                  End If
                ElseIf Left$( RelationshipInformation$, 1 ) = "n" Then
                  RelationshipInformation$ = "z"
              End If
              p = InStr( FieldData$, DELIMITER )
              If p > 0 Then
                  If Mid$( FieldData$, p + 1, 1 ) Like "[avxyz]" Then
                      FieldData$ = Left$( FieldData$, 5 ) & Trim$( Mid$( FieldData$, p + 2 ) )
                  End If
              End If
            Else
              FieldData$               = Left$( FieldData$, 5 ) & Trim$( Mid$( FieldData$, 8 ) )
              RelationshipInformation$ = "z"
          End If

' Load the main array with the information collected.

          CountOf5XX%                                  = CountOf5XX% + 1
          ReDim Preserve Store5XX( aRELATION_CODE, CountOf5XX% )

' Fix up the statement of relationship: Delete a terminal colon (the macro puts one back
' in), and truncate it if it is too long to fit into the dialog box.

          If Right$( RelationshipInformation$, 1 ) = ":" Then
              RelationshipInformation$ = Left$( RelationshipInformation$, Len( RelationshipInformation$ ) - 1 )
          End If
          If Len( RelationshipInformation$ ) > 36 Then
              For i = 36 To 1 Step -1
                CharT$ = Mid$( RelationshipInformation$, i, 1 )
                If CharT$ = " " Then
                    RelationshipInformation$ = Left$( RelationshipInformation$, i - 1 ) & "..."
                    Exit For
                End If
              Next i
          End If
          TempString$                                  = AssignLabels( RelationshipInformation$ )
          Store5XX( aRELATION_CODE, CountOf5XX% )      = Left$( TempString$, 1 )
          Store5XX( aRELATION_TERM, CountOf5XX% )      = Mid$( TempString$, 2 )
          Store5XX( aRAW_HEADING, CountOf5XX% )        = FieldData$
          Store5XX( aNORMALIZED_HEADING, CountOf5XX% ) = Normalize( Mid$( FieldData$, FIELD_DATA_BEGINS ), FALSE )
          Store5XX( aHEADING_TAG, CountOf5XX% )        = Tag$
      End If
  End If
  LineCount% = LineCount% + 1
Loop Until FoundField = FALSE

' If the main array of 5XX fields contains more than one term, sort them so the common
' terms appear first. A simple bubble sort suffices to order them by the single-letter
' code in the first element of each row, which was assigned by the function
' "AssignLabels." Headings with the same code are not further sorted, and because of the
' type of sort, remain in the order in which they appear in the record. Even if the main
' array contains only one term, continue with the macro, rather than searching it
' immediately, simply so it can be displayed and its relationship put into words from a
' code.

If CountOf5XX% > 1 Then
    Do
      Swapped = FALSE
      For i = 0 To CountOf5XX% - 1
        If Store5XX( aRELATION_CODE, i ) > Store5XX( aRELATION_CODE, i + 1 ) Then
            Temp_RELATION_INFO$                    = Store5XX( aRELATION_CODE, i )
            Temp_RELATIONSHIP$                     = Store5XX( aRELATION_TERM, i )
            Temp_RAW_HEADING$                      = Store5XX( aRAW_HEADING, i )
            Temp_DISPLAY_HEADING$                  = Store5XX( aNORMALIZED_HEADING, i )
            Temp_HEADING_TAG$                      = Store5XX( aHEADING_TAG, i )
            Store5XX( aRELATION_CODE, i )          = Store5XX( aRELATION_CODE, i + 1 )
            Store5XX( aRELATION_TERM, i)           = Store5XX( aRELATION_TERM, i + 1 )
            Store5XX( aRAW_HEADING, i )            = Store5XX( aRAW_HEADING, i + 1 )
            Store5XX( aNORMALIZED_HEADING, i)      = Store5XX( aNORMALIZED_HEADING, i + 1 )
            Store5XX( aHEADING_TAG, i )            = Store5XX( aHEADING_TAG, i + 1 )
            Store5XX( aRELATION_CODE, i + 1 )      = Temp_RELATION_INFO$
            Store5XX( aRELATION_TERM, i + 1 )      = Temp_RELATIONSHIP$
            Store5XX( aRAW_HEADING, i + 1 )        = Temp_RAW_HEADING$
            Store5XX( aNORMALIZED_HEADING, i + 1 ) = Temp_DISPLAY_HEADING$
            Store5XX( aHEADING_TAG, i + 1 )        = Temp_HEADING_TAG$
            Swapped = TRUE
        End If
      Next i
    Loop Until Swapped = FALSE
End If

' Fill the arrays that will display in the dialog box. Start with the array that holds
' headings referred to, if any.

If CountOfReferredTo% > 0 Then
    For i = 0 To UBound( StoreRefs, 2 )
      ReDim Preserve DisplayRefs( i )
      DisplayRefs( i ) = StoreRefs( aNORMALIZED_HEADING, i )
    Next i
End If

' Continue by filling the arrays of 5XX fields which populate the list boxes in the
' dialog box. Providing three arrays seems to work for most headings to display all the
' relationships: one array for earlier/later/broader/narrower, one for another kind of
' relationship, and the third for other or unspecified relationships. If there are more
' than three kinds of specific relationships, the remaining ones are combined into the
' catchall group of "Other." The relationship itself serves as the label in the dialog
' box.

IndexStore5XX% = 0
For ArrayNumber% = 1 To 3
  If IndexStore5XX% <= CountOf5XX% Then
      Select Case ArrayNumber%
        Case 1
          Call Fill5XXArrays( ArrayNumber%, Display5XX_1(), IndexStore5XX%, Display5XX_1Label$, Display5XX_1Count% )
        Case 2
          Call Fill5XXArrays( ArrayNumber%, Display5XX_2(), IndexStore5XX%, Display5XX_2Label$, Display5XX_2Count% )
        Case 3
          Call Fill5XXArrays( ArrayNumber%, Display5XX_3(), IndexStore5XX%, Display5XX_3Label$, Display5XX_3Count% )
      End Select
  End If
Next ArrayNumber%

' Display the dialog box to get the term to search or browse on.

If CountOfReferredTo% > 0 Or CountOf5XX% > -1 Then
    FunctionReturn$ = DisplayAuthorityRecordBrowses( MatchString$ )
    If FunctionReturn$ = FAILURE or FunctionReturn$ = QUIT Then
        BrowseFromAuthorityRecord = FunctionReturn$
        Exit Function
    End If
  Else
    FunctionReturn$ = BROWSE_AUTHORIZED_HEADING & BaseHeading$
End If

Select Case Left$( FunctionReturn$, 1 )

  Case BROWSE_AUTHORIZED_HEADING

    Tag$          = Mid$( FunctionReturn$, 2, 3 )
    BrowseString$ = Mid$( FunctionReturn$, 5 )

    Select Case Tag$
      Case "180", "185"
        BrowseIndex$ = "sb"
      Case "100"
        BrowseIndex$ = "pn"
      Case "110", "111"
        BrowseIndex$ = "co"
      Case "130"
        BrowseIndex$ = "ti"
      Case "150"
        BrowseIndex$ = "to"
      Case "151"
        BrowseIndex$ = "gg"
    End Select
    If CS.Browse( AUTHORITY_FILE, BrowseIndex$, BrowseString$ ) = FALSE Then
        BrowseFromAuthorityRecord = FAILURE
      Else
        BrowseFromAuthorityRecord = QUIT
    End If
    Exit Function

  Case BROWSE_REFERRED_TO_HEADING

    BrowseString$ = Mid$( FunctionReturn$, 2 )

    p = InStr( BrowseString$, COMMA )
    If p <> 0 Then
        BrowseString$ = Left$( BrowseString$, p - 1 ) & Mid$( BrowseString$, p + 1 )
    End If

    If Left$( BrowseString$, 3 ) = "-- " Then
        BrowseString$ = Trim$( Mid$( BrowseString$, 4 ) )
        If CS.Browse( AUTHORITY_FILE, "sb", BrowseString$ ) = FALSE Then
            BrowseFromAuthorityRecord = FAILURE
            Exit Function
        End If
      Else
        p = InStr( BrowseString$, "--" )
        If p = 0 Then
            If CS.Browse( AUTHORITY_FILE, "su", BrowseString$ ) = FALSE Then
                BrowseFromAuthorityRecord = FAILURE
              Else

' This next little bit of code highlights the search result that matches the search
' exactly. When a heading is the same as a subdivision, in the list of "Root Results,"
' the subdivision, which comes first in the list, is highlighted. Which is not what we
' want.

                q = CS.SearchList( MatchString$, "Root Results", TRUE )
                BrowseFromAuthorityRecord = QUIT
            End If
          Else
            Remainder$    = Trim$( Mid$( BrowseString$, p + 2 ) )
            BrowseString$ = Trim$( Left$( BrowseString$, p - 1 ) )
            Do
              p = InStr( Remainder$, "--" )
              If p > 0 Then
                  Remainder$ = Left$( Remainder$, p - 1 ) & " " & Mid$( Remainder$, p + 2 )
              End If
            Loop Until p = 0
            If CS.BrowseAuthorityExpanded( "0", "su", BrowseString$, Remainder$ ) = FALSE Then
                BrowseFromAuthorityRecord = FAILURE
                Exit Function
            End If
        End If
    End If
    BrowseFromAuthorityRecord = QUIT
    Exit Function

  Case GET_5XX_HEADING
    BrowseFromAuthorityRecord = FunctionReturn$
    Exit Function

End Select

BrowseFromAuthorityRecord = QUIT

End Function

'****************************************************************************************

Function BrowseFromSelectedText As String

Const SUBJECT_SELECT As Integer = 5

Dim InvertPoint%
Dim SearchString$
Dim TempString$
Dim WorkString$

Dim i As Integer, p As Integer

' The first thing to do with a selection, or the portion of a selection that has been
' identified as a title, is to check if the first word is an article. If an initial
' article is found the selection is assumed to be a title.

CountOfNames% = 1
If NameTitleType% = SELECTION_NAME_TITLE Then
    TempString$ = TitleString$
  Else
    TempString$ = NormalizedString$
End If

TempString$ = InitialArticle( TempString$ )

' If the selection began with the abbreviation "A.", the abbreviation was marked so it
' would not be considered an initial article and removed. Take out that mark now.

p = InStr( TempString$, ESC )
If p <> 0 Then
    TempString$ = Left$( TempString$, p - 1 ) & Mid$( TempString$, p + 1 )
End If

' Then check the string for music flat and sharp signs. If one is found, again, the
' selection is assumed to be a title.

TempString$ = FlatSharpFix( TempString$, MUSIC_SIGN_TO_WORD )

If NameTitleType% = SELECTION_NAME_TITLE Then
    TitleHeading$ = TempString$
    SearchString$ = NameString$
  Else
    SearchString$ = TempString$
End If

' If the selection is of two or three words, it is presented for choice of browsing in
' two forms--as selected, to be browsed as a generic name, and inverted, to be browsed as
' a personal name. The inverted form is simply the last word first, unless the last two
' words are connected by a hyphen, in which case that pair comes first in the string. The
' function "InvertOption" returns the position in the string where it can be broken for
' inversion; a return value of zero means the name can't be inverted, as when the name is
' a single word. The "Names" array holds both forms. If it seems probable that the
' inverted form represents a personal name, that is put into the first element of the
' array; otherwise the original form is put into the first element.

InvertPoint% = InvertOption( SearchString$ )
If InvertPoint% = 0 Then
    ReDim Names( 0 )
    Names( 0 ) = Trim$( SearchString$ )
  Else
    ReDim Names( 1 )
    WorkString$ = Mid$( SearchString$, InvertPoint% ) & ", " & Left$( SearchString$, InvertPoint% - 1 )
    If Invertibility% = INVERTIBLE_BY_DEFAULT Then
        Names( 0 ) = Trim$( WorkString$ )
        Names( 1 ) = Trim$( SearchString$ )
      Else
        Names( 0 ) = Trim$( SearchString$ )
        Names( 1 ) = Trim$( WorkString$ )
    End If
End If

' Remove any hyphens from the names in the array.

For i = 0 To UBound( Names )
  WorkString$ = Names( i )
  Do
    p = InStr( WorkString$, "-" )
    If p <> 0 Then
        WorkString$ = Left$( WorkString$, p - 1 ) & " " & Mid$( WorkString$, p + 1 )
    End If
  Loop Until p = 0
  Names( i )  = WorkString$
Next i

If NameTitleType% = SELECTION_NAME_TITLE Then
    BrowseFromSelectedText = "GoToNameTitleBrowse"
    Exit Function
End If

Select Case ChooseBrowse( "", "", "" )

  Case DLG_STATEMENT_CANCEL
    BrowseFromSelectedText = QUIT
    Exit Function

  Case NAME_SELECT
    AFIndex$ = "nw"

  Case NAME_INVERTED
    AFIndex$ = "pn"

  Case SUBJECT_SELECT
    AFIndex$ = "su"

  Case TITLE_SELECT
    AFIndex$ = "ti"

End Select

If CS.Browse( AUTHORITY_FILE, AFIndex$, SearchTerm1$ ) = FALSE Then
    BrowseFromSelectedText = FAILURE
  Else
    BrowseFromSelectedText = QUIT
End If

End Function

'****************************************************************************************

Function ChooseBrowse( OptionParam1$, OptionParam2$, OptionParam3$ )

' The dialog box that shows what's being browsed and how to do it. It has two layouts:
'  + For browsing by field (or a selection considered to be a name/title field), options
'    1-3 allow a browse on a main heading, subject subdivisions or a title, or both, in
'    an expanded browse, using one or two entry boxes.
'  + For browsing by selection, the first three options are hidden, and a single entry
'    box shows the string to be browsed as a name (in direct or inverted order), a
'    subject, or a title.
' The entry boxes that show the normalized strings are either text boxes or drop combo
' boxes, so their contents can be edited to tweak the browse strings. The parameters
' passed to the dialog box control the text of the radio buttons and the commit button in
' each layout.

Dim p As Integer

SearchOption1$ = OptionParam1$
SearchOption2$ = OptionParam2$
SearchOption3$ = OptionParam3$

If SearchOption3$ <> "" Then SearchOption3$ = "Expanded browse " & SearchOption3$

Begin Dialog Dialog2Definition  320, 156, WaltsMacros$, .Dialog2ControlFunction
  ButtonGroup                                           .Choice
   PushButton     76, 134, 104,  14, "",                .CommitButton
   CancelButton  190, 134,  52,  14
  Text            16,  22, 128,  10, "",                .AlternateBT1
  OptionGroup                                           .BrowseType
   OptionButton   16,  21, 128,  12, "",                .OptionButton1
   OptionButton   16,  65, 128,  12, "",                .OptionButton2
   OptionButton   16, 109, 240,  12, "",                .OptionButton3
   OptionButton   16,  21,  38,  12, "&Name",           .OptionButton4
   OptionButton   56,  21,  64,  12, "Name, &Inverted", .OptionButton5
   OptionButton  126,  21,  38,  12, "&Subject",        .OptionButton6
   OptionButton  170,  21,  38,  12, "&Title",          .OptionButton7
  TextBox         16,  34, 288,  12,                    .TextBox1
  TextBox         16,  78, 288,  12,                    .TextBox2
  DropComboBox    16,  34, 288,  64, Names(),           .DropComboBox1
  DropComboBox    16,  78, 288,  96, Subdivisions(),    .DropComboBox2
  GroupBox         8,  14, 304,  40, ""
  GroupBox         8,  58, 304,  40, "",                .GroupBox2
  GroupBox         8, 102, 304,  23, "",                .GroupBox3
  Text           203,  23, 100,   8, "",                .Attention1
  Text           201,  67,  88,   8, "",                .Attention2
  Text             8,   6, 104,   8, "Select/edit what to browse on:"
End Dialog

Dim Dialog2 as Dialog2Definition
On Error Resume Next
Dialog Dialog2
If Err = DLG_STATEMENT_CANCEL Then
    ChooseBrowse = DLG_STATEMENT_CANCEL
    Exit Function
End If

ChooseBrowse = Dialog2.BrowseType

SearchTerm1$ = Trim$( Dialog2.TextBox1 )
If SearchTerm1$ = "" Then SearchTerm1$ = Trim$( Dialog2.DropComboBox1 )

If TextSelection And NameTitleType% = NOT_NAME_TITLE Then
    SearchTerm2$ = ""
  Else
    SearchTerm2$ = Trim$( Dialog2.TextBox2 )
    If SearchTerm2$ = "" Then SearchTerm2$ = Trim$( Dialog2.DropComboBox2 )
End If

' Remove all periods from name headings, and all dashes from subject subdivision strings.

Do
  p = InStr( SearchTerm1$, "." )
  If p <> 0 Then SearchTerm1$ = Left$( SearchTerm1$, p - 1 ) & Mid$( SearchTerm1$, p + 1 )
Loop Until p = 0

Do
  p = InStr( SearchTerm2$, "--" )
  If p <> 0 Then SearchTerm2$ = Left$( SearchTerm2$, p - 1 ) & Mid$( SearchTerm2$, p + 2 )
Loop Until p = 0
SearchTerm2$ = Trim$( DoubleSpaceErase( SearchTerm2$ ) )

End Function

'****************************************************************************************

Function DisplayAuthorityRecordBrowses( OutString$ ) As String

Dim ArrayIndex%
Dim EstablishedHeading$
Dim HeadingLegend$
Dim Prompt$
Dim ReferredToHeading$
Dim SeeAlsoHeading$
Dim TextBoxInput$

HeadingLegend$ = "&1  Browse authorized heading:"
Prompt$        = "Choose action..."

If CountOfReferredTo% > 0 Then
    ReDim Preserve StoreRefs( 1, CountOfReferredTo% - 1 )
End If

If ( CountOfReferredTo% > 0 And Display5XX_1Count% = 0 ) Or _
   ( CountOfReferredTo% = 0 And ( Display5XX_1Count% > 0 And Display5XX_2Count% = 0 ) ) Then
    Begin Dialog Dialog3_1_ListBoxDefinition  256, 142, WaltsMacros$, .Dialog3_1_ListBoxControlFunction
      OkButton       134, 118,  52,  14
      CancelButton   194, 118,  52,  14
      OptionGroup                                        .OptionGroup
       OptionButton   10,  18, 236,  12, HeadingLegend$, .OptionButtonHeading
       OptionButton   10,  46, 236,  12, "",             .OptionButtonListBox1
      TextBox         22,  30, 224,  12,                 .EstablishedHeading
      ListBox         22,  58, 224,  56, "",             .ListBox1
      Text            10,   6, 128,   8, Prompt$
    End Dialog
    Dim Dialog3_1_ListBox As Dialog3_1_ListBoxDefinition
    On Error Resume Next
    Dialog Dialog3_1_ListBox
    If Err = DLG_STATEMENT_CANCEL Then
        DisplayAuthorityRecordBrowses = QUIT
        Exit Function
    End If
    If Dialog3_1_ListBox.OptionGroup = 0 Then
        TextBoxInput$ = Dialog3_1_ListBox.EstablishedHeading
        If TextBoxInput$ = Mid$( BaseHeading$, 2 ) Then
            EstablishedHeading$ = BaseHeading$
          Else
            EstablishedHeading$ = TextBoxInput$
        End If
      Else
        ArrayIndex% = Dialog3_1_ListBox.ListBox1
        If CountOfReferredTo% > 0 Then
            ReferredToHeading$ = StoreRefs( aNORMALIZED_HEADING, ArrayIndex% )
        End If
    End If

  ElseIf ( CountOfReferredTo% > 0 And Display5XX_2Count% = 0 ) Or _
         ( CountOfReferredTo% = 0 And ( Display5XX_2Count% > 0 And Display5XX_3Count% = 0 ) ) Then
    Begin Dialog Dialog3_2_ListBoxesDefinition  256, 208, WaltsMacros$, .Dialog3_2_ListBoxesControlFunction
      OkButton       102, 184,  52,  14
      CancelButton   162, 184,  52,  14
      OptionGroup                                        .OptionGroup
       OptionButton   10,  18, 236,  12, HeadingLegend$, .OptionButtonHeading
       OptionButton   10,  46, 236,  12, "",             .OptionButtonListBox1
       OptionButton   10, 112, 236,  12, "",             .OptionButtonListBox2
      TextBox         22,  30, 224,  12,                 .EstablishedHeading
      ListBox         22,  58, 224,  56, "",             .ListBox1
      ListBox         22, 124, 224,  56, "",             .ListBox2
      Text            10,   6, 128,   8, Prompt$
    End Dialog
    Dim Dialog3_2_ListBoxes As Dialog3_2_ListBoxesDefinition
    On Error Resume Next
    Dialog Dialog3_2_ListBoxes
    If Err = DLG_STATEMENT_CANCEL Then
        DisplayAuthorityRecordBrowses = QUIT
        Exit Function
    End If
    Select Case Dialog3_2_ListBoxes.OptionGroup
      Case 0
        EstablishedHeading$ = Dialog3_2_ListBoxes.EstablishedHeading
      Case 1
        ArrayIndex% = Dialog3_2_ListBoxes.ListBox1
        If CountOfReferredTo% > 0 Then
            ReferredToHeading$ = StoreRefs( aNORMALIZED_HEADING, ArrayIndex% )
        End If
      Case 2
        If CountOfReferredTo% > 0 Then
            ArrayIndex% = Dialog3_2_ListBoxes.ListBox2
          Else
            ArrayIndex% = Dialog3_2_ListBoxes.ListBox2 + Display5XX_1Count%
        End If
    End Select

  ElseIf ( CountOfReferredTo% > 0 And Display5XX_3Count% = 0 ) Or CountOfReferredTo% = 0 Then
    Begin Dialog Dialog3_3_ListBoxesDefinition  256, 284, WaltsMacros$, .Dialog3_3_ListBoxesControlFunction
      PushButton     102, 260,  52,  14, "&Search",      .OK
      CancelButton   162, 260,  52,  14
      OptionGroup                                        .OptionGroup
       OptionButton   10,  18,  80,  12, HeadingLegend$, .OptionButtonHeading
       OptionButton   10,  50, 236,  12, "",             .OptionButtonListBox1
       OptionButton   10, 120, 236,  12, "",             .OptionButtonListBox2
       OptionButton   10, 190, 236,  12, "",             .OptionButtonListBox3
      TextBox         22,  30, 224,  12,                 .EstablishedHeading
      ListBox         22,  62, 224,  56, Display5XX_1(), .ListBox1
      ListBox         22, 132, 224,  56, "",             .ListBox2
      ListBox         22, 202, 224,  56, "",             .ListBox3
      Text            10,   6, 128,   8, Prompt$
    End Dialog
    Dim Dialog3_3_ListBoxes As Dialog3_3_ListBoxesDefinition
    On Error Resume Next
    Dialog Dialog3_3_ListBoxes
    If Err = DLG_STATEMENT_CANCEL Then
        DisplayAuthorityRecordBrowses = QUIT
        Exit Function
    End If
    Select Case Dialog3_3_ListBoxes.OptionGroup
      Case 0
        EstablishedHeading$ = Dialog3_3_ListBoxes.EstablishedHeading
      Case 1
        ArrayIndex% = Dialog3_3_ListBoxes.ListBox1
        If CountOfReferredTo% > 0 Then
            ReferredToHeading$ = StoreRefs( aNORMALIZED_HEADING, ArrayIndex% )
        End If
      Case 2
        If CountOfReferredTo% > 0 Then
            ArrayIndex% = Dialog3_3_ListBoxes.ListBox2
          Else
            ArrayIndex% = Dialog3_3_ListBoxes.ListBox2 + Display5XX_1Count%
        End If
      Case 3
        If CountOfReferredTo% > 0 Then
            ArrayIndex% = Dialog3_3_ListBoxes.ListBox3 + Display5XX_1Count%
          Else
            ArrayIndex% = Dialog3_3_ListBoxes.ListBox3 + Display5XX_1Count% + Display5XX_2Count%
        End If
    End Select

  Else

    Begin Dialog Dialog3_4_ListBoxesDefinition  256, 356, WaltsMacros$, .Dialog3_4_ListBoxesControlFunction
      PushButton     102, 332,  52,  14, "&Search",      .OK
      CancelButton   162, 332,  52,  14
      OptionGroup                                        .OptionGroup
       OptionButton   10,  18,  80,  12, HeadingLegend$, .OptionButtonHeading
       OptionButton   10,  50, 236,  12, "",             .OptionButtonListBox1
       OptionButton   10, 120, 236,  12, "",             .OptionButtonListBox2
       OptionButton   10, 190, 236,  12, "",             .OptionButtonListBox3
       OptionButton   10, 260, 236,  12, "",             .OptionButtonListBox4
      TextBox         22,  30, 224,  12,                 .EstablishedHeading
      ListBox         22,  62, 224,  56, Display5XX_1(), .ListBox1
      ListBox         22, 132, 224,  56, "",             .ListBox2
      ListBox         22, 202, 224,  56, "",             .ListBox3
      ListBox         22, 272, 224,  56, "",             .ListBox4
      Text            10,   6, 128,   8, Prompt$
    End Dialog
    Dim Dialog3_4_ListBoxes As Dialog3_4_ListBoxesDefinition
    On Error Resume Next
    Dialog Dialog3_4_ListBoxes
    If Err = DLG_STATEMENT_CANCEL Then
        DisplayAuthorityRecordBrowses = QUIT
        Exit Function
    End If
    Select Case Dialog3_4_ListBoxes.OptionGroup
      Case 0
        EstablishedHeading$ = Dialog3_4_ListBoxes.EstablishedHeading
      Case 1
        ReferredToHeading$ = StoreRefs( aNORMALIZED_HEADING, ArrayIndex% )
      Case 2
        ArrayIndex% = Dialog3_4_ListBoxes.ListBox2
      Case 3
        ArrayIndex% = Dialog3_4_ListBoxes.ListBox3 + Display5XX_1Count%
      Case 4
        ArrayIndex% = Dialog3_4_ListBoxes.ListBox4 + Display5XX_1Count% + Display5XX_2Count%
    End Select

End If

' The "OutString" is the heading as it appears in the record, and is used to narrow a
' browse or find the heading in a list after a search.

If EstablishedHeading$ <> "" Then
    DisplayAuthorityRecordBrowses = BROWSE_AUTHORIZED_HEADING & BaseHeading$
  ElseIf ReferredToHeading$ <> "" Then
    DisplayAuthorityRecordBrowses = BROWSE_REFERRED_TO_HEADING & ReferredToHeading$
    OutString$                    = StoreRefs( aRAW_HEADING, ArrayIndex% )
  Else
    SeeAlsoHeading$               = Store5XX( aNORMALIZED_HEADING, ArrayIndex% )
    OutString$                    = Store5XX( aRAW_HEADING, ArrayIndex% )
    DisplayAuthorityRecordBrowses = GET_5XX_HEADING & SeeAlsoHeading$
End If

End Function

'****************************************************************************************

Function DoubleSpaceErase( SomeString$ )

' This function simply removes double spaces from a string.

Dim TempString$

Dim p As Integer

TempString$ = Trim$( SomeString$ )

Do
  p = InStr( TempString$, "  " )
  If p <> 0 Then TempString$ = Left$( TempString$, p ) & Mid$( TempString$, p + 2 )
Loop Until p = 0

DoubleSpaceErase = TempString$

End Function

'****************************************************************************************

Function FlatSharpFix( SomeString$, Switch% )

' This function changes the music flat and sharp signs, which do not display properly in
' the dialog box, into the words "flat" and "sharp". It also sets the flag that the
' input string is probably a title. Conversely, if a search term has been entered using
' the terms "-flat" or "-sharp", this function converts them to the appropriate character
' in order to properly execute the search.

Dim TempString$

Dim MUSIC_FLAT_SIGN  As String*1 : MUSIC_FLAT_SIGN  = Chr$( 169 )
Dim MUSIC_SHARP_SIGN As String*1 : MUSIC_SHARP_SIGN = Chr$( 204 )

Dim p As Integer

TempString$ = Trim$( SomeString$ )

If Switch% = MUSIC_SIGN_TO_WORD Then

' Convert the music flat and sharp signs to words for the display.

    Do
      p = InStr( TempString$, MUSIC_FLAT_SIGN )
      If p <> 0 Then
          TempString$   = Left$( TempString$, p - 1 ) & "-FLAT" & Mid$( TempString$, p + 1 )
          ProbableTitle = TRUE
      End If
    Loop Until p = 0

    Do
      p = InStr( 1, TempString$, MUSIC_SHARP_SIGN )
      If p <> 0 Then
          TempString$   = Left$( TempString$, p - 1 ) & "-SHARP" & Mid$( TempString$, p + 1 )
          ProbableTitle = TRUE
      End If
    Loop Until p = 0

' If the music signs are found, remove all commas from the selection.

    If ProbableTitle Then
        Do
          p = InStr( TempString$, COMMA )
          If p <> 0 Then TempString$ = Left$( TempString$, p - 1 ) & Mid$( TempString$, p + 1 )
        Loop Until p = 0
    End If

  Else

' Convert the words "-flat" and "-sharp" to music signs for proper searching.

    TempString$ = UCase$( TempString$ )
    Do
      p = InStr( TempString$, "-FLAT" )
      If p > 1 Then
          If Mid$( TempString$, p - 1, 1 ) Like "[A-Ga-g]" Then
              TempString$ = Left$( TempString$, p - 1 ) & MUSIC_FLAT_SIGN & Mid$( TempString$, p + 4 )
          End If
      End If
    Loop Until p = 0

    Do
      p = InStr( TempString$, "-SHARP" )
      If p > 1 Then
          If Mid$( TempString$, p - 1, 1 ) Like "[A-Ga-g]" Then
              TempString$ = Left$( TempString$, p - 1 ) & MUSIC_SHARP_SIGN & Mid$( TempString$, p + 6 )
          End If
      End If
    Loop Until p = 0

End If

FlatSharpFix = TempString$

End Function

'****************************************************************************************

Function InitialArticle( SomeString$ )

' This function checks the input string for an initial article in records for English,
' French, German, Spanish, and Italian resources. If one is found, the string is likely a
' title.

Dim ArticleTest$
Dim TempString$

Dim p As Integer

TempString$ = SomeString$

If Language$ <> "" Then
    p = InStr( TempString$, " " )
    If p <> 0 Then
        ArticleTest$ = Left$( TempString$, p )

        Select Case ArticleTest$

          Case "A ", "AN ", "THE "
            If Language$ = "eng" Or Language$ = "zxx" Then
                TempString$   = Mid$( TempString$, Len( ArticleTest$ ) + 1 )
                ProbableTitle = TRUE
            End If

          Case "DAS ", "DER ", "DIE "
            If Language$ = "ger" Then
                TempString$   = Mid$( TempString$, Len( ArticleTest$ ) + 1 )
                ProbableTitle = TRUE
            End If

          Case "L ", "LE ", "LES ", "UN ", "UNE "
            If Language$ = "fre" Then
                TempString$   = Mid$( TempString$, Len( ArticleTest$ ) + 1 )
                ProbableTitle = TRUE
            End If

          Case "LAS ", "LOS ", "UN ", "UNA "
            If Language$ = "spa" Then
                TempString$   = Mid$( TempString$, Len( ArticleTest$ ) + 1 )
                ProbableTitle = TRUE
            End If

          Case "I ", "IL ", "L ", "LE ", "LO ", "UN ", "UNA ", "UNO "
            If Language$ = "ita" Then
                TempString$   = Mid$( TempString$, Len( ArticleTest$ ) + 1 )
                ProbableTitle = TRUE
            End If

          Case "LA "
            If Language$ = "ita" Or Language$ = "spa" Or Language$ = "fre" Then
                TempString$   = Mid$( TempString$, Len( ArticleTest$ ) + 1 )
                ProbableTitle = TRUE
            End If

        End Select

    End If
End If

InitialArticle = TempString$

End Function

'****************************************************************************************

Function InvertOption( BaseString$ ) As Integer

' This function tests to see if the search string is a candidate for inversion. That is,
' if the string is composed of two or three words, the option will be presented of
' searching with the last word first, as a personal name, or in its original order. The
' function returns the place in the selected string of the last term, or zero if the
' selection can't be inverted (as for a selection of a single word, or of four or more
' words). If the middle word of a three-word string is "de", "du", "le", "St.", "Van",
' or "Von", the inverted option begins with that word.

Const PREFIX_COUNT As Integer = 5

Dim CharT$
Dim CorporateClue%
Dim CountOfStopwords%
Dim FirstSpace%
Dim LastSpace%
Dim MidWord$
Dim TempString$
Dim WordCount%

Dim Hyphen

Dim i As Integer, p As Integer

Dim Prefixes( PREFIX_COUNT )
Prefixes( 0 ) = "DE"
Prefixes( 1 ) = "DU"
Prefixes( 2 ) = "LE"
Prefixes( 3 ) = "ST"
Prefixes( 4 ) = "VAN"
Prefixes( 5 ) = "VON"

Hyphen     = FALSE
LastSpace% = 1

TempString$ = BaseString$

' Count the words.

For i = 1 To Len( TempString$ )
  CharT$ = Mid$( TempString$, i, 1 )
  If WordCount% = 1 Then
      MidWord$ = MidWord$ & CharT$
  End If
  If CharT$ = " " Then
      WordCount% = WordCount% + 1
      If WordCount% = 1 Then
          FirstSpace% = i
      End If
      LastSpace% = i
      If WordCount% = 3 Then
          Exit For
      End If
    ElseIf CharT$ = "-" Then
      WordCount% = WordCount% + 1
      Hyphen     = TRUE
  End If
Next i

WordCount% = WordCount% + 1

' A selection of one word is unflippable. A selection of two words joined by a hyphen is
' also not subject to inversion, probably being a corporate name. If the selection is of
' three words, and the middle one is one of the particles listed above, present the
' inverted form beginning with that middle word, as it is likely a personal name.

Select Case WordCount%

  Case 1
    InvertOption   = 0
    Invertibility% = NOT_INVERTIBLE
    Exit Function

  Case 2
    If Hyphen Then
        InvertOption   = 0
        Invertibility% = NOT_INVERTIBLE
        Exit Function
    End If

  Case 3
    MidWord$ = Trim$( MidWord$ )
    For i = 0 To PREFIX_COUNT
      If MidWord$ = Prefixes( i ) Then
          InvertOption   = FirstSpace%
          Invertibility% = INVERTIBLE_BY_DEFAULT
          Exit Function
      End If
    Next i

End Select

' A selection of two or three words will be presented for browsing in the dialog box in
' two ways--as a personal name, inverted, with the last term first, or in its original
' order, as a corporate body, subject, or title. The form that displays first in the drop
' box depends on whether the string contains any of the stopwords that may indicate a
' corporate body.

If WordCount% = 2 Or WordCount% = 3 Then
    TempString$ = " " & TempString$ & " "
    Do
      p = InStr( TempString$, "-" )
      If p <> 0 Then
          TempString$ = Left$( TempString$, p - 1 ) & " " & Mid$( TempString$, p + 1 )
      End If
    Loop Until p = 0
    FillStopwords
    For i = 0 to STOPWORD_COUNT
      CorporateClue% = InStr( TempString$, Stopwords( i ) )
      If CorporateClue% <> 0 Then
          CountOfStopwords% = CountOfStopwords% + 1
      End If
    Next i
    Select Case CountOfStopwords%

' If the word string contains no stopwords, consider it likely to be a personal name; the
' presence of at least one stopword makes the name likely a corporate body.

      Case 0
        InvertOption   = LastSpace%
        Invertibility% = INVERTIBLE_BY_DEFAULT

      Case Else
        InvertOption   = LastSpace%
        Invertibility% = INVERTIBLE_AS_OPTION

    End Select

' A selection of four or more words is unable to be inverted.

  Else
    InvertOption   = 0
    Invertibility% = NOT_INVERTIBLE
End If

End Function

'****************************************************************************************

Function Normalize( InString$, KeepDelimiter ) As String

' This function uses NACO normalization rules to convert the MARC-21 string into a string
' suitable for browsing the Authority File, omitting and converting some characters.

Const ASCII_DIFF_CASE        As Integer = 32  'The difference between ASCII values of upper and lower case of a letter.
Const ASCII_DIFF_SUBSCRIPT   As Integer = 96  'The difference between ASCII values of subscript and normal numbers.
Const ASCII_DIFF_SUPERSCRIPT As Integer = 80  'The difference between ASCII values of superscript and normal numbers.

Dim CharA%
Dim CharT$
Dim Index%
Dim InStringLength%
Dim TempString$

Dim DelimiterFound           : DelimiterFound = FALSE

Dim p As Integer

InStringLength% = Len( InString$ )
Index%          = 1

Do While Index% <= InStringLength%
  CharT$ = Mid$( InString$, Index%, 1 )
  CharA% = Asc( CharT$ )
  Select Case CharA%

     Case Asc( DASH )
       TempString$ = TempString$ & " -- "

' Numbers and text characters: Include; convert lowercase to uppercase.

    Case 48 to 57, 65 To 90
      TempString$ = TempString$ & CharT$

    Case 97 to 122
      If DelimiterFound Then
          TempString$    = TempString$ & CharT$
          DelimiterFound = FALSE
        Else
          TempString$    = TempString$ & Chr$( CharA% - ASCII_DIFF_CASE )
      End If

' Hyphen: Include if browsing by selection, as it probably indicates a compound surname.
' It will get removed later.

    Case 45
      If TextSelection Then
          TempString$ = TempString$ & CharT$
        Else
          TempString$ = TempString$ & " "
      End If

' Special characters to include:

    Case 35 To 36, 38, 43, 64, 169, 185, 204
      TempString$ = TempString$ & CharT$

' Comma: Convert to blank in a selection. Otherwise, retain commas until constructing the
' search string to browse by field; at that point, discard all commas after the first in
' subfield $a.

    Case 44
      If TextSelection Then
          TempString$ = TempString$ & " "
        Else
          TempString$ = TempString$ & CharT$
      End If

' Characters converted to space:

    Case 32 To 34, 37, 40 To 42, 45, 58 To 63, 92, 94 To 96, 123 To 126, _
         138 To 141, 154 To 158, 167 To 168, 170 To 171, 174, 183, 200 To 203
      TempString$ = TempString$ & " "

' The case of "A." at the beginning of the selection. This is likely an initial, not an
' indefinite article. Mark it so the selection is not considered to be a title, and the
' initial is retained.

    Case 46
      If TextSelection Then
          If TempString$ = "A" Then
              TempString$ = TempString$ & ESC
            Else
              TempString$ = TempString$ & " "
          End If
        Else
          TempString$ = TempString$ & " "
      End If

' Forward slash: In the middle of a selection, surrounded by spaces, assume it is ISBD
' punctuation that separates a title and a statement of responsibility. Use it to define
' those two distinct strings, and then omit it. Otherwise, convert it to a space.

    Case 47
      If TextSelection Then
          If Index% < InStringLength% Then
              If Right$( TempString$, 1 ) = " " And Mid$( InString$, Index% + 1, 1 ) = " " Then
                  TitleString$    = Trim$( TempString$ )
                  NameTitleSplit% = Len( TitleString$ ) + 1
                Else
                  TempString$     = TempString$ & " "
              End If
          End If
        Else
          TempString$ = TempString$ & " "
      End If

' Superscript, subscript numbers: Convert to normal.

    Case 128 to 137
      CharT$      = Chr$( CharA% - ASCII_DIFF_SUPERSCRIPT )
      TempString$ = TempString$ & CharT$

    Case 144 to 153
      CharT$      = Chr$( CharA% - ASCII_DIFF_SUBSCRIPT )
      TempString$ = TempString$ & CharT$

' Special characters: Substitute.

    Case 159
      TempString$ = TempString$ & "SS"
    Case 161, 177, 190
      TempString$ = TempString$ & "L"
    Case 162, 172, 178, 188
      TempString$ = TempString$ & "O"
    Case 163, 179, 186
      TempString$ = TempString$ & "D"
    Case 164, 180
      TempString$ = TempString$ & "TH"
    Case 165, 181
      TempString$ = TempString$ & "AE"
    Case 166, 182
      TempString$ = TempString$ & "OE"
    Case 173, 189
      TempString$ = TempString$ & "U"
    Case 184
      TempString$ = TempString$ & "I"

' Delimiter: If the string is a selection, omit it, along with its accompanying subfield
' code. Also omit it when building a browse string; in that case, replace it with a dash
' if the subfield code indicates a subject subdivision, or replace it with a full stop,
' or period. Otherwise, keep it, to identify subfields to exclude from the search string,
' or to match headings in a search in an expanded browse list.

    Case 223

      If TextSelection Then
          Index% = Index% + 1
        Else
          If KeepDelimiter Then
              TempString$ = TempString$ & CharT$
            Else
              If Index% < InStringLength% Then
                  If Mid$( TempString$, Index% + 1, 1 ) Like "[vxyz]" Then
                      TempString$ = TempString$ & "-- "
                      Index% = Index% + 1
                    Else
                      If Right$( TempString$, 1 ) = " " Then
                          TempString$ = Trim$( TempString$ )
                      End If
'                      TempString$ = TempString$ & "."
                      Index%       = Index% + 1
                  End If
              End If
          End If
      End If

    Case Else

  End Select

  Index% = Index% + 1

Loop

' Remove any introduced double spaces.

Do
  p = InStr( TempString$, "  " )
  If p > 0 Then
      TempString$ = Trim$( Left$( TempString$, p ) ) & " " & Trim$( Mid$( TempString$, p + 1 ) )
  End If
Loop Until p = 0

Normalize = Trim$( TempString$ )

End Function

'****************************************************************************************

Function Plural( Label$, n% ) As String

' Makes the listbox label plural if there is more than one heading in it.

Dim TestString$

If n% = 1 Then
    Plural = Label$
  Else
    TestString$ = Right$( Label$, 4 )
    If TestString$ = "erm:" Or TestString$ = "ing:" Or TestString$ = "hip:" Then
        Plural = Left$( Label$, Len( Label$ ) - 1 ) & "s:"
      Else
        Plural = Label$
    End If
End If

End Function

'****************************************************************************************

Function Dialog2ControlFunction( Id$, Action%, SVal& )

' The function that controls what the dialog box does and doesn't display, depending on
' whether the browse is by selection or by field. For browsing by field, options 1 is
' always visible, with options 2-3 visible depending on what is being browsed; for
' browsing a selection, those options are hidden and the other options are shown.

Const BROWSE_NAME    As Integer = 0
Const BROWSE_SUBJECT As Integer = 1
Const CONTROL_CHANGE As Integer = 2
Const DISABLED       As Integer = 0
Const INVISIBLE      As Integer = 0
Const VISIBLE        As Integer = 1

Select Case Action%

  Case INITIALIZE

' The dialog box opens differently for browsing by selection than for browsing by field.
' The case of a browse on a selection is simpler, as there is only one option (that is,
' only one input box) to display. Whether it is a text box or a combo box depends on the
' number of names in the array.

    If TextSelection And NameTitleType% = NOT_NAME_TITLE Then

' Hide the controls associated with options 1-3.

        DlgVisible      "AlternateBT1",         INVISIBLE
        DlgVisible      "Attention2",           INVISIBLE
        DlgVisible      "DropComboBox2",        INVISIBLE
        DlgVisible      "GroupBox2",            INVISIBLE
        DlgVisible      "GroupBox3",            INVISIBLE
        DlgVisible      "OptionButton1",        INVISIBLE
        DlgVisible      "OptionButton2",        INVISIBLE
        DlgVisible      "OptionButton3",        INVISIBLE
        DlgVisible      "TextBox2",             INVISIBLE

' If the search term consists of a single word, of four or more words, showing an
' inverted form is not an option; display the term in a text box. Otherwise, use the drop
' combo box for the search term. If it contains no stopwords--and thus could be a
' personal name--the first element (what displays by default) is the inverted form.
' However, if it contains at least one stopword, the first element is the form in direct
' order, with the inverted form hidden until selected.

        If Invertibility% = NOT_INVERTIBLE Then
            DlgVisible      "Attention1",           INVISIBLE
            DlgValue        "BrowseType",           NAME_SELECT
            DlgText         "CommitButton",         "&Browse name"
            DlgValue        "DropComboBox1",        0
            DlgVisible      "DropComboBox1",        INVISIBLE
            DlgEnable       "OptionButton5",        DISABLED
            DlgText         "TextBox1",             Names( 0 )
          Else
            DlgText         "Attention1",           "[Select inverted or direct order]"
            DlgValue        "DropComboBox1",        0
            DlgVisible      "TextBox1",             INVISIBLE
            If Invertibility% = INVERTIBLE_AS_OPTION Then
                DlgValue        "BrowseType",           NAME_SELECT
                DlgText         "CommitButton",         "&Browse name"
              Else
                DlgValue        "BrowseType",           NAME_INVERTED
                DlgText         "CommitButton",         "&Browse inverted name"
            End If
        End If

        If ProbableTitle Then
            DlgVisible      "Attention1",           INVISIBLE
            DlgValue        "BrowseType",           TITLE_SELECT
            DlgText         "CommitButton",         "&Browse title"
            DlgValue        "DropComboBox1",        0
        End If

      Else

' For browsing by field, initialize the dialog box by hiding the options for browsing a
' selection.

        DlgVisible      "OptionButton4",        INVISIBLE
        DlgVisible      "OptionButton5",        INVISIBLE
        DlgVisible      "OptionButton6",        INVISIBLE
        DlgVisible      "OptionButton7",        INVISIBLE

        Select Case CountOfSubdivisions%

' The values and visibility of the various controls is determined primarily by the
' contents of the arrays. Adjust these in layers. For the first layer, the number of
' subject subdivisions is the controlling factor. No subdivisions: Hide the controls for
' options 2 and 3. Option 1 must be a name or a title (an undivided subject heading would
' be searched immediately, with no need for the dialog box); controls for that option
' will be set below.

          Case 0
            DlgVisible      "Attention2",           INVISIBLE
            DlgVisible      "DropComboBox2",        INVISIBLE
            DlgVisible      "GroupBox2",            INVISIBLE
            DlgVisible      "GroupBox3",            INVISIBLE
            DlgVisible      "OptionButton2",        INVISIBLE
            DlgVisible      "OptionButton3",        INVISIBLE
            DlgVisible      "TextBox2",             INVISIBLE

' One subdivision: Display all three options, as the browse may be executed on the main
' heading, the subdivision, or both as an expanded browse. Display the text box, rather
' than a combo box, for option 2, as there is only one thing to select. Make option 1 a
' text box also assuming it is a main heading.

          Case 1
            DlgVisible      "Attention2",           INVISIBLE
            DlgVisible      "DropComboBox1",        INVISIBLE
            DlgVisible      "DropComboBox2",        INVISIBLE
            DlgText         "OptionButton1",        "&" & SearchOption1$
            DlgText         "OptionButton2",        "&" & SearchOption2$
            DlgText         "OptionButton3",        "&" & SearchOption3$
            DlgText         "TextBox1",             SubjectString$
            DlgVisible      "TextBox1",             VISIBLE
            DlgText         "TextBox2",             Subdivisions( 0 )
            DlgVisible      "TextBox2",             VISIBLE

' More than one subdivision: As above, but option 2 uses the drop combo box, in order to
' show the contents of the subdivisions array. The reminder to select a string from the
' choices in the array must be made visible also.

          Case Is > 1
            DlgText         "Attention2",           "[Select a subdivision string]"
            DlgVisible      "Attention2",           VISIBLE
            DlgText         "DropComboBox2",        Subdivisions( 0 )
            DlgVisible      "DropComboBox2",        VISIBLE
            DlgText         "OptionButton1",        "&" & SearchOption1$
            DlgText         "OptionButton2",        "&" & SearchOption2$
            DlgText         "OptionButton3",        "&" & SearchOption3$
            DlgText         "TextBox1",             SubjectString$
            DlgVisible      "TextBox1",             VISIBLE
            DlgVisible      "TextBox2",             INVISIBLE
        End Select

' The next layer takes into account the number of names available to search.

        Select Case CountOfNames%

' If there are no names to browse, hide the drop combobox, as the text box must be made
' visible.

          Case 0
            DlgVisible      "DropComboBox1",        INVISIBLE

' One name, one form: Option 1 is a text box.

          Case 1
            DlgVisible      "DropComboBox1",        INVISIBLE
            DlgText         "OptionButton1",        "&" & SearchOption1$
            DlgText         "TextBox1",             Names( 0 )
            DlgVisible      "TextBox1",             VISIBLE

' More than one name (i.e., a corporate body with subordinate units): Option 1 is a drop
' combo box, and the reminder to make a selection from the hierarchy is made visible. If
' TextBox1 has been filled, empty it, or it gets read as the search term when the commit
' button is clicked.

          Case Else
            DlgText         "Attention1",           "[Select a level in the hierarchy]"
            DlgVisible      "Attention1",           VISIBLE
            DlgText         "DropComboBox1",        Names( 0 )
            DlgVisible      "DropComboBox1",        VISIBLE
            DlgText         "OptionButton1",        "&" & SearchOption1$
            DlgVisible      "TextBox1",             INVISIBLE
            DlgText         "TextBox1",             ""

        End Select

' If there is a title portion of the heading to browse, the box for option 2 is a simple
' text box.

        If TitleHeading$ <> "" Then
            DlgVisible      "DropComboBox2",        INVISIBLE
            DlgText         "OptionButton2",        "&" & SearchOption2$
            DlgText         "TextBox2",             TitleHeading$
            DlgVisible      "TextBox2",             VISIBLE
            If NameTitleType% = SELECTION_NAME_TITLE Then
                DlgVisible      "OptionButton1",        INVISIBLE
              Else
                DlgVisible      "OptionButton1",        VISIBLE
            End If
            If Invertibility% = NOT_INVERTIBLE Then
                DlgVisible      "OptionButton5",        INVISIBLE
                DlgVisible      "DropComboBox1",        INVISIBLE
                DlgText         "TextBox1",             Names( 0 )
                DlgVisible      "TextBox1",             VISIBLE
              Else
                DlgVisible      "OptionButton5",        VISIBLE
                DlgVisible      "DropComboBox1",        VISIBLE
                DlgText         "DropComboBox1",        Names( 1 )
                DlgVisible      "TextBox1",             INVISIBLE
                DlgText         "TextBox1",             ""
            End If
        End If

' The final layer is based on whether option 2 is available. If not, the browse is on the
' levels of a hierarchy of a corporate body, and there is no need for a radio button, as
' the only selection to be made is in the drop combo box, to choose which level of the
' hierarchy to browse.

        If TitleHeading$ <> "" Or CountOfSubdivisions% > 0 Then
            DlgVisible      "AlternateBT1",         INVISIBLE
            DlgText         "CommitButton",         "&Browse " & LCase( Left$( SearchOption1$, 1 ) ) & Mid$( SearchOption1$, 2 )
            DlgVisible      "GroupBox2",            VISIBLE
            DlgVisible      "GroupBox3",            VISIBLE
            If NameTitleType% = SELECTION_NAME_TITLE Then
                DlgVisible      "OptionButton4",        VISIBLE
              Else
                DlgVisible      "OptionButton4",        INVISIBLE
            End If
            DlgVisible      "OptionButton2",        VISIBLE
            DlgVisible      "OptionButton3",        VISIBLE
            DlgText         "OptionButton2",        "&" & SearchOption2$
            DlgText         "OptionButton3",        "&" & SearchOption3$
          Else
            DlgVisible      "AlternateBT1",         VISIBLE
            DlgText         "AlternateBT1",         "&" & SearchOption1$
            DlgText         "CommitButton",         "&Browse " & LCase( Left$( SearchOption1$, 1 ) ) & Mid$( SearchOption1$, 2 )
            DlgVisible      "GroupBox2",            INVISIBLE
            DlgVisible      "GroupBox3",            INVISIBLE
            DlgVisible      "OptionButton1",        INVISIBLE
        End If

' If a uniform title appears as option 2, it will be the default search if the cursor was
' in a 240 field when the macro was invoked; otherwise, the default search will be a
' name/title expanded browse.

        If NameTitleSplit% = CURSOR_IN_240 Then
            DlgValue        "BrowseType",           BROWSE_SUBJECT
            DlgText         "CommitButton",         "&Browse title heading"
          ElseIf NameTitleSplit% <> 0 Then
            DlgValue        "BrowseType",           2
            DlgText         "CommitButton",         "&Expanded browse"
        End If
    End If

  Case CONTROL_CHANGE

    Select Case Id$

' If the selections in the drop combo boxes change, change the selection of the radio
' buttons to match.

      Case "DropComboBox1"
        If TextSelection = FALSE Then
            DlgValue        "BrowseType",           BROWSE_NAME
          Else
            If DlgValue( "DropComboBox1" ) = 0 Then
                If Invertibility% = INVERTIBLE_AS_OPTION Then
                    DlgValue        "BrowseType",           NAME_SELECT
                    DlgText         "CommitButton",         "&Browse name"
                  Else
                    DlgValue        "BrowseType",           NAME_INVERTED
                    DlgText         "CommitButton",         "&Browse inverted name"
                End If
              Else
                If Invertibility% = INVERTIBLE_AS_OPTION Then
                    DlgValue        "BrowseType",           NAME_INVERTED
                    DlgText         "CommitButton",         "&Browse inverted name"
                  Else
                    DlgValue        "BrowseType",           NAME_SELECT
                    DlgText         "CommitButton",         "&Browse name"
                End If
            End If
        End If

      Case "DropComboBox2"
        If TextSelection = FALSE Then
            DlgValue        "BrowseType",           BROWSE_SUBJECT
            DlgText         "CommitButton",         "&Browse subject subdivision"
        End If

' When the radio buttons are selected, change the wording on the Commit Button, and the
' form of the name shown in the drop combo box, to follow suit.

      Case "OptionButton1"
        DlgValue        "BrowseType",           BROWSE_NAME
        DlgText         "CommitButton",         "&Browse " & LCase( Left$( SearchOption1$, 1 ) ) & Mid$( SearchOption1$, 2 )

      Case "OptionButton2"
        DlgValue        "BrowseType",           BROWSE_SUBJECT
        DlgText         "CommitButton",         "&Browse " & LCase( Left$( SearchOption2$, 1 ) ) & Mid$( SearchOption2$, 2 )

      Case "OptionButton3"
        DlgText         "CommitButton",         "&Expanded browse"

      Case "OptionButton4"
        DlgText         "CommitButton",         "&Browse name"
        If Invertibility% = INVERTIBLE_AS_OPTION Then
            DlgValue        "DropComboBox1",        0
          ElseIf Invertibility% = INVERTIBLE_BY_DEFAULT Then
            DlgValue        "DropComboBox1",        1
        End If

      Case "OptionButton5"
        DlgText         "CommitButton",         "&Browse inverted name"
        If Invertibility% = INVERTIBLE_AS_OPTION Then
            DlgValue        "DropComboBox1",        1
          ElseIf Invertibility% = INVERTIBLE_BY_DEFAULT Then
            DlgValue        "DropComboBox1",        0
        End If

      Case "OptionButton6"
        DlgText         "CommitButton",         "&Browse subject"
        If Invertibility% = INVERTIBLE_AS_OPTION Then
            DlgValue        "DropComboBox1",        0
          ElseIf Invertibility% = INVERTIBLE_BY_DEFAULT Then
            DlgValue        "DropComboBox1",        1
        End If

      Case "OptionButton7"
        DlgText         "CommitButton",         "&Browse title"
        If Invertibility% = INVERTIBLE_AS_OPTION Then
            DlgValue        "DropComboBox1",        0
          ElseIf Invertibility% = INVERTIBLE_BY_DEFAULT Then
            DlgValue        "DropComboBox1",        1
        End If

    End Select


  Case FOCUS_CHANGE

' Clicking in a text box, perhaps to edit the search term, must also select the
' corresponding radio button, so the Commit Button text needs to change accordingly.

    Select Case Id$

      Case "DropComboBox1", "TextBox1"
        If TextSelection = FALSE Then
            DlgValue        "BrowseType",           BROWSE_NAME
            DlgText         "CommitButton",         "&Browse " & LCase$( Left$( SearchOption1$, 1 ) ) & Mid$( SearchOption1$, 2 )
        End If

      Case "DropComboBox2", "TextBox2"
        If TextSelection = FALSE Then
            DlgValue        "BrowseType",           BROWSE_SUBJECT
            DlgText         "CommitButton",         "&Browse " & LCase$( Left$( SearchOption2$, 1 ) ) & Mid$( SearchOption2$, 2 )
        End If

    End Select

End Select

End Function

'****************************************************************************************

Function Dialog3_1_ListBoxControlFunction( Id$, Action%, SVal& )

' Controls a dialog box containing one list box, for either the headings referred to or
' one kind of 5XX field.

Select Case Action%

  Case INITIALIZE

    If Left$( BaseHeading$, 2 ) = "18" Then
        DlgText         "EstablishedHeading",   "-- " & Mid$( BaseHeading$, 4 )
      Else
        DlgText         "EstablishedHeading",   Mid$( BaseHeading$, 4 )
    End If
    If CountOfReferredTo% = 0 Then
        DlgText         "OptionButtonListBox1", "&2  Retrieve authority record (" & Display5XX_1Label$
        DlgListBoxArray "ListBox1",             Display5XX_1()
      Else
        DlgText         "OptionButtonListBox1", "&2  " & BrowseRefs$
        DlgListBoxArray "ListBox1",             DisplayRefs()
    End If

  Case FOCUS_CHANGE

    Select Case Id$

      Case "EstablishedHeading"
        DlgValue        "OptionGroup",          0
        DlgValue        "ListBox1",             NO_SELECTION
      Case "ListBox1"
        DlgValue        "OptionGroup",          1
      Case "OptionButtonHeading"
        DlgValue        "OptionGroup",          0
        DlgValue        "ListBox1",             NO_SELECTION
      Case "OptionButtonListBox1"
        DlgValue        "OptionGroup",          1
        DlgValue        "ListBox1",             0
        DlgFocus        "ListBox1"

    End Select

End Select

End Function

'****************************************************************************************

Function Dialog3_2_ListBoxesControlFunction( Id$, Action%, SVal& )

' Controls a dialog box containing two list boxes, for either the headings referred to
' and one type of 5XX field, or two types of 5XX fields and no headings referred to.

Select Case Action%

  Case INITIALIZE

    If Left$( BaseHeading$, 2 ) = "18" Then
        DlgText         "EstablishedHeading",   "-- " & Mid$( BaseHeading$, 4 )
      Else
        DlgText         "EstablishedHeading",   Mid$( BaseHeading$, 4 )
    End If
    If CountOfReferredTo% = 0 Then
        DlgText         "OptionButtonListBox1", "&2  Retrieve authority record (" & Display5XX_1Label$
        DlgText         "OptionButtonListBox2", "&3  Retrieve authority record (" & Display5XX_2Label$
        DlgListBoxArray "ListBox1",             Display5XX_1()
        DlgListBoxArray "ListBox2",             Display5XX_2()
      Else
        DlgText         "OptionButtonListBox1", "&2  " & BrowseRefs$
        DlgText         "OptionButtonListBox2", "&3  Retrieve authority record (" & Display5XX_1Label$
        DlgListBoxArray "ListBox1",             DisplayRefs()
        DlgListBoxArray "ListBox2",             Display5XX_1()
    End If


  Case FOCUS_CHANGE

    Select Case Id$

      Case "EstablishedHeading"
        DlgValue        "OptionGroup",          0
        DlgValue        "ListBox1",             NO_SELECTION
        DlgValue        "ListBox2",             NO_SELECTION
      Case "ListBox1"
        DlgValue        "OptionGroup",          1
        DlgValue        "ListBox2",             NO_SELECTION
      Case "ListBox2"
        DlgValue        "OptionGroup",          2
        DlgValue        "ListBox1",             NO_SELECTION
      Case "OptionButtonListBox1"
        DlgValue        "OptionGroup",          1
        DlgValue        "ListBox2",             NO_SELECTION
        DlgValue        "ListBox1",             0
        DlgFocus        "ListBox1"
      Case "OptionButtonListBox2"
        DlgValue        "OptionGroup",          2
        DlgValue        "ListBox1",             NO_SELECTION
        DlgValue        "ListBox2",             0
        DlgFocus        "ListBox2"

    End Select

End Select

End Function

'****************************************************************************************

Function Dialog3_3_ListBoxesControlFunction( Id$, Action%, SVal& )

' Controls a dialog box containing three list boxes, for either the headings referred to
' and two types of 5XX fields, or three types of 5XX fields and no headings referred to.

Select Case Action%

  Case INITIALIZE

    If Left$( BaseHeading$, 2 ) = "18" Then
        DlgText         "EstablishedHeading",   "-- " & Mid$( BaseHeading$, 4 )
      Else
        DlgText         "EstablishedHeading",   Mid$( BaseHeading$, 4 )
    End If
    If CountOfReferredTo% = 0 Then
        DlgText         "OptionButtonListBox1", "&2  Retrieve authority record (" & Display5XX_1Label$
        DlgText         "OptionButtonListBox2", "&3  Retrieve authority record (" & Display5XX_2Label$
        DlgText         "OptionButtonListBox3", "&4  Retrieve authority record (" & Display5XX_3Label$
        DlgListBoxArray "ListBox1",             Display5XX_1()
        DlgListBoxArray "ListBox2",             Display5XX_2()
        DlgListBoxArray "ListBox3",             Display5XX_3()
      Else
        DlgText         "OptionButtonListBox1", "&2  " & BrowseRefs$
        DlgText         "OptionButtonListBox2", "&3  Retrieve authority record (" & Display5XX_1Label$
        DlgText         "OptionButtonListBox3", "&4  Retrieve authority record (" & Display5XX_2Label$
        DlgListBoxArray "ListBox1",             DisplayRefs()
        DlgListBoxArray "ListBox2",             Display5XX_1()
        DlgListBoxArray "ListBox3",             Display5XX_2()
    End If


  Case FOCUS_CHANGE

    Select Case Id$

      Case "EstablishedHeading"
        DlgValue        "OptionGroup",          0
        DlgValue        "ListBox1",             NO_SELECTION
        DlgValue        "ListBox2",             NO_SELECTION
        DlgValue        "ListBox3",             NO_SELECTION
      Case "ListBox1"
        DlgValue        "OptionGroup",          1
        DlgValue        "ListBox2",             NO_SELECTION
        DlgValue        "ListBox3",             NO_SELECTION
      Case "ListBox2"
        DlgValue        "OptionGroup",          2
        DlgValue        "ListBox1",             NO_SELECTION
        DlgValue        "ListBox3",             NO_SELECTION
      Case "ListBox3"
        DlgValue        "OptionGroup",          3
        DlgValue        "ListBox1",             NO_SELECTION
        DlgValue        "ListBox2",             NO_SELECTION
      Case "OptionButtonHeading"
        DlgValue        "OptionGroup",          0
        DlgValue        "ListBox1",             NO_SELECTION
        DlgValue        "ListBox2",             NO_SELECTION
        DlgValue        "ListBox3",             NO_SELECTION
      Case "OptionButtonListBox1"
        DlgValue        "OptionGroup",          1
        DlgValue        "ListBox2",             NO_SELECTION
        DlgValue        "ListBox3",             NO_SELECTION
        DlgValue        "ListBox1",             0
        DlgFocus        "ListBox1"
      Case "OptionButtonListBox2"
        DlgValue        "OptionGroup",          2
        DlgValue        "ListBox1",             NO_SELECTION
        DlgValue        "ListBox3",             NO_SELECTION
        DlgValue        "ListBox2",             0
        DlgFocus        "ListBox2"
      Case "OptionButtonListBox3"
        DlgValue        "OptionGroup",          3
        DlgValue        "ListBox1",             NO_SELECTION
        DlgValue        "ListBox2",             NO_SELECTION
        DlgValue        "ListBox3",             0
        DlgFocus        "ListBox3"

    End Select

End Select

End Function

'****************************************************************************************

Function Dialog3_4_ListBoxesControlFunction( Id$, Action%, SVal& )

' Controls a dialog box containing four list boxes, for headings referred to and three
' types of 5XX fields.

Select Case Action%

  Case INITIALIZE

    If Left$( BaseHeading$, 2 ) = "18" Then
        DlgText         "EstablishedHeading",   "-- " & Mid$( BaseHeading$, 4 )
      Else
        DlgText         "EstablishedHeading",   Mid$( BaseHeading$, 4 )
    End If
    DlgText         "OptionButtonListBox1", "&2  " & BrowseRefs$
    DlgText         "OptionButtonListBox2", "&3  Retrieve authority record (" & Display5XX_1Label$
    DlgText         "OptionButtonListBox3", "&4  Retrieve authority record (" & Display5XX_2Label$
    DlgText         "OptionButtonListBox4", "&5  Retrieve authority record (" & Display5XX_3Label$
    DlgListBoxArray "ListBox1",             DisplayRefs()
    DlgListBoxArray "ListBox2",             Display5XX_1()
    DlgListBoxArray "ListBox3",             Display5XX_2()
    DlgListBoxArray "ListBox4",             Display5XX_3()


  Case FOCUS_CHANGE

    Select Case Id$

      Case "EstablishedHeading"
        DlgValue        "OptionGroup",          0
        DlgValue        "ListBox1",             NO_SELECTION
        DlgValue        "ListBox2",             NO_SELECTION
        DlgValue        "ListBox3",             NO_SELECTION
        DlgValue        "ListBox4",             NO_SELECTION
      Case "ListBox1"
        DlgValue        "OptionGroup",          1
        DlgValue        "ListBox2",             NO_SELECTION
        DlgValue        "ListBox3",             NO_SELECTION
        DlgValue        "ListBox4",             NO_SELECTION
      Case "ListBox2"
        DlgValue        "OptionGroup",          2
        DlgValue        "ListBox1",             NO_SELECTION
        DlgValue        "ListBox3",             NO_SELECTION
        DlgValue        "ListBox4",             NO_SELECTION
      Case "ListBox3"
        DlgValue        "OptionGroup",          3
        DlgValue        "ListBox1",             NO_SELECTION
        DlgValue        "ListBox2",             NO_SELECTION
        DlgValue        "ListBox4",             NO_SELECTION
      Case "ListBox4"
        DlgValue        "OptionGroup",          4
        DlgValue        "ListBox1",             NO_SELECTION
        DlgValue        "ListBox2",             NO_SELECTION
        DlgValue        "ListBox3",             NO_SELECTION
      Case "OptionButtonHeading"
        DlgValue        "OptionGroup",          0
        DlgValue        "ListBox1",             NO_SELECTION
        DlgValue        "ListBox2",             NO_SELECTION
        DlgValue        "ListBox3",             NO_SELECTION
        DlgValue        "ListBox4",             NO_SELECTION
      Case "OptionButtonListBox1"
        DlgValue        "ListBox2",             NO_SELECTION
        DlgValue        "ListBox3",             NO_SELECTION
        DlgValue        "ListBox4",             NO_SELECTION
        DlgValue        "ListBox1",             0
        DlgFocus        "ListBox1"
      Case "OptionButtonListBox2"
        DlgValue        "ListBox1",             NO_SELECTION
        DlgValue        "ListBox3",             NO_SELECTION
        DlgValue        "ListBox4",             NO_SELECTION
        DlgValue        "ListBox2",             0
        DlgFocus        "ListBox2"
      Case "OptionButtonListBox3"
        DlgValue        "ListBox1",             NO_SELECTION
        DlgValue        "ListBox2",             NO_SELECTION
        DlgValue        "ListBox4",             NO_SELECTION
        DlgValue        "ListBox3",             0
        DlgFocus        "ListBox3"
      Case "OptionButtonListBox4"
        DlgValue        "ListBox1",             NO_SELECTION
        DlgValue        "ListBox2",             NO_SELECTION
        DlgValue        "ListBox3",             NO_SELECTION
        DlgValue        "ListBox4",             0
        DlgFocus        "ListBox4"

    End Select

End Select

End Function
'4109162441
