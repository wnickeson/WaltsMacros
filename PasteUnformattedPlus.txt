' MacroName:PasteUnformattedPlus.2025.03
' MacroDescription:Removes formatting from text placed on the Windows Clipboard for
' pasting into a bibliographic record. Allows adding a multi-line copied string to the
' record as a simple string or as one or more new fields.
'
' This macro was written by Walter F. Nickeson and last updated 2 May 2025.
' It was developed in Connexion client 3.1 running in Windows 11 Enterprise and 64-bit
' Windows 10 Pro.
' Walt's macros for the Connexion client: https://github.com/wnickeson/WaltsMacros
' wfnickeson@zohomail.com
'
' Copyright 2025 Walter F. Nickeson.
'
' Permission is hereby granted, free of charge, to any person obtaining a copy of this
' software and associated documentation files (the "Software"), to deal in the Software
' without restriction, including without limitation the rights to use, copy, modify,
' merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
' permit persons to whom the Software is furnished to do so, subject to the following
' conditions:
'
' The above copyright notice and this permission notice shall be included in all copies
' or substantial portions of the Software.
'
' THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
' INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
' PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
' HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
' CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
' THE USE OR OTHER DEALINGS IN THE SOFTWARE.
'
'****************************************************************************************
' How it works: Use this macro to paste text copied to the Windows Clipboard from outside
' Connexion into a Connexion bibliographic record, with some formatting removed and some
' special characters converted into simple ASCII characters. The text may be copied from
' the Web (as from a MARC record display), a document produced by a word processor,
' MarcEdit's editor, and other sources. In the bibliographic record, if the copied
' material is to be inserted into a field, place the cursor at the appropriate position,
' and run the macro. Or, if several lines have been copied, they can be added as one or
' more new fields to the record; in that case, cursor position is irrelevant.
'
' Specifically, this macro:
'  + Collapses white space, by deleting consecutive space characters (of any width),
'    tabs, and line breaks. Single line breaks may be changed to either spaces or dashes,
'    or they may be retained, in order to paste in the copied text as multiple new
'    fields.
'  + Changes proper quotation marks (also known as "curly," "smart," or "typographical"
'    quotes) into simple straight, vertical slashes.
'  + Converts em dashes and horizontal bars to double hyphens and all other dashes to
'    single hyphens (precisely, the "hyphen-minus" character).
'  + Expands an ellipsis character into three dots with a space preceding and following.
'  + Combines two single quotation marks (including the spacing grave accent (`) used as
'    a quotation mark) into one double quotation mark.
'  + Separates the typographical ligatures based on "f" ("f" combined with "i", "f", and
'    "l"), as well as some other ligatures.
'  + Replaces the modifier letters right and left half rings, representing the alif and
'    ayn characters, respectively, with the modifier letters turned comma and apostrophe,
'    following OCLC guidelines.
'
' In text copied from MARC or staff views in an online catalog, the macro:
'  + Converts the underscore, backslash, and sharp sign representations of blank
'    indicator values to actual blank spaces.
'  + Attempts to change delimiter characters, such as the dollar sign or pipe character,
'    into the standard OCLC delimiter character (the "alveolar click," or, formerly, the
'    "double-barred pipe").
'
' Also removed by this macro: The characteristic formatting from fields copied from
' MarcEdit's editor, except that mnemonics in braces are retained. An exception to the
' exception is that the mnemonic "{dollar}" is changed to the dollar character.
'
' Fullwidth and halfwidth characters (U+FF01--U+FFEE) are not changed, even though OCLC
' prefers that they be replaced by the corresponding ordinary width characters.
'
' Data retrieved from the Windows Clipboard has already had its character formatting
' removed, such as font, color, bold and italic, and so on. Information pasted into a
' record is strictly Unicode text.
'
' Because different online catalogs display MARC records in different ways, indicator
' placement in the copied lines from an OPAC MARC view may be incorrect. This is likely
' to be the case when the display doesn't distinguish between an indicator value of
' "blank" and a space character. And because the macro expects indicators to be present,
' copying 00X fields will probably be unsuccessful (not to mention that HTML condenses
' whitespace, which renders a 008 field copied from a web source, for example,
' unreadable). Often manual cleanup will be required after pasting such copied material
' into the record as multiple fields.
'
' When the macro runs, it presents a dialog box showing the options for adding the text
' to the record. The deformatted text can be inserted into an existing field at the
' cursor position as a simple string, or it can be added as one or more new fields. When
' new fields are to be added, the dialog box presents you with the option of supplying a
' tag and indicators, which will apply to all those fields. Lines copied from a MARC
' record that already begin with the three digits of a tag may be pasted just as copied,
' except that the macro will still remove formatting from the content of the field(s).
' All new fields are inserted into the record by means of the OML "AddField" command,
' which places new fields in the record according to their tag. If no tag is detected in
' the copied text or supplied in the dialog box, the macro will add the fields
' immediately following the row in which the cursor is placed, just as they were copied
' (minus formatting). Not entering anything in the dialog box for an indicator is the
' same as entering a blank space. The dialog box includes a preview of the copied,
' modified text, but because of the limitations of OML, the preview can only display
' Latin alphabet characters, and not even all the ones available. Delimiters are shown as
' dollar signs, but they will appear correctly when pasted into the record.
'
' A line break in the copied text may be represented by different characters--typically,
' the carriage return (decimal character 13), the line feed (decimal 10), or the two
' together. Use of both characters is standard in Windows, but the Client requires only
' the carriage return to create a new field. Therefore, the macro converts any line break
' to a single carriage return character for ease of manipulation. After that, the macro
' can change the line breaks to either spaces or dashes (space-hyphen-hyphen-space, as
' used in contents notes). Or the line breaks can be retained, in order to paste the
' copied text in as new fields. (However, blank or empty lines are removed as part of the
' process of cleaning up whitespace.) The dialog box is how you choose to treat all line
' breaks.
'
' The delimiter character in MARC21 is decimal 31, the "unit separator." As a non-
' printing character, it must be represented on the screen by visible characters. Common
' representations include the pipe (decimal 124), double dagger (decimal 135), and dollar
' characters. The macro considers them all to be potential delimiters, as well as two
' consecutive dollar signs, and even the question mark, which is how the Connexion
' delimiter appears when pasted from the Clipboard into a plain text context. If the
' copied text contains such a character (or characters, in the case of the double dollar
' common in the Alma environment) which is followed by a lowercase alphanumeric character
' or a digit, and then a space, the macro will treat it as a delimiter and convert it to
' the standard Connexion alveolar click glyph. If the macro does not properly recognize a
' delimiter, such as if spacing around it is not present, the results may be unexpected.
' An initial "$a" in a field will show up in the dialog box, but won't be added to the
' record, and Connexion will eliminate it anyway with the Reformat command.
'
' The OML "Copy" and "Paste" commands don't seem to work, so this macro copies existing
' fields to the Clipboard with the "CopyField" command. OML is also unable to retrieve
' Unicode information from the Clipboard, so the macro uses Windows API functions to
' access that information. If a string is to be inserted into a field, the field is
' actually replaced with the "SetField" command. New fields are added with the "AddField"
' command.
'
' The Client has a built-in "Paste Unformatted" menu command (created after I had
' developed my original macro of the same name) which simply removes white space.
'
' To convert precomposed characters (usually those with diacritics), use my macro
' "Decompose," which replaces, a field at a time, all Latin-1/Unicode single-character
' letter + diacritic combinations with the proper sequence of separate letters followed
' by diacritics.
'
' References to the Unicode standard are to version 16.0, published 10 September 2024.
'****************************************************************************************

Option Explicit

Declare Sub FillCombinedArray
Declare Sub FillDisplaySubArray
Declare Sub FillUnicodeSubArray
Declare Sub InitialDialogSetup( OptionButtonChoice% )

Declare Function GetIndicator    ( WhichIndicator$ )                     As String
Declare Function GetUnicodeString()                                      As String
Declare Function MakeDisplayable ( InString$ )                           As String
Declare Function Replace         ( InputString$, Replacement$, Remove$ ) As String

Declare Function Dialog1ControlFunction( Id$, Action%, SValue& )

'----------------------------------------------------------------------------------------
' The following routines declare procedures in the .dll files for retrieving data from
' the Windows Clipboard. Initial guidance on use of this technique is due to Joel Hahn.

Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" ( DestinationPointer As Any, _
                                                              SourcePointer As Any, _
                                                              ByVal SizeOfCopy As Long)

Declare Function CloseClipboard   Lib "user32"   Alias "CloseClipboard" () As Long
Declare Function GetActiveWindow  Lib "user32"   Alias "GetActiveWindow" () As Long
Declare Function GetClipboardData Lib "user32"   Alias "GetClipboardData" ( ByVal ClipboardFormat As Long ) As Long
Declare Function GetStringLength  Lib "kernel32" Alias "lstrlenW" ( ByVal StringLength As Long ) As Long
Declare Function GlobalAlloc      Lib "kernel32" ( ByVal wFlags As Long, ByVal dwBytes As Long ) As Long
Declare Function GlobalLock       Lib "kernel32" Alias "GlobalLock" ( ByVal MemoryHandle As Long ) As Long
Declare Function GlobalUnlock     Lib "kernel32" Alias "GlobalUnlock" ( ByVal MemoryHandle As Long ) As Long
Declare Function OpenClipboard    Lib "user32"   Alias "OpenClipboard" ( ByVal WindowHandle As Long ) As Long
'----------------------------------------------------------------------------------------

Global Const DISABLED         As Integer = 0
Global Const ENABLED          As Integer = 1

Global Const aDASH            As Integer = 1
Global Const aMULTI_FIELDS    As Integer = 1
Global Const aNO_CR           As Integer = 0
Global Const aSINGLE_FIELD    As Integer = 0
Global Const aSPACE           As Integer = 0
Global Const DISPLAY_SUB_SIZE As Integer = 570
Global Const ISO_CHAR         As Integer = 1
Global Const MULTI_FIELDS     As Integer = 2
Global Const SIMPLE_STRING    As Integer = 0
Global Const SINGLE_FIELD     As Integer = 1
Global Const UNI_CHAR         As Integer = 0
Global Const UNI_CHAR_TEXT    As Long    = 13&
Global Const UNI_SUB_SIZE     As Integer = 61

Global BLANK_TAG_INDICATORS   As String*5
Global CLIPBOARD_ERROR        As String*1
Global CR                     As String*1
Global DOLLAR_DELIMITER       As String*1
Global DOUBLE_QUOTE           As String*1
Global SINGLE_QUOTE           As String*1
Global TWO_SPACES             As String*2
Global UNI_DELIMITER          As String*8

Global ACUTE                  As String*8
Global CARON                  As String*8
Global CEDILLA                As String*8
Global CIRCUMFLEX             As String*8
Global DIAERESIS              As String*8
Global GRAVE                  As String*8
Global RING_ABOVE             As String*8
Global TILDE                  As String*8

Global CursorPosition%
Global DefaultAddFieldOption%
Global PreviewString$
Global SpaceOrDash%

Global BlankTag
Global CRFound
Global TaggedFieldsLikely

Global Combined  ( 52 )               As String
Global DisplaySub( DISPLAY_SUB_SIZE ) As String
Global FieldStore()                   As String
Global UnicodeSub( UNI_SUB_SIZE )     As String
'****************************************************************************************

Sub Main

PreviewString$ = ""

Dim CS As Object
On Error Resume Next
Set CS = GetObject( , "Connex.Client" )
On Error GoTo 0
If CS Is Nothing Then Set CS = CreateObject( "Connex.Client" )

Const CRITICAL_MESSAGE     As Integer = 16
Const DLG_STATEMENT_CANCEL As Integer = 102

Const CR_CHAR              As Integer = 13
Const DBL_DAGGER_CHAR      As Integer = 135
Const DOLLAR_CHAR          As Integer = 36
Const LF_CHAR              As Integer = 10
Const PIPE_CHAR            As Integer = 124
Const QUESTION_CHAR        As Integer = 63
Const NCR                  As Integer = -1

Dim BLANK_TAG_FLAG         As String*1
Dim CR_SPACE_AFTER         As String*2
Dim CR_SPACE_BEFORE        As String*2
Dim TWO_CRs                As String*2
Dim TWO_SINGLE_QUOTES      As String*2

Dim AddFieldFailure%
Dim ArrayDimension%
Dim CharA%
Dim Character$
Dim CharCount%
Dim CharT$
Dim ConvertedToDash$
Dim ConvertedToSpace$
Dim CRsNotConverted$
Dim CurrentField$
Dim CurrentFieldLength%
Dim DeformattedString$
Dim Indicator1$
Dim Indicator2$
Dim IndicatorString$
Dim InsertionPoint%
Dim NextChar$
Dim PotentialFields%
Dim PrevChar$
Dim RawString$
Dim Row%
Dim Start%
Dim Tag$
Dim TaggedFields%
Dim TagTest$
Dim TempField$
Dim TempString$
Dim TypeOfWindow%
Dim WaltsMacros$
Dim WorkString$

Dim DelimFound               : DelimFound        = FALSE
Dim MarcEdit                 : MarcEdit          = FALSE
Dim PossibleMARCField        : PossibleMARCField = FALSE
Dim TagFound

Dim i As Integer, j As Integer, p As Integer

BLANK_TAG_FLAG       = Chr$( 009 )
BLANK_TAG_INDICATORS = "     "
CLIPBOARD_ERROR      = Chr$( 021 )
CR                   = Chr$( 013 )
CR_SPACE_AFTER       = CR & " "
CR_SPACE_BEFORE      = " " & CR
DOLLAR_DELIMITER     = "$"
DOUBLE_QUOTE         = Chr$( 034 )
SINGLE_QUOTE         = Chr$( 039 )
TWO_CRs              = CR & CR
TWO_SINGLE_QUOTES    = SINGLE_QUOTE & SINGLE_QUOTE
TWO_SPACES           = "  "
UNI_DELIMITER        = "&#x01C2;"
WaltsMacros$         = "[Walt's macros] Essentials:PasteUnformattedPlus"

ACUTE                = "&#x0301;"
CARON                = "&#x030C;"
CEDILLA              = "&#x0327;"
CIRCUMFLEX           = "&#x0302;"
DIAERESIS            = "&#x0308;"
GRAVE                = "&#x0300;"
RING_ABOVE           = "&#x030A;"
TILDE                = "&#x0303;"

BlankTag             = FALSE
CRFound              = FALSE

' First, make sure a bibliographic record is available for the copied data to be pasted
' into.

TypeOfWindow% = CS.ItemType
Select Case TypeOfWindow%
  Case -1, 3 To 16, 18, 20 To 26
    MsgBox "Sorry, this macro works only when a bibliographic record is available to paste the copied text into.", CRITICAL_MESSAGE, WaltsMacros$
    Exit Sub
End Select

' Get Unicode data from the Clipboard.

RawString$ = GetUnicodeString

If Left$( RawString$, 1 ) = CLIPBOARD_ERROR Then
    MsgBox( Mid$( RawString$, 2 ) ), CRITICAL_MESSAGE, WaltsMacros$
    Exit Sub
End If

' If there is text on the Clipboard, and a record to paste it into, the next step is to
' get the cursor position, and then the Unicode data from the field the cursor is in.

Row%                = CS.CursorRow
CursorPosition%     = CS.CursorColumn
CS.CopyField
CurrentField$       = GetUnicodeString
CurrentFieldLength% = Len( CurrentField$ )

' The "CopyField" command retrieves the string as Unicode, so delimiter signs and other
' characters are represented by Numeric Character References, or NCRs. The actual
' position of the cursor in the field, in case the copied material is to be inserted
' there, has to be determined by counting characters in the NCRs, rather than just the
' displayed characters.

i = 6
Do
  CharT$ = Mid$( CurrentField$, i, 1 )
  If CharT$ = "&" Then
      If Mid$( CurrentField$, i, 3 ) = "&#x" Then
          p = InStr( i + 1, CurrentField$, ";" )
          If ( p - i ) < 10 Then
              i = p
              CharCount% = CharCount% + 1
          End If
      End If
    Else
      CharCount% = CharCount% + 1
  End If
  i = i + 1
Loop Until CharCount% >= CursorPosition% - 6
InsertionPoint% = i

' Turn back to the copied string and start the de-formatting process. The first step is
' to remove extraneous spaces and carriage return/line feeds (and any other non-printing
' characters, that is, characters with ASCII values below 32) from the beginning and end
' of the string.

For i = 1 To Len( RawString$ )
  CharT$ = Mid$( RawString$, i, 1 )
  CharA% = Asc( CharT$ )
  If CharA% > 31 Then
      RawString$ = Mid$( RawString$, i )
      Exit For
  End If
Next i

For i = Len( RawString$ ) To 1 Step -1
  CharT$ = Mid$( RawString$, i, 1 )
  CharA% = Asc( CharT$ )
  If CharA% > 31 Then
      RawString$ = Left$( RawString$, i )
      Exit For
  End If
Next i

' Fill the arrays used to substitute characters.

FillDisplaySubArray
FillUnicodeSubArray
FillCombinedArray

' Go through the text on the Clipboard, substituting plain text, or ASCII, characters for
' some characters chiefly in the Unicode General Punctuation and Alphabetic Presentation
' Forms blocks. This is a preliminary go-through, mostly to get rid of extra white space
' and help make a nice display in the dialog box. The string must be gone through again
' when pasting the text in as a new field. If an NCR  is found, consider that string to
' be the character.

For i = 1 To Len( RawString$ )
  CharT$ = Mid$( RawString$, i, 1 )
  If CharT$ = "&" Then
      If Mid$( RawString$, i, 3 ) = "&#x" Then
          p      = InStr( i + 1, RawString$, ";" )
          CharT$ = Mid$( RawString$, i, p - i + 1 )
          For j = 0 To UNI_SUB_SIZE
            If Mid$( CharT$, 4, 4 ) = Left$( UnicodeSub( j ), 4 ) Then
                CharT$ = Mid$( UnicodeSub( j ), 5 )
                Exit For
            End If
          Next j
          i      = p
          CharA% = NCR
      End If
    Else
      CharA% = Asc( CharT$ )
  End If
  If i < Len( RawString$ ) Then
      NextChar$ = Mid$( RawString$, i + 1, 1 )
    Else
      NextChar$ = ""
  End If
  Select Case CharA%
    Case 0 To 9, 11 To 12, 14 To 30
      Character$ = " "

' If line breaks don't get converted to spaces or dashes, they will mark the ends of
' fields added to the record. If they are kept as field terminators, they will get
' converted, if need be, to single carriage return characters for ease of processing.
' Omit a line feed character following a carriage return, but convert it to a carriage
' return if it's on its own, so only carriage returns indicate a new line or field. The
' presence of carriage returns determines what default options the dialog box offers when
' it opens.

    Case LF_CHAR
      If PrevChar$ = CR Then
          Character$ = ""
        Else
          Character$ = CR
          CRFound    = TRUE
          DefaultAddFieldOption% = MULTI_FIELDS
      End If

    Case CR_CHAR
      Character$ = CR
      CRFound    = TRUE
      DefaultAddFieldOption% = MULTI_FIELDS

' If a potential delimiter character is found (dollar, pipe, double dagger, and question
' mark), check if the character following is a digit or a lowercase letter that is in
' turn followed by a space. If all those conditions are met, consider the character to be
' a delimiter, and add it to the string as such. If the character following the delimiter
' is the letter "a", or if the first character copied is a delimiter, the dialog box will
' default to showing the paste option as a new field, rather than as a simple string. The
' question mark is included here because that's how the Windows Clipboard copies the
' Connexion delimiter as text. If spacing in the copied text is not as expected, the
' pasted results may not be, either.

    Case DOLLAR_CHAR, PIPE_CHAR, DBL_DAGGER_CHAR, QUESTION_CHAR
      If NextChar$ Like "[a-z]" Then
          DelimFound = TRUE
          Character$ = UNI_DELIMITER
          If i = 1 Or NextChar$ = "a" Then
              If DefaultAddFieldOption% = 0 Then
                  DefaultAddFieldOption% = SINGLE_FIELD
              End If
          End If
        ElseIf NextChar$ Like "[0-9]" Then
          If i + 1 < Len( RawString$ ) Then
              If Mid$( RawString$, i + 2, 1 ) Like "[!0-9]" Then
                  DelimFound = TRUE
                  Character$ = UNI_DELIMITER
                Else
                  DelimFound = FALSE
                  Character$ = CharT$
              End If
          End If
        ElseIf NextChar$ = "$" Then
          Character$ = ""
        Else
          Character$ = CharT$
      End If

' Most ASCII characters in the copied text are retained.

    Case 32 To 35, 37, 39 To 62, 64 To 95, 97 To 123, 125
      Character$ = CharT$

' The grave accent sometimes appears as part of a left double quotation mark. If it
' appears to be used that way, replace it with a double quotation mark.

    Case 96
      If PrevChar$ = SINGLE_QUOTE Or NextChar$ = Chr$( 096 ) Then
          Character$ = SINGLE_QUOTE
        Else
          Character$ = CharT$
      End If

' OCLC says to not use the vertical bar, and the delete character is meaningless.

    Case 124, 127
      Character$ = ""

' NCRs, or Unicode code points, are added as is.

    Case NCR
      Character$ = CharT$

' Everything else appears as a pair of brackets, somewhat resembling an empty box.

    Case Else
      Character$ = "[]"

  End Select

  WorkString$ = WorkString$ & Character$
  PrevChar$   = Character$

Next i

WorkString$ = Trim$( WorkString$ )

' Collapse consecutive occurrences of a carriage return to a single occurrence.

WorkString$ = Replace( (WorkString$), CR$, TWO_CRs )

' Clean up fields copied from the MarcEdit editor. These fields are identified in part by
' the characteristic equals sign at the beginning of the line. If an equals sign is
' followed by three digits and then two spaces, consider that sufficient evidence that
' the copied text is from MarcEdit. Delete the equals sign and the two spaces following
' the potential tag.

If Left$( WorkString$, 1 ) = "=" Then
    WorkString$ = CR & WorkString$
End If
Start% = 1
Do
  p = InStr( Start%, WorkString$, "=" )
  If p > 0 Then
      If Mid$( WorkString$, p + 1, 5 ) Like "[0-9][0-9][0-9]  " Then
          WorkString$ = Left$( WorkString$, p - 1 ) & Mid$( WorkString$, p + 1, 3 ) & _
                        Mid$( WorkString$, p + 6, 2 ) & Trim$( Mid$( WorkString$, p + 8 ) )
      End If
  End If
  Start% = p + 1
Loop Until p = 0
If Left$( WorkString$, 1 ) = CR Then
    WorkString$ = Mid$( WorkString$, 2 )
End If

' For a string copied from MarcEdit, replace the mnemonic "{dollar}" with the actual
' dollar sign. All other mnemonics are retained.

p = InStr( WorkString$, "{dollar}" )
If p > 0 Then
    WorkString$ = Left$( WorkString$, p - 1 ) & "$" & Mid$( WorkString$, p + 8 )
End If

' Strings copied from a Voyager MARC display sometimes use carriage returns to separate
' tag and indicators. If a string seems to be a MARC field, eliminate interior carriage
' returns, so the only ones that remain are line breaks, or field separators. The clue
' the macro looks for is a carriage return that is followed by a string of three digits.
' Start this part of the processing by adding a carriage return to the beginning and end
' of the field, simply to aid in the manipulation. Then examine the three characters that
' follow the carriage return. If they seem to form a tag, then delete every subsequent
' carriage return that is not followed by three digits, assuming that they are artifacts
' of the display. If no tag is found, then carriage returns are kept.

If InStr( WorkString$, CR ) > 0 Then
    WorkString$ = CR & WorkString$ & CR
    Start%      = 1
    Do
      p = InStr( Start%, WorkString$, CR )
      If p > 0 Then
          If p < Len( WorkString$ ) - 2 Then
              For i = p To p + 2
                TagTest$ = Mid$( WorkString$, i + 1, 3 )
                If TagTest$ Like "[0-9][0-9][0-9]" Then
                    TagFound          = TRUE
                    PossibleMARCField = TRUE
                    PotentialFields%  = PotentialFields% + 1
                    Exit For
                  Else
                    TagFound = FALSE
                End If
              Next i
              If PossibleMARCField Then
                  If TagFound = FALSE Then
                      WorkString$ = Left$( WorkString$, p - 1 ) & Mid$( WorkString$, p + 1 )
                      Start%      = p
                    Else
                      Start%      = p + 2
                  End If
                Else
                  PotentialFields% = PotentialFields% + 1
                  Start%           = p + 1
              End If
            Else
              Start% = p + 1
          End If
        Else
          Exit Do
      End If
    Loop Until p = 0

    If Left$( WorkString$, 1 ) = CR Then
        WorkString$ = Mid$( WorkString$, 2 )
    End If
    If Right$( WorkString$, 1 ) = CR Then
        WorkString$ = Left$( WorkString$, Len( WorkString$ ) - 1 )
    End If
End If

' Count the number of potential fields in the string to determine the default paste
' operation to offer in the dialog box. Any copied text can be added as a string to an
' existing field, or as a new field. Multiple copied lines can be added as a string, a
' single new field (converting the line breaks into spaces or dashes, as instructed), or
' as several new fields.

Select Case PotentialFields%
  Case 0
    DefaultAddFieldOption% = SIMPLE_STRING
    CRFound                = FALSE
  Case 1
    DefaultAddFieldOption% = SINGLE_FIELD
    CRFound                = FALSE
  Case Else
    DefaultAddFieldOption% = MULTI_FIELDS
    CRFound                = TRUE
End Select

' Add a space before each delimiter.

Start% = 1
Do
  p = InStr( Start%, WorkString$, UNI_DELIMITER )
  Select Case p
    Case 0
      Exit Do
    Case 1
    Case Else
      WorkString$ = Left$( WorkString$, p - 1 ) & " " & Mid$( WorkString$, p )
  End Select
  Start% = p + 2
Loop Until p = 0

' Do a first round of eliminating extra white space.

WorkString$ = Replace( (WorkString$), " ", TWO_SPACES )

' Combine consecutive single quotation marks into one double quotation mark.

WorkString$ = Replace( (WorkString$), DOUBLE_QUOTE, TWO_SINGLE_QUOTES )

' Add a space after subfield codes.

WorkString$ = Replace( (WorkString$), UNI_DELIMITER, UNI_DELIMITER )

' Create separate strings to accommodate the three ways to deal with carriage returns:
'  - Change them to spaces, to add a single field to the record.
'  - Change them to dashes, also to add a single field to the record.
'  - Keep them, to add new fields to the record.

' Prepare the array to accommodate at least two rows in each of two dimensions.

ReDim FieldStore( 1, 1 )

If CRFound = TRUE Then

' Eliminate spaces preceding and following carriage returns.

    WorkString$ = Replace( (WorkString$), CR, CR_SPACE_BEFORE )
    WorkString$ = Replace( (WorkString$), CR, CR_SPACE_AFTER )

' Keep the current string that contains carriage returns.

    CRsNotConverted$  = WorkString$

' Create a text string with carriage returns converted to spaces.

    ConvertedToSpace$ = Replace( (WorkString$), " ", CR )

' Create a second text string with carriage returns converted to space-dash-space (i.e.,
' space-hyphen-hyphen-space).

    ConvertedToDash$  = Replace( (WorkString$), " -- ", CR )

' As the last step, clean up any remaining or introduced double spaces in the converted
' strings.

    ConvertedToSpace$ = Replace( ConvertedToSpace$, " ", TWO_SPACES )
    ConvertedToDash$  = Replace( ConvertedToDash$, " ", TWO_SPACES )

' Store the two strings in which the carriage returns have been converted in the first
' two rows of the first dimension of the array. Store each string terminated by a
' carriage return in the rows of the second dimension of the array.

    FieldStore( aSINGLE_FIELD, aSPACE ) = ConvertedToSpace$
    FieldStore( aSINGLE_FIELD, aDASH )  = ConvertedToDash$
    If MarcEdit = FALSE Then
        CRsNotConverted$ = Replace( CRsNotConverted$, " ", TWO_SPACES )
    End If
    Start% = 1
    i = 0
    Do
      p = InStr( Start%, CRsNotConverted$, CR )
      If p > 0 Then
          If i = 0 Then
              ReDim Preserve FieldStore( 1, 1 )
            Else
              ReDim Preserve FieldStore( 1, i )
          End If
          FieldStore( aMULTI_FIELDS, i ) = Mid$( CRsNotConverted$, Start%, p - Start% )
          Start% = p + 1
        Else
          If Start% < Len( CRsNotConverted$ ) Then
              ReDim Preserve FieldStore( aMULTI_FIELDS, i )
          FieldStore( aMULTI_FIELDS, i ) = Mid$( CRsNotConverted$, Start% )
          End If
      End If
      i = i + 1
    Loop Until p = 0
  Else
    FieldStore( aSINGLE_FIELD, aNO_CR ) = WorkString$

End If

' Examine the first three characters of each separate string in the array. If all three
' characters are digits, assume they form MARC tags and thus could be pasted into the
' record as new fields. In each such string, try to find the indicators and convert the
' characters representing the value "blank," if necessary, so they paste into the record
' properly.

For ArrayDimension% = aSINGLE_FIELD To aMULTI_FIELDS
  For i = 0 To UBound( FieldStore, 2 )
    TempString$ = FieldStore( ArrayDimension%, i )
    If TempString$ <> "" Then
        TagTest$ = Left$( TempString$, 3 )
        If TagTest$ Like "[0-9][0-9][0-9]" Then
            TaggedFields% = TaggedFields% + 1

' Extract the string of characters between the tag and the first delimiter (or end of the
' field, if there are no subfields) and examine it to see if it could contain a pair of
' indicators. If the copied text uses blank spaces both for layout and for indicators,
' the macro can't distinguish between the two, and may paste invalid values into the
' record. Other non-digit indicator characters--specifically, the underscore, sharp or
' hashtag sign, and backslash--can be changed to spaces for Connexion. If "$a" is not
' present at the beginning of the field (if subfield $a is the first subfield), the macro
' may not be able to display the indicators and beginning of the field data correctly.

            p = InStr( TempString$, UNI_DELIMITER )
            If p > 0 Then
                IndicatorString$ = Trim$( Mid$( TempString$, 4, p - 4 ) )
                If IndicatorString$ = "" Then
                    IndicatorString$ = "  "
                  ElseIf IndicatorString$ Like "[0-9_#\]" Then
                    IndicatorString$ = IndicatorString$ & " "
                  Else
                    For j = 1 To 2
                      CharT$ = Mid$( IndicatorString$, j, 1 )
                      If CharT$ Like "[_#\]" Then
                          Mid$( IndicatorString$, j, 1 ) = " "
                        ElseIf CharT$ Like "[!0-9]" Then
                          IndicatorString$ = ""
                          Exit For
                      End If
                    Next j
                End If
                If IndicatorString$ <> "" Then
                    TempString$ = Left$( TempString$, 3 ) & IndicatorString$ & Mid$( TempString$, p )
                End If

' If there is no delimiter, check the two characters following the potential tag. If the
' first is a space and the second is not a digit, assume the second indicator was a blank
' but was discarded in an earlier round of eliminating double spaces, and restore it.
' This means some fields will be pasted incorrectly, but that may be unavoidable.

              Else
                If Mid$( TempString$, 4, 1 ) = " " And Mid$( TempString$, 5, 1 ) Like "[!0-9]" Then
                    TempString$ = Left$( TempString$, 4 ) & " " & Mid$( TempString$, 5 )
                End If
            End If
        End If
    End If
    FieldStore( ArrayDimension%, i ) = TempString$
  Next i
Next ArrayDimension%

'If the majority of the strings in the array seem to be tagged fields, the focus when the
' dialog box opens is the OK button, to add the fields as copied. Otherwise, the focus
' will be on the input box, to prefix a tag and indicators when adding the new fields.

If TaggedFields% >= i / 2 Then
    TaggedFieldsLikely = TRUE
    If TaggedFields% = 1 Then
        DefaultAddFieldOption% = SINGLE_FIELD
      Else
        DefaultAddFieldOption% = MULTI_FIELDS
    End If
  Else
    TaggedFieldsLikely = FALSE
End If

' The dialog box for decisions to be made: To convert carriage returns (if present) to
' spaces or to dashes, and how to paste the text--as a string anywhere, or as a new
' field; or to keep carriage returns and paste each line in as a separate field; and if
' new fields are to be added, what their tags are.

Begin Dialog Dialog1Definition  268, 196, WaltsMacros$, .Dialog1ControlFunction
  OkButton       146, 172,  52,  14
  CancelButton   206, 172,  52,  14
  OptionGroup                                                       .OBGroup_PasteChoices
   OptionButton   18,  18,  96,  12, "",                            .OB1_PasteAsString
   OptionButton   18,  32,  44,  12, "&New field",                  .OB2_PasteAsField
   OptionButton   18,  46,  96,  12, "&Multiple new fields",        .OB3_PasteFields
  OptionGroup                                                       .OBGroup_ConvertOrAddTag
   OptionButton  148,  28,  36,  12, "&Spaces",                     .OB4_ConvertToSpaces
   OptionButton  194,  28,  36,  12, "&Dashes",                     .OB5_ConvertToDashes
  TextBox        162,  44,  18,  12,                                .TB1_Tag
  TextBox        183,  44,   8,  12,                                .TB2_Indicator1
  TextBox        194,  44,   8,  12,                                .TB3_Indicator2
  CheckBox       208,  44,  48,  12, "&Blank tag",                  .CB_BlankTag
  GroupBox        10,   6, 108,  58, "Paste copied text in as ..."
  GroupBox       126,   6, 132,  58, "Options",                     .GB_Options
  GroupBox        10,  68, 248,  97, "Deformatted text:",           .GB_Preview
  Text           148,  17,  80,   8, "Convert line breaks to ...",  .ConvertPrompt
  Text           132,  47,  30,   8, "Add tag:",                    .TagPrompt
  Text            18,  80, 232,  72, "",                            .PreviewTextArea
  Text            10, 174,  64,   8, "",                            .Troubleshooting
End Dialog

Dim Dialog1 As Dialog1Definition
On Error Resume Next
Dialog Dialog1
If Err = DLG_STATEMENT_CANCEL Then Exit Sub

Select Case Dialog1.OBGroup_PasteChoices

' In all the pasting cases, the MARC delimiter--the single character at code point 31--
' must be replaced first by the Unicode code point string.

  Case SIMPLE_STRING

' To paste text into an existing field, as a simple string, get the text of that field,
' insert the unformatted text at the cursor position, and then put it back into the
' record with the "SetField" command. The decision to be made here is to how to convert
' carriage returns, if present.

    If Dialog1.OBGroup_ConvertOrAddTag = aSPACE Then
        TempField$ = FieldStore( aSINGLE_FIELD, aSPACE )
      Else
        TempField$ = FieldStore( aSINGLE_FIELD, aDASH )
    End If
    DeformattedString$ = TempField$
    If InsertionPoint% > 5 Then
        CurrentField$ = Left$( CurrentField$, InsertionPoint% - 1 ) & DeformattedString$ & Mid$( CurrentField$, InsertionPoint% )
      Else
        CurrentField$ = CurrentField$ & DeformattedString$
    End If
    If CS.SetFieldLine( Row%, CurrentField$ ) = FALSE Then
        MsgBox "Sorry, the copied text was not added to the record.", CRITICAL_MESSAGE, WaltsMacros$
        Exit Sub
    End If

' When pasting in text as fields, if the first delimiter is for subfield $a, delete it.
' To add the de-formatted text as a new field, the user must specify how to convert
' carriage returns. The new field is added with the "AddField" command, which places it
' in the record according to its tag. If the tag is blank, such as might be chosen when
' the copied text seems to contain no tag, the macro uses the "AddFieldLine" to add the
' new field immediately following the field in which the cursor is placed.

  Case SINGLE_FIELD

    If BlankTag Then
        Tag$        = BLANK_TAG_FLAG
        TempField$  = Tag$
      Else
        Tag$        = Dialog1.TB1_Tag
        Indicator1$ = Dialog1.TB2_Indicator1
        If Indicator1$ = "" Then Indicator1$ = " "
        Indicator2$ = Dialog1.TB3_Indicator2
        If Indicator2$ = "" Then Indicator2$ = " "
        TempField$ = Tag$ & Indicator1$ & Indicator2$
    End If
    If Dialog1.OBGroup_ConvertOrAddTag = aSPACE Then
        TempString$ = FieldStore( aSINGLE_FIELD, aSPACE )
      Else
        TempString$ = FieldStore( aSINGLE_FIELD, aDASH )
    End If
    If Left$( TempString$, 3 ) Like "[0-9][0-9][0-9]" And Mid$( TempString$, 6, 9 ) = UNI_DELIMITER & "a" Then
        TempString$ = Left$( TempString$, 5 ) & Trim$( Mid$( TempString$, 15 ) )
      ElseIf Left$( TempString$, 9 ) = UNI_DELIMITER & "a" Then
        TempString$ = Trim$( Mid$( TempString$, 10 ) )
    End If
    TempField$ = Trim$( TempField$ & TempString$ )
    If BlankTag Then
        DeformattedString$ = BLANK_TAG_INDICATORS & Mid$( TempField$, 2 )
        If CS.AddFieldLine( Row% + i, DeformattedString$ ) = FALSE Then
            MsgBox "Sorry, the field could not be added.", CRITICAL_MESSAGE, WaltsMacros$
        End If
      Else
        DeformattedString$ = TempField$
        If CS.AddField( 1, DeformattedString$ ) = FALSE Then
            MsgBox "Sorry, the field could not be added.", CRITICAL_MESSAGE, WaltsMacros$
        End If
    End If

  Case MULTI_FIELDS

    For i = 0 To UBound( FieldStore, 2 )
      If i = 0 Then
          If BlankTag Then
              Tag$        = BLANK_TAG_FLAG
              Indicator1$ = ""
              Indicator2$ = ""
            Else
              Tag$        = Dialog1.TB1_Tag
              Indicator1$ = Dialog1.TB2_Indicator1
              If Indicator1$ = "" Then Indicator1$ = " "
              Indicator2$ = Dialog1.TB3_Indicator2
              If Indicator2$ = "" Then Indicator2$ = " "
          End If
      End If
      TempField$  = Tag$ & Indicator1$ & Indicator2$
      TempString$ = FieldStore( aMULTI_FIELDS, i )
      If Mid$( TempString$, 6, 9 ) = UNI_DELIMITER & "a" Then
          TempString$ = Left$( TempString$, 5 ) & Trim$( Mid$( TempString$, 15 ) )
      End If
      TempField$  = Trim$( TempField$ & TempString$ )
      If BlankTag Then
          DeformattedString$ = BLANK_TAG_INDICATORS & Mid$( TempField$, 2 )
          If CS.AddFieldLine( Row% + i, DeformattedString$ ) = FALSE Then
              AddFieldFailure% = AddFieldFailure% = 1
          End If
        Else
          DeformattedString$ = TempField$
          If CS.AddField( 99 + i, DeformattedString$ ) = FALSE Then
              AddFieldFailure% = AddFieldFailure% = 1
          End If
      End If
    Next i

    If AddFieldFailure% > 0 Then
        MsgBox "Sorry, " & Trim$( Str$( AddFieldFailure% ) ) & " fields could not be added.", CRITICAL_MESSAGE, WaltsMacros$
    End If
End Select

Done:

End Sub

'****************************************************************************************

Sub FillCombinedArray

' This array is used to turn a base + diacritic character combination into a precomposed
' ASCII character, for display.

Combined( 0  ) = "A" & GRAVE      & "À"
Combined( 1  ) = "a" & GRAVE      & "à"
Combined( 2  ) = "E" & GRAVE      & "È"
Combined( 3  ) = "e" & GRAVE      & "è"
Combined( 4  ) = "I" & GRAVE      & "Ì"
Combined( 5  ) = "i" & GRAVE      & "ì"
Combined( 6  ) = "O" & GRAVE      & "Ò"
Combined( 7  ) = "o" & GRAVE      & "ò"
Combined( 8  ) = "U" & GRAVE      & "Ù"
Combined( 9  ) = "u" & GRAVE      & "ù"
Combined( 10 ) = "A" & ACUTE      & "Á"
Combined( 11 ) = "a" & ACUTE      & "á"
Combined( 12 ) = "E" & ACUTE      & "É"
Combined( 13 ) = "e" & ACUTE      & "é"
Combined( 14 ) = "I" & ACUTE      & "Í"
Combined( 15 ) = "i" & ACUTE      & "í"
Combined( 16 ) = "O" & ACUTE      & "Ó"
Combined( 17 ) = "o" & ACUTE      & "ó"
Combined( 18 ) = "U" & ACUTE      & "Ú"
Combined( 19 ) = "u" & ACUTE      & "ú"
Combined( 20 ) = "Y" & ACUTE      & "Ý"
Combined( 21 ) = "y" & ACUTE      & "ý"
Combined( 22 ) = "A" & CIRCUMFLEX & "Â"
Combined( 23 ) = "a" & CIRCUMFLEX & "â"
Combined( 24 ) = "E" & CIRCUMFLEX & "Ê"
Combined( 25 ) = "e" & CIRCUMFLEX & "ê"
Combined( 26 ) = "I" & CIRCUMFLEX & "Î"
Combined( 27 ) = "i" & CIRCUMFLEX & "î"
Combined( 28 ) = "O" & CIRCUMFLEX & "Ô"
Combined( 29 ) = "o" & CIRCUMFLEX & "ô"
Combined( 30 ) = "U" & CIRCUMFLEX & "Û"
Combined( 31 ) = "u" & CIRCUMFLEX & "û"
Combined( 32 ) = "A" & TILDE      & "Ã"
Combined( 33 ) = "a" & TILDE      & "ã"
Combined( 34 ) = "N" & TILDE      & "Ñ"
Combined( 35 ) = "n" & TILDE      & "ñ"
Combined( 36 ) = "O" & TILDE      & "Õ"
Combined( 37 ) = "o" & TILDE      & "õ"
Combined( 38 ) = "A" & DIAERESIS  & "Ä"
Combined( 39 ) = "a" & DIAERESIS  & "ä"
Combined( 40 ) = "E" & DIAERESIS  & "Ë"
Combined( 41 ) = "e" & DIAERESIS  & "ë"
Combined( 42 ) = "I" & DIAERESIS  & "Ï"
Combined( 43 ) = "i" & DIAERESIS  & "ï"
Combined( 44 ) = "O" & DIAERESIS  & "Ö"
Combined( 45 ) = "o" & DIAERESIS  & "ö"
Combined( 46 ) = "U" & DIAERESIS  & "Ü"
Combined( 47 ) = "u" & DIAERESIS  & "ü"
Combined( 48 ) = "y" & DIAERESIS  & "ÿ"
Combined( 49 ) = "A" & RING_ABOVE & "Å"
Combined( 50 ) = "a" & RING_ABOVE & "å"
Combined( 51 ) = "C" & CEDILLA    & "Ç"
Combined( 52 ) = "c" & CEDILLA    & "ç"

End Sub

'****************************************************************************************

Sub FillDisplaySubArray

' The first four characters of each row of the array comprise the Unicode character to be
' replaced by the character in the second part of the row. Most of the substitions are to
' help properly display the copied strings in the dialog box, because that box can use
' only the characters in ISO/IEC 8859-1 (0000-00FF, or ASCII). This macro finds
' (approximate) substitutes for the characters in the Latin Extended-A (U+0100-U+017F),
' Extended-B (U+0180-U+024F), and Extended Additional (U+1E00-U+1EFF) blocks, mostly by
' removing diacritics. Characters for which no appropriate substitutes are available are
' represented by a pair of empty brackets, []. For both the display and the copied
' strings, the macro replaces some characters in the General Punctation (U+2000-U+206F)
' and Alphabetic Presentation Forms (U+FB00-U+FB4F) blocks, mostly for spaces, dashes,
' and quotation marks. All Unicode characters with no equivalent in ISO/IEC 8859-1 will
' not be able to be represented in the dialog box, although they will be pasted into the
' record.

DisplaySub( 0   ) = "0100A"
DisplaySub( 1   ) = "0101a"
DisplaySub( 2   ) = "0102A"
DisplaySub( 3   ) = "0103a"
DisplaySub( 4   ) = "0104A"
DisplaySub( 5   ) = "0105a"
DisplaySub( 6   ) = "0106C"
DisplaySub( 7   ) = "0107c"
DisplaySub( 8   ) = "0108C"
DisplaySub( 9   ) = "0109c"
DisplaySub( 10  ) = "010AC"
DisplaySub( 11  ) = "010Bc"
DisplaySub( 12  ) = "010CC"
DisplaySub( 13  ) = "010Dc"
DisplaySub( 14  ) = "010ED"
DisplaySub( 15  ) = "010Fd"
DisplaySub( 16  ) = "0110D"
DisplaySub( 17  ) = "0111d"
DisplaySub( 18  ) = "0112E"
DisplaySub( 19  ) = "0113e"
DisplaySub( 20  ) = "0114E"
DisplaySub( 21  ) = "0115e"
DisplaySub( 22  ) = "0116E"
DisplaySub( 23  ) = "0117e"
DisplaySub( 24  ) = "0118E"
DisplaySub( 25  ) = "0119e"
DisplaySub( 26  ) = "011AE"
DisplaySub( 27  ) = "011Be"
DisplaySub( 28  ) = "011CG"
DisplaySub( 29  ) = "011Dg"
DisplaySub( 30  ) = "011EG"
DisplaySub( 31  ) = "011Fg"
DisplaySub( 32  ) = "0120G"
DisplaySub( 33  ) = "0121g"
DisplaySub( 34  ) = "0122G"
DisplaySub( 35  ) = "0123g"
DisplaySub( 36  ) = "0124H"
DisplaySub( 37  ) = "0125h"
DisplaySub( 38  ) = "0126H"
DisplaySub( 39  ) = "0127h"
DisplaySub( 40  ) = "0128I"
DisplaySub( 41  ) = "0129i"
DisplaySub( 42  ) = "012AI"
DisplaySub( 43  ) = "012Bi"
DisplaySub( 44  ) = "012CI"
DisplaySub( 45  ) = "012Di"
DisplaySub( 46  ) = "012EI"
DisplaySub( 47  ) = "012Fi"
DisplaySub( 48  ) = "0130I"
DisplaySub( 49  ) = "0131i"
DisplaySub( 50  ) = "0132IJ"
DisplaySub( 51  ) = "0133ij"
DisplaySub( 52  ) = "0134J"
DisplaySub( 53  ) = "0135j"
DisplaySub( 54  ) = "0136K"
DisplaySub( 55  ) = "0137k"
DisplaySub( 56  ) = "0139L"
DisplaySub( 57  ) = "013Al"
DisplaySub( 58  ) = "013BL"
DisplaySub( 59  ) = "013Cl"
DisplaySub( 60  ) = "013DL"
DisplaySub( 61  ) = "013El"
DisplaySub( 62  ) = "013FL"
DisplaySub( 63  ) = "0140l"
DisplaySub( 64  ) = "0141L"
DisplaySub( 65  ) = "0142l"
DisplaySub( 66  ) = "0143N"
DisplaySub( 67  ) = "0144n"
DisplaySub( 68  ) = "0145N"
DisplaySub( 69  ) = "0146n"
DisplaySub( 70  ) = "0147N"
DisplaySub( 71  ) = "0148n"
DisplaySub( 72  ) = "0149'n"
DisplaySub( 73  ) = "014CO"
DisplaySub( 74  ) = "014Do"
DisplaySub( 75  ) = "014EO"
DisplaySub( 76  ) = "014Fo"
DisplaySub( 77  ) = "0150O"
DisplaySub( 78  ) = "0151o"
DisplaySub( 79  ) = "0152?"
DisplaySub( 80  ) = "0153?"
DisplaySub( 81  ) = "0154R"
DisplaySub( 82  ) = "0155r"
DisplaySub( 83  ) = "0156R"
DisplaySub( 84  ) = "0157r"
DisplaySub( 85  ) = "0158R"
DisplaySub( 86  ) = "0159r"
DisplaySub( 87  ) = "015AS"
DisplaySub( 88  ) = "015Bs"
DisplaySub( 89  ) = "015CS"
DisplaySub( 90  ) = "015Ds"
DisplaySub( 91  ) = "015ES"
DisplaySub( 92  ) = "015Fs"
DisplaySub( 93  ) = "0160S"
DisplaySub( 94  ) = "0161s"
DisplaySub( 95  ) = "0162T"
DisplaySub( 96  ) = "0163t"
DisplaySub( 97  ) = "0164T"
DisplaySub( 98  ) = "0165t"
DisplaySub( 99  ) = "0166T"
DisplaySub( 100 ) = "0167t"
DisplaySub( 101 ) = "0168U"
DisplaySub( 102 ) = "0169u"
DisplaySub( 103 ) = "016AU"
DisplaySub( 104 ) = "016Bu"
DisplaySub( 105 ) = "016CU"
DisplaySub( 106 ) = "016Du"
DisplaySub( 107 ) = "016EU"
DisplaySub( 108 ) = "016Fu"
DisplaySub( 109 ) = "0170U"
DisplaySub( 110 ) = "0171u"
DisplaySub( 111 ) = "0172U"
DisplaySub( 112 ) = "0173u"
DisplaySub( 113 ) = "0174W"
DisplaySub( 114 ) = "0175w"
DisplaySub( 115 ) = "0176Y"
DisplaySub( 116 ) = "0177y"
DisplaySub( 117 ) = "0178Y"
DisplaySub( 118 ) = "0179Z"
DisplaySub( 119 ) = "017Az"
DisplaySub( 120 ) = "017BZ"
DisplaySub( 121 ) = "017Cz"
DisplaySub( 122 ) = "017DZ"
DisplaySub( 123 ) = "017Ez"
DisplaySub( 124 ) = "017Fs"
DisplaySub( 125 ) = "0180b"
DisplaySub( 126 ) = "0181B"
DisplaySub( 127 ) = "0182B"
DisplaySub( 128 ) = "0183b"
DisplaySub( 129 ) = "0186O"
DisplaySub( 130 ) = "0187C"
DisplaySub( 131 ) = "0188c"
DisplaySub( 132 ) = "018AD"
DisplaySub( 133 ) = "018BD"
DisplaySub( 134 ) = "018Cd"
DisplaySub( 135 ) = "018EE"
DisplaySub( 136 ) = "0190E"
DisplaySub( 137 ) = "0191F"
DisplaySub( 138 ) = "0192f"
DisplaySub( 139 ) = "0193G"
DisplaySub( 140 ) = "0195hv"
DisplaySub( 141 ) = "0197I"
DisplaySub( 142 ) = "0198K"
DisplaySub( 143 ) = "0199k"
DisplaySub( 144 ) = "019Al"
DisplaySub( 145 ) = "019CM"
DisplaySub( 146 ) = "019DN"
DisplaySub( 147 ) = "019En"
DisplaySub( 148 ) = "019FO"
DisplaySub( 149 ) = "01A0O"
DisplaySub( 150 ) = "01A1o"
DisplaySub( 151 ) = "01A2OI"
DisplaySub( 152 ) = "01A3oi"
DisplaySub( 153 ) = "01A4P"
DisplaySub( 154 ) = "01A5p"
DisplaySub( 155 ) = "01ABt"
DisplaySub( 156 ) = "01ACT"
DisplaySub( 157 ) = "01ADt"
DisplaySub( 158 ) = "01AET"
DisplaySub( 159 ) = "01AFU"
DisplaySub( 160 ) = "01B0u"
DisplaySub( 161 ) = "01B2V"
DisplaySub( 162 ) = "01B3Y"
DisplaySub( 163 ) = "01B4y"
DisplaySub( 164 ) = "01B5Z"
DisplaySub( 165 ) = "01B6z"
DisplaySub( 166 ) = "01C2$"
DisplaySub( 167 ) = "01C4DZ"
DisplaySub( 168 ) = "01C5Dz"
DisplaySub( 169 ) = "01C6dz"
DisplaySub( 170 ) = "01C7LJ"
DisplaySub( 171 ) = "01C8Lj"
DisplaySub( 172 ) = "01C9lj"
DisplaySub( 173 ) = "01CANJ"
DisplaySub( 174 ) = "01CBNj"
DisplaySub( 175 ) = "01CCnj"
DisplaySub( 176 ) = "01CDA"
DisplaySub( 177 ) = "01CEa"
DisplaySub( 178 ) = "01CFI"
DisplaySub( 179 ) = "01D0i"
DisplaySub( 180 ) = "01D1O"
DisplaySub( 181 ) = "01D2o"
DisplaySub( 182 ) = "01D3U"
DisplaySub( 183 ) = "01D4u"
DisplaySub( 184 ) = "01D5U"
DisplaySub( 185 ) = "01D6u"
DisplaySub( 186 ) = "01D7U"
DisplaySub( 187 ) = "01D8u"
DisplaySub( 188 ) = "01D9U"
DisplaySub( 189 ) = "01DAu"
DisplaySub( 190 ) = "01DBU"
DisplaySub( 191 ) = "01DCu"
DisplaySub( 192 ) = "01DDe"
DisplaySub( 193 ) = "01DEA"
DisplaySub( 194 ) = "01DFa"
DisplaySub( 195 ) = "01E0A"
DisplaySub( 196 ) = "01E1a"
DisplaySub( 197 ) = "01E2Æ"
DisplaySub( 198 ) = "01E3æ"
DisplaySub( 199 ) = "01E4G"
DisplaySub( 200 ) = "01E5g"
DisplaySub( 201 ) = "01E6G"
DisplaySub( 202 ) = "01E7g"
DisplaySub( 203 ) = "01E8K"
DisplaySub( 204 ) = "01E9k"
DisplaySub( 205 ) = "01EAO"
DisplaySub( 206 ) = "01EBo"
DisplaySub( 207 ) = "01ECO"
DisplaySub( 208 ) = "01EDo"
DisplaySub( 209 ) = "01F0j"
DisplaySub( 210 ) = "01F1DZ"
DisplaySub( 211 ) = "01F2Dz"
DisplaySub( 212 ) = "01F3dz"
DisplaySub( 213 ) = "01F4G"
DisplaySub( 214 ) = "01F5g"
DisplaySub( 215 ) = "01F8N"
DisplaySub( 216 ) = "01F9n"
DisplaySub( 217 ) = "01FAA"
DisplaySub( 218 ) = "01FBa"
DisplaySub( 219 ) = "01FCÆ"
DisplaySub( 220 ) = "01FDæ"
DisplaySub( 221 ) = "01FEO"
DisplaySub( 222 ) = "01FFo"
DisplaySub( 223 ) = "0200A"
DisplaySub( 224 ) = "0201a"
DisplaySub( 225 ) = "0202A"
DisplaySub( 226 ) = "0203a"
DisplaySub( 227 ) = "0204E"
DisplaySub( 228 ) = "0205e"
DisplaySub( 229 ) = "0206E"
DisplaySub( 230 ) = "0207e"
DisplaySub( 231 ) = "0208I"
DisplaySub( 232 ) = "0209i"
DisplaySub( 233 ) = "020AI"
DisplaySub( 234 ) = "020Bi"
DisplaySub( 235 ) = "020CO"
DisplaySub( 236 ) = "020Do"
DisplaySub( 237 ) = "020EO"
DisplaySub( 238 ) = "020Fo"
DisplaySub( 239 ) = "0210R"
DisplaySub( 240 ) = "0211r"
DisplaySub( 241 ) = "0212R"
DisplaySub( 242 ) = "0213r"
DisplaySub( 243 ) = "0214U"
DisplaySub( 244 ) = "0215u"
DisplaySub( 245 ) = "0216U"
DisplaySub( 246 ) = "0217u"
DisplaySub( 247 ) = "0218S"
DisplaySub( 248 ) = "0219s"
DisplaySub( 249 ) = "021AT"
DisplaySub( 250 ) = "021Bt"
DisplaySub( 251 ) = "021EH"
DisplaySub( 252 ) = "021Fh"
DisplaySub( 253 ) = "0220N"
DisplaySub( 254 ) = "0221d"
DisplaySub( 255 ) = "0222OU"
DisplaySub( 256 ) = "0223ou"
DisplaySub( 257 ) = "0224Z"
DisplaySub( 258 ) = "0225z"
DisplaySub( 259 ) = "0226A"
DisplaySub( 260 ) = "0227a"
DisplaySub( 261 ) = "0228E"
DisplaySub( 262 ) = "0229e"
DisplaySub( 263 ) = "022AO"
DisplaySub( 264 ) = "022Bo"
DisplaySub( 265 ) = "022CO"
DisplaySub( 266 ) = "022Do"
DisplaySub( 267 ) = "022EO"
DisplaySub( 268 ) = "022Fo"
DisplaySub( 269 ) = "0230O"
DisplaySub( 270 ) = "0231o"
DisplaySub( 271 ) = "0232Y"
DisplaySub( 272 ) = "0233y"
DisplaySub( 273 ) = "0234l"
DisplaySub( 274 ) = "0235n"
DisplaySub( 275 ) = "0236t"
DisplaySub( 276 ) = "0237j"
DisplaySub( 277 ) = "023AA"
DisplaySub( 278 ) = "023BC"
DisplaySub( 279 ) = "023Cc"
DisplaySub( 280 ) = "023DL"
DisplaySub( 281 ) = "023ET"
DisplaySub( 282 ) = "023Fs"
DisplaySub( 283 ) = "0240z"
DisplaySub( 284 ) = "0243B"
DisplaySub( 285 ) = "0244U"
DisplaySub( 286 ) = "0245V"
DisplaySub( 287 ) = "0246E"
DisplaySub( 288 ) = "0247e"
DisplaySub( 289 ) = "0248J"
DisplaySub( 290 ) = "0249j"
DisplaySub( 291 ) = "024Aq"
DisplaySub( 292 ) = "024BQ"
DisplaySub( 293 ) = "024CR"
DisplaySub( 294 ) = "024Dr"
DisplaySub( 295 ) = "024EY"
DisplaySub( 296 ) = "024Fy"
DisplaySub( 297 ) = "02B9" & SINGLE_QUOTE
DisplaySub( 298 ) = "02BA" & DOUBLE_QUOTE
DisplaySub( 299 ) = "02BB" & SINGLE_QUOTE
DisplaySub( 300 ) = "02BC" & SINGLE_QUOTE
DisplaySub( 301 ) = "02BD" & SINGLE_QUOTE
DisplaySub( 302 ) = "02BE" & SINGLE_QUOTE
DisplaySub( 303 ) = "02BF" & SINGLE_QUOTE
DisplaySub( 304 ) = "1E00A"
DisplaySub( 305 ) = "1E01a"
DisplaySub( 306 ) = "1E02B"
DisplaySub( 307 ) = "1E03b"
DisplaySub( 308 ) = "1E04B"
DisplaySub( 309 ) = "1E05b"
DisplaySub( 310 ) = "1E06B"
DisplaySub( 311 ) = "1E07b"
DisplaySub( 312 ) = "1E08C"
DisplaySub( 313 ) = "1E09c"
DisplaySub( 314 ) = "1E0AD"
DisplaySub( 315 ) = "1E0Bd"
DisplaySub( 316 ) = "1E0CD"
DisplaySub( 317 ) = "1E0Dd"
DisplaySub( 318 ) = "1E0ED"
DisplaySub( 319 ) = "1E0Fd"
DisplaySub( 320 ) = "1E10D"
DisplaySub( 321 ) = "1E11d"
DisplaySub( 322 ) = "1E12D"
DisplaySub( 323 ) = "1E13d"
DisplaySub( 324 ) = "1E14E"
DisplaySub( 325 ) = "1E15e"
DisplaySub( 326 ) = "1E16E"
DisplaySub( 327 ) = "1E17e"
DisplaySub( 328 ) = "1E18E"
DisplaySub( 329 ) = "1E19e"
DisplaySub( 330 ) = "1E1AE"
DisplaySub( 331 ) = "1E1Be"
DisplaySub( 332 ) = "1E1CE"
DisplaySub( 333 ) = "1E1De"
DisplaySub( 334 ) = "1E1EF"
DisplaySub( 335 ) = "1E1Ff"
DisplaySub( 336 ) = "1E20G"
DisplaySub( 337 ) = "1E21g"
DisplaySub( 338 ) = "1E22H"
DisplaySub( 339 ) = "1E23h"
DisplaySub( 340 ) = "1E24H"
DisplaySub( 341 ) = "1E25h"
DisplaySub( 342 ) = "1E26H"
DisplaySub( 343 ) = "1E27h"
DisplaySub( 344 ) = "1E28H"
DisplaySub( 345 ) = "1E29h"
DisplaySub( 346 ) = "1E2AH"
DisplaySub( 347 ) = "1E2Bh"
DisplaySub( 348 ) = "1E2CI"
DisplaySub( 349 ) = "1E2Di"
DisplaySub( 350 ) = "1E2EI"
DisplaySub( 351 ) = "1E2Fi"
DisplaySub( 352 ) = "1E30K"
DisplaySub( 353 ) = "1E31k"
DisplaySub( 354 ) = "1E32K"
DisplaySub( 355 ) = "1E33k"
DisplaySub( 356 ) = "1E34K"
DisplaySub( 357 ) = "1E35k"
DisplaySub( 358 ) = "1E36L"
DisplaySub( 359 ) = "1E37l"
DisplaySub( 360 ) = "1E38L"
DisplaySub( 361 ) = "1E39l"
DisplaySub( 362 ) = "1E3AL"
DisplaySub( 363 ) = "1E3Bl"
DisplaySub( 364 ) = "1E3CL"
DisplaySub( 365 ) = "1E3Dl"
DisplaySub( 366 ) = "1E3EM"
DisplaySub( 367 ) = "1E3Fm"
DisplaySub( 368 ) = "1E40M"
DisplaySub( 369 ) = "1E41m"
DisplaySub( 370 ) = "1E42M"
DisplaySub( 371 ) = "1E43m"
DisplaySub( 372 ) = "1E44N"
DisplaySub( 373 ) = "1E45n"
DisplaySub( 374 ) = "1E46N"
DisplaySub( 375 ) = "1E47n"
DisplaySub( 376 ) = "1E48N"
DisplaySub( 377 ) = "1E49n"
DisplaySub( 378 ) = "1E4AN"
DisplaySub( 379 ) = "1E4Bn"
DisplaySub( 380 ) = "1E4CO"
DisplaySub( 381 ) = "1E4Do"
DisplaySub( 382 ) = "1E4EO"
DisplaySub( 383 ) = "1E4Fo"
DisplaySub( 384 ) = "1E50O"
DisplaySub( 385 ) = "1E51o"
DisplaySub( 386 ) = "1E52O"
DisplaySub( 387 ) = "1E53o"
DisplaySub( 388 ) = "1E54P"
DisplaySub( 389 ) = "1E55p"
DisplaySub( 390 ) = "1E56P"
DisplaySub( 391 ) = "1E57p"
DisplaySub( 392 ) = "1E58R"
DisplaySub( 393 ) = "1E59r"
DisplaySub( 394 ) = "1E5AR"
DisplaySub( 395 ) = "1E5Br"
DisplaySub( 396 ) = "1E5CR"
DisplaySub( 397 ) = "1E5Dr"
DisplaySub( 398 ) = "1E5ER"
DisplaySub( 399 ) = "1E5Fr"
DisplaySub( 400 ) = "1E60S"
DisplaySub( 401 ) = "1E61s"
DisplaySub( 402 ) = "1E62S"
DisplaySub( 403 ) = "1E63s"
DisplaySub( 404 ) = "1E64S"
DisplaySub( 405 ) = "1E65s"
DisplaySub( 406 ) = "1E66S"
DisplaySub( 407 ) = "1E67s"
DisplaySub( 408 ) = "1E68S"
DisplaySub( 409 ) = "1E69s"
DisplaySub( 410 ) = "1E6AT"
DisplaySub( 411 ) = "1E6Bt"
DisplaySub( 412 ) = "1E6CT"
DisplaySub( 413 ) = "1E6Dt"
DisplaySub( 414 ) = "1E6ET"
DisplaySub( 415 ) = "1E6Ft"
DisplaySub( 416 ) = "1E70T"
DisplaySub( 417 ) = "1E71t"
DisplaySub( 418 ) = "1E72U"
DisplaySub( 419 ) = "1E73u"
DisplaySub( 420 ) = "1E74U"
DisplaySub( 421 ) = "1E75u"
DisplaySub( 422 ) = "1E76U"
DisplaySub( 423 ) = "1E77u"
DisplaySub( 424 ) = "1E78U"
DisplaySub( 425 ) = "1E79u"
DisplaySub( 426 ) = "1E7AU"
DisplaySub( 427 ) = "1E7Bu"
DisplaySub( 428 ) = "1E7CV"
DisplaySub( 429 ) = "1E7Dv"
DisplaySub( 430 ) = "1E7EV"
DisplaySub( 431 ) = "1E7Fv"
DisplaySub( 432 ) = "1E80W"
DisplaySub( 433 ) = "1E81w"
DisplaySub( 434 ) = "1E82W"
DisplaySub( 435 ) = "1E83w"
DisplaySub( 436 ) = "1E84W"
DisplaySub( 437 ) = "1E85w"
DisplaySub( 438 ) = "1E86W"
DisplaySub( 439 ) = "1E87w"
DisplaySub( 440 ) = "1E88W"
DisplaySub( 441 ) = "1E89w"
DisplaySub( 442 ) = "1E8AX"
DisplaySub( 443 ) = "1E8Bx"
DisplaySub( 444 ) = "1E8CX"
DisplaySub( 445 ) = "1E8Dx"
DisplaySub( 446 ) = "1E8EY"
DisplaySub( 447 ) = "1E8Fy"
DisplaySub( 448 ) = "1E90Z"
DisplaySub( 449 ) = "1E91z"
DisplaySub( 450 ) = "1E92Z"
DisplaySub( 451 ) = "1E93z"
DisplaySub( 452 ) = "1E94Z"
DisplaySub( 453 ) = "1E95z"
DisplaySub( 454 ) = "1E96h"
DisplaySub( 455 ) = "1E97t"
DisplaySub( 456 ) = "1E98w"
DisplaySub( 457 ) = "1E99y"
DisplaySub( 458 ) = "1E9Aa"
DisplaySub( 459 ) = "1E9Bs"
DisplaySub( 460 ) = "1E9Cs"
DisplaySub( 461 ) = "1E9Ds"
DisplaySub( 462 ) = "1E9ESS"
DisplaySub( 463 ) = "1EA0A"
DisplaySub( 464 ) = "1EA1a"
DisplaySub( 465 ) = "1EA2A"
DisplaySub( 466 ) = "1EA3a"
DisplaySub( 467 ) = "1EA4A"
DisplaySub( 468 ) = "1EA5a"
DisplaySub( 469 ) = "1EA6A"
DisplaySub( 470 ) = "1EA7a"
DisplaySub( 471 ) = "1EA8A"
DisplaySub( 472 ) = "1EA9a"
DisplaySub( 473 ) = "1EAAA"
DisplaySub( 474 ) = "1EABa"
DisplaySub( 475 ) = "1EACA"
DisplaySub( 476 ) = "1EADa"
DisplaySub( 477 ) = "1EAEA"
DisplaySub( 478 ) = "1EAFa"
DisplaySub( 479 ) = "1EB0A"
DisplaySub( 480 ) = "1EB1a"
DisplaySub( 481 ) = "1EB2A"
DisplaySub( 482 ) = "1EB3a"
DisplaySub( 483 ) = "1EB4A"
DisplaySub( 484 ) = "1EB5a"
DisplaySub( 485 ) = "1EB6A"
DisplaySub( 486 ) = "1EB7a"
DisplaySub( 487 ) = "1EB8E"
DisplaySub( 488 ) = "1EB9e"
DisplaySub( 489 ) = "1EBAE"
DisplaySub( 490 ) = "1EBBe"
DisplaySub( 491 ) = "1EBCE"
DisplaySub( 492 ) = "1EBDe"
DisplaySub( 493 ) = "1EBEE"
DisplaySub( 494 ) = "1EBFe"
DisplaySub( 495 ) = "1EC0E"
DisplaySub( 496 ) = "1EC1e"
DisplaySub( 497 ) = "1EC2E"
DisplaySub( 498 ) = "1EC3e"
DisplaySub( 499 ) = "1EC4E"
DisplaySub( 500 ) = "1EC5e"
DisplaySub( 501 ) = "1EC6E"
DisplaySub( 502 ) = "1EC7e"
DisplaySub( 503 ) = "1EC8I"
DisplaySub( 504 ) = "1EC9i"
DisplaySub( 505 ) = "1ECAI"
DisplaySub( 506 ) = "1ECBi"
DisplaySub( 507 ) = "1ECCO"
DisplaySub( 508 ) = "1ECDo"
DisplaySub( 509 ) = "1ECEO"
DisplaySub( 510 ) = "1ECFo"
DisplaySub( 511 ) = "1ED0O"
DisplaySub( 512 ) = "1ED1o"
DisplaySub( 513 ) = "1ED2O"
DisplaySub( 514 ) = "1ED3o"
DisplaySub( 515 ) = "1ED4O"
DisplaySub( 516 ) = "1ED5o"
DisplaySub( 517 ) = "1ED6O"
DisplaySub( 518 ) = "1ED7o"
DisplaySub( 519 ) = "1ED8O"
DisplaySub( 520 ) = "1ED9o"
DisplaySub( 521 ) = "1EDAO"
DisplaySub( 522 ) = "1EDBo"
DisplaySub( 523 ) = "1EDCO"
DisplaySub( 524 ) = "1EDDo"
DisplaySub( 525 ) = "1EDEO"
DisplaySub( 526 ) = "1EDFo"
DisplaySub( 527 ) = "1EE0O"
DisplaySub( 528 ) = "1EE1o"
DisplaySub( 529 ) = "1EE2O"
DisplaySub( 530 ) = "1EE3o"
DisplaySub( 531 ) = "1EE4U"
DisplaySub( 532 ) = "1EE5u"
DisplaySub( 533 ) = "1EE6U"
DisplaySub( 534 ) = "1EE7u"
DisplaySub( 535 ) = "1EE8U"
DisplaySub( 536 ) = "1EE9u"
DisplaySub( 537 ) = "1EEAU"
DisplaySub( 538 ) = "1EEBu"
DisplaySub( 539 ) = "1EECU"
DisplaySub( 540 ) = "1EEDu"
DisplaySub( 541 ) = "1EEEU"
DisplaySub( 542 ) = "1EEFu"
DisplaySub( 543 ) = "1EF0U"
DisplaySub( 544 ) = "1EF1u"
DisplaySub( 545 ) = "1EF2Y"
DisplaySub( 546 ) = "1EF3y"
DisplaySub( 547 ) = "1EF4Y"
DisplaySub( 548 ) = "1EF5y"
DisplaySub( 549 ) = "1EF6Y"
DisplaySub( 550 ) = "1EF7y"
DisplaySub( 551 ) = "1EF8Y"
DisplaySub( 552 ) = "1EF9y"
DisplaySub( 553 ) = "1EFALL"
DisplaySub( 554 ) = "1EFBll"
DisplaySub( 555 ) = "1EFEY"
DisplaySub( 556 ) = "1EFFy"
DisplaySub( 557 ) = "2018" & SINGLE_QUOTE
DisplaySub( 558 ) = "2019" & SINGLE_QUOTE
DisplaySub( 559 ) = "201A" & SINGLE_QUOTE
DisplaySub( 560 ) = "201B" & SINGLE_QUOTE
DisplaySub( 561 ) = "201C" & DOUBLE_QUOTE
DisplaySub( 562 ) = "201D" & DOUBLE_QUOTE
DisplaySub( 563 ) = "201E" & DOUBLE_QUOTE
DisplaySub( 564 ) = "201F" & DOUBLE_QUOTE
DisplaySub( 565 ) = "2032" & SINGLE_QUOTE
DisplaySub( 566 ) = "2033" & DOUBLE_QUOTE
DisplaySub( 567 ) = "2035" & SINGLE_QUOTE
DisplaySub( 568 ) = "2036" & DOUBLE_QUOTE
DisplaySub( 569 ) = "2039<"
DisplaySub( 570 ) = "203A>"

End Sub

'****************************************************************************************

Sub FillUnicodeSubArray

' This array finds substitutes for pasting into a record some characters in the General
' Punctuation (U+2000-U+206F) and Alphabetic Presentation Forms (U+FB00-U+FB4F) blocks,
' as well as making sure the last four characters from the Specials (U+FFF0-U+FFFF) block
' don't get added.

UnicodeSub(  0 ) = "2000 " 'General Punctuation
UnicodeSub(  1 ) = "2001 "
UnicodeSub(  2 ) = "2002 "
UnicodeSub(  3 ) = "2003 "
UnicodeSub(  4 ) = "2004 "
UnicodeSub(  5 ) = "2005 "
UnicodeSub(  6 ) = "2006 "
UnicodeSub(  7 ) = "2008 "
UnicodeSub(  8 ) = "2009 "
UnicodeSub(  9 ) = "200A "
UnicodeSub( 10 ) = "200B"
UnicodeSub( 11 ) = "200E"
UnicodeSub( 12 ) = "2010-"
UnicodeSub( 13 ) = "2011-"
UnicodeSub( 14 ) = "2012-"
UnicodeSub( 15 ) = "2013-"
UnicodeSub( 16 ) = "2014--"
UnicodeSub( 17 ) = "2015--"
UnicodeSub( 18 ) = "2018" & SINGLE_QUOTE
UnicodeSub( 19 ) = "2019" & SINGLE_QUOTE
UnicodeSub( 20 ) = "201A" & SINGLE_QUOTE
UnicodeSub( 21 ) = "201B" & SINGLE_QUOTE
UnicodeSub( 22 ) = "201C" & DOUBLE_QUOTE
UnicodeSub( 23 ) = "201D" & DOUBLE_QUOTE
UnicodeSub( 24 ) = "201E" & DOUBLE_QUOTE
UnicodeSub( 25 ) = "201F" & DOUBLE_QUOTE
UnicodeSub( 26 ) = "2024."
UnicodeSub( 27 ) = "2025.."
UnicodeSub( 28 ) = "2026..."
UnicodeSub( 29 ) = "2028"
UnicodeSub( 30 ) = "2029"
UnicodeSub( 31 ) = "202A"
UnicodeSub( 32 ) = "202B"
UnicodeSub( 33 ) = "202C"
UnicodeSub( 34 ) = "202D"
UnicodeSub( 35 ) = "202E"
UnicodeSub( 36 ) = "202F"
UnicodeSub( 37 ) = "203C!!"
UnicodeSub( 38 ) = "203D!?"
UnicodeSub( 39 ) = "2043-"
UnicodeSub( 40 ) = "2044/"
UnicodeSub( 41 ) = "2045["
UnicodeSub( 42 ) = "2046]"
UnicodeSub( 43 ) = "2047??"
UnicodeSub( 44 ) = "2048?!"
UnicodeSub( 45 ) = "2049!?"
UnicodeSub( 46 ) = "204E*"
UnicodeSub( 47 ) = "2053~"
UnicodeSub( 48 ) = "205F "
UnicodeSub( 49 ) = "20A8RI"
UnicodeSub( 50 ) = "FB00ff" 'Alphabetic Presentation Forms
UnicodeSub( 51 ) = "FB01fi"
UnicodeSub( 52 ) = "FB02fl"
UnicodeSub( 53 ) = "FB03ffi"
UnicodeSub( 54 ) = "FB04ffl"
UnicodeSub( 55 ) = "FB05st"
UnicodeSub( 56 ) = "FB06st"
UnicodeSub( 57 ) = "FEFF"
UnicodeSub( 58 ) = "FFFC"
UnicodeSub( 59 ) = "FFFD"
UnicodeSub( 60 ) = "FFFE"
UnicodeSub( 61 ) = "FFFF"

End Sub

'****************************************************************************************

Sub InitialDialogSetup( DefaultAddFieldOption% )

' The initial setup of the dialog box is determined chiefly by whether or not carriage
' returns are present in the de-formatted text. If none have been found, the default
' option is to add the copied text as a string; but the choice of adding the text as a
' single new field is also available. If at least one carriage return has been found, the
' default option is to add the copied lines as new fields; but of course the choice of
' adding the copied text as a string or a single new field, converting line breaks, is
' always available. Note that one or more new fields can be added no matter where the
' cursor is placed, but a simple string can't be added if the cursor is not in a field
' with space to put it.

Dim TempString$

Dim i As Integer

DlgValue   "OBGroup_ConvertOrAddTag", SpaceOrDash%

DlgText    "TB1_Tag",                 ""
DlgText    "TB2_Indicator1",          ""
DlgText    "TB3_Indicator2",          ""

If CursorPosition% = 0 Then
    DlgText    "OB1_PasteAsString",       "S&tring, at cursor position"
    DlgEnable  "OB1_PasteAsString",       DISABLED
  ElseIf CursorPosition% < 6 Then
    DlgText    "OB1_PasteAsString",       "S&tring, at end of field"
  Else
    DlgText    "OB1_PasteAsString",       "S&tring, at cursor position"
End If

Select Case DefaultAddFieldOption%

  Case SIMPLE_STRING, SINGLE_FIELD

    If CRFound Then
        DlgEnable  "ConvertPrompt",           ENABLED
        DlgEnable  "OB4_ConvertToSpaces",     ENABLED
        DlgEnable  "OB5_ConvertToDashes",     ENABLED
      Else
        DlgEnable  "ConvertPrompt",           DISABLED
        DlgEnable  "OB4_ConvertToSpaces",     DISABLED
        DlgEnable  "OB5_ConvertToDashes",     DISABLED
    End If

    If SpaceOrDash% = aSPACE Then
        PreviewString$ = MakeDisplayable( FieldStore( aSINGLE_FIELD, aSPACE ) )
      Else
        PreviewString$ = MakeDisplayable( FieldStore( aSINGLE_FIELD, aDASH ) )
    End If

    If DefaultAddFieldOption% = SIMPLE_STRING Then
        DlgEnable  "CB_BlankTag",             DISABLED
        DlgEnable  "TB1_Tag",                 DISABLED
        DlgEnable  "TB2_Indicator1",          DISABLED
        DlgEnable  "TB3_Indicator2",          DISABLED
        DlgFocus   "OB1_PasteAsString"
      Else
        DlgEnable  "CB_BlankTag",             ENABLED
        DlgEnable  "TagPrompt",               ENABLED
        DlgEnable  "TB1_Tag",                 ENABLED
        DlgEnable  "TB2_Indicator1",          ENABLED
        DlgEnable  "TB3_Indicator2",          ENABLED
        DlgValue   "OBGroup_PasteChoices",    SINGLE_FIELD
        If TaggedFieldsLikely Then
            DlgFocus   "OK"
          Else
            DlgFocus   "TB1_Tag"
        End If
    End If

  Case MULTI_FIELDS

    DlgEnable  "ConvertPrompt",           DISABLED
    DlgEnable  "OB3_PasteFields",         ENABLED
    DlgEnable  "OB4_ConvertToSpaces",     DISABLED
    DlgEnable  "OB5_ConvertToDashes",     DISABLED
    DlgValue   "OBGroup_PasteChoices",    MULTI_FIELDS
    DlgEnable  "TagPrompt",               ENABLED
    DlgEnable  "TB1_Tag",                 ENABLED
    DlgEnable  "TB2_Indicator1",          ENABLED
    DlgEnable  "TB3_Indicator2",          ENABLED
    If TaggedFieldsLikely Then
        DlgFocus   "OK"
      Else
        DlgFocus   "TB1_Tag"
    End If

    PreviewString$ = ""
    For i = 0 To UBound( FieldStore, 2 )
      TempString$    = MakeDisplayable( FieldStore( aMULTI_FIELDS, i ) )
      PreviewString$ = PreviewString$ & TempString$ & CR
    Next i

End Select

End Sub

'****************************************************************************************

Function GetIndicator( WhichIndicator$ ) As String

Dim TempString$

Select Case WhichIndicator$
  Case "TB2_Indicator1"
    TempString$ = Trim$( DlgText( "TB2_Indicator1" ) )
  Case "TB3_Indicator2"
    TempString$ = Trim$( DlgText( "TB3_Indicator2" ) )
End Select

If TempString$ = "" Then
    TempString$ = " "
  Else
    If TempString$ Like "[! 0-9]" Then
        TempString$ = "#"
    End If
End If

GetIndicator = TempString$

End Function

'****************************************************************************************

Function GetUnicodeString() As String

Const INTEGER_RANGE       As Long = 65536 '-32,768 to 32,767

Dim ActiveWindowHandle    As Long
Dim CharToAdd$
Dim ClipboardCharsDim%
Dim ClipboardDataHandle   As Long
Dim ClipboardDataLocation As Long
Dim CodePoint%
Dim LengthOfField%
Dim UniCodePoint$
Dim TempString$

Dim ClipboardClose

Dim i As Integer

Dim ClipboardChars() As Integer

ActiveWindowHandle = GetActiveWindow()
If OpenClipboard( ActiveWindowHandle ) = FALSE Then
    GetUnicodeString = CLIPBOARD_ERROR & "Sorry, the contents of the Clipboard could not be accessed."
    ClipboardClose   = CloseClipboard()
    Exit Function
End If

ClipboardDataHandle = GetClipboardData( UNI_CHAR_TEXT )
If ClipboardDataHandle = 0& Then
    GetUnicodeString = CLIPBOARD_ERROR & "Sorry, the macro failed to get Clipboard data."
    ClipboardClose   = CloseClipboard()
    Exit Function
End If
ClipboardDataLocation = GlobalLock( ClipboardDataHandle )

' Copy the Clipboard contents to a prepared array.

On Error Resume Next
LengthOfField% = GetStringLength( ClipboardDataLocation )
If Err > 0 Then
    If Err = 6 Then
        GetUnicodeString = CLIPBOARD_ERROR & "There is too much data on the Clipboard!"
      Else
        GetUnicodeString = CLIPBOARD_ERROR & "Sorry, an unexpected error occurred."
    End If
    ClipboardClose = CloseClipboard()
    Exit Function
End If
If LengthOfField% > 0 Then
    ClipboardCharsDim% = ( LengthOfField% - 1 ) * 2
    ReDim ClipboardChars( ClipboardCharsDim% )
    CopyMemory ClipboardChars( 0 ), ByVal ClipboardDataLocation, ClipboardCharsDim% + 2
  Else
    GetUnicodeString = CLIPBOARD_ERROR & "Sorry, this macro works only when there is text on the Clipboard to paste in a bibliographic record."
    Exit Function
End If

GlobalUnlock( ClipboardDataHandle )
ClipboardClose = CloseClipboard()

' Build a string of characters from the numbers in the array. As type "integer", they
' range from -32,768 to 32,767. Numbers 0 to 127 encode plain ASCII characters, which are
' added to the string as themselves. All other numbers are converted to hexadecimal by
' means of the BASIC "Hex" function. Decimal numbers from 128 to 32,767 are directly
' converted to hexadecimal 0080 to 7FFF. Negative decimal numbers are made positive by
' adding them to 65,536, so the range -32,768 to -1 becomes the range 32,768 to 65,535.
' The "Hex" function converts those numbers to the hexadecimal range 8000 to FFFF.
' Finally, the hexadecimal numbers are transformed into Numeric Character References,
' with strings of two or three digits padded with leading zeros to make each string four
' characters in length; then that NCR is added to the character string.

For i = 0 To ClipboardCharsDim%
  CodePoint% = ClipboardChars( i )
  If CodePoint% = 0 Then
      Exit For
    ElseIf CodePoint% > 0 And CodePoint% < 128 Then
      CharToAdd$ = Chr$( CodePoint% )
    ElseIf CodePoint% = 450 Then
      CharToAdd$ = UNI_DELIMITER
    ElseIf CodePoint% <> 0 Then
      If CodePoint% > 127 Then
          UniCodePoint$ = Hex( ClipboardChars( i ) )
          If Len( UniCodePoint$ ) < 4 Then
             UniCodePoint$ = String$( 4 - Len( UniCodePoint$ ), "0" ) & UniCodePoint$
          End If
        Else
          UniCodePoint$ = Hex( INTEGER_RANGE + CodePoint% )
      End If
      CharToAdd$ = "&#x" & UniCodePoint$ & ";"
  End If
  TempString$ = TempString$ & CharToAdd$
  CharToAdd$  = ""
Next i

GetUnicodeString = TempString$

End Function

'****************************************************************************************

Function MakeDisplayable( InString$ ) As String

Dim Candidate$
Dim CharT$
Dim Compare%
Dim High%
Dim Low%
Dim Match%
Dim Middle%
Dim Target$
Dim TempString$
Dim DecVal%

Dim i As Integer, j As Integer, p As Integer

i = 1
Do
  CharT$ = Mid$( InString$, i, 1 )
  If CharT$ = "&" Then
      If Mid$( InString$, i, 3 ) = "&#x" Then
          p = InStr( i + 1, InString$, ";" )
          If ( p - i ) < 10 Then
              CharT$  = Mid$( InString$, i, p - i + 1 )
              Target$ = Mid$( CharT$, 4, 4 )
              DecVal% = Val( "&H" & Target$ )
              If Target$ = "02BF" Then           'OCLC doesn't like the
                  CharT$ = "&#x02BB;"            ' Unicode alef and ayn
                ElseIf Target$ = "02BE" Then     ' characters and wants to use
                  CharT$ = "&#x02BC;"            ' modifier letters instead.
                ElseIf Target$ = "01C2" Then
                  CharT$ = DOLLAR_DELIMITER
                ElseIf DecVal% > 159 And DecVal% < 256 Then
                  CharT$ = Chr$( DecVal% )
                Else
                  Low%  = 0
                  High% = DISPLAY_SUB_SIZE
                  Do While Low% <= High%
                    Middle%    = Int( ( High% + Low% ) / 2 )
                    Candidate$ = Left$( DisplaySub( Middle% ), 4 )
                    Compare%   = StrComp( Candidate$, Target$ )
                    Select Case Compare%
                      Case -1
                        Low%   = Middle% + 1
                      Case 0
                        Match% = Middle%
                        Exit Do
                      Case 1
                        High%  = Middle% - 1
                    End Select
                  Loop
                  If Candidate$ = Target$ Then
                      CharT$ = Mid$( DisplaySub( Match% ), 5 )
                    Else
                      If DecVal% = 768 Or _                     'The dialog box character set can't show most
                         DecVal% > 771 And DecVal% < 776 Or _   ' combining characters, such as the macron,
                         DecVal% = 777 Or DecVal% = 779 Or _    ' breve, candrabindu, etc., so these are
                         DecVal% > 780 And DecVal% < 807 Or _   ' simply omitted from the display string.
                         DecVal% > 807 And DecVal% < 880 Then
                          CharT$ = ""
                        Else
                          CharT$ = "|"
                      End If
                  End If
              End If
              i = p
          End If
      End If
    ElseIf CharT$ Like "[AaCcEeIiNnoOUuYy]" Then
      For j = 0 To 52
        If Mid$( InString$, i, 9 ) = Left$( Combined ( j ), 9 ) Then
            CharT$ = Mid$( Combined( j ), 10 )
            i = i + 8
            Exit For
        End If
      Next j
  End If
  TempString$ = TempString$ & CharT$
  i = i + 1
Loop Until i > Len( InString$ )

MakeDisplayable = TempString$

End Function

'****************************************************************************************

Function Replace( InputString$, Replacement$, Remove$ ) As String

' This function replaces "Remove$" in "InputString" with "Replacement$," except in the
' special case when a delimiter is passed to it. In that case, add a space after any
' subfield code.

Dim Start%

Dim p As Integer

Start% = 1

If Remove$ = UNI_DELIMITER Then
    Do
      p = InStr( Start%, InputString$, Remove$ )
      If p <> 0 Then
          InputString$ = Left$( InputString$, p + 8 ) & " " & Mid$( InputString$, p + 9 )
      End If
      Start% = p + 2
    Loop Until p = 0
    InputString$ = Replace( InputString$, " ", TWO_SPACES )
  Else
    Do
      p = InStr( InputString$, Remove$ )
      If p <> 0 Then
          InputString$ = Left$( InputString$, p - 1 ) & Replacement$ & Mid$( InputString$, p + Len( Remove$ ) )
      End If
    Loop Until p = 0
End If

Replace = InputString$

End Function

'****************************************************************************************

Function Dialog1ControlFunction( Id$, Action%, SValue& )

' This function sets up the dialog box for choosing whether to add the copied text as a
' string in an existing field or as a new field, and also whether to convert carriage
' returns to spaces or to dashes. It also manages input for adding new fields.

Const CHECKED         As Integer = 1
Const CONTROL_CHANGE  As Integer = 2
Const FOCUS_CHANGE    As Integer = 4
Const IDLE_STATE      As Integer = 5
Const INITIALIZE      As Integer = 1
Const KEEP_DLG_OPEN   As Integer = -1
Const UNCHECKED       As Integer = 0

Dim CharT$
Dim ControlWithFocus$
Dim Indicator1$
Dim Indicator2$
Dim MultipleFieldsString$
Dim TempField$

Dim i As Integer, x As Integer

Static CurrVal$
Static Indicators$
Static LastValidInd1$
Static LastValidInd2$
Static LastValidTag$
Static PrevPasteAsChoice%
Static PrevPreviewString$
Static PrevVal$
Static Tag$

Static BadInput              : BadInput = FALSE

Select Case Action%

  Case INITIALIZE

' If multiple lines have been copied, the dialog box opens with the default option being
' to add new fields. Otherwise, that option is disabled, and the choices offered are to
' add the copied text as a string or as a new field, and whether to change any line
' breaks to spaces or dashes.

    DlgValue   "OBGroup_ConvertOrAddTag", SpaceOrDash%
    If DefaultAddFieldOption% < 2 And CRFound = FALSE Then
        DlgEnable  "OB3_PasteFields",         DISABLED
      Else
        DlgEnable  "OB3_PasteFields",         ENABLED
    End If
    InitialDialogSetup( DefaultAddFieldOption% )
    PrevPasteAsChoice% = DefaultAddFieldOption%


  Case CONTROL_CHANGE

' For any change in the dialog box, the first action is to get the values from the input
' text boxes.

    Tag$        = DlgText( "TB1_Tag" )
    Indicator1$ = DlgText( "TB2_Indicator1" )
    Indicator2$ = DlgText( "TB3_Indicator2" )
    If Tag$ <> "" Then
        If Indicator1$ = "" Then Indicator1$ = " "
        If Indicator2$ = "" Then Indicator2$ = " "
    End If

    Select Case Id$

      Case "CB_BlankTag"

' Putting a check in the checkbox automatically adds a blank set of tag and indicators,
' and clears anything already entered in those text boxes. Removing the check deletes the
' blank set and restores the copied text to its original state when the macro was
' invoked.

        DlgText    "TB1_Tag",                 ""
        DlgText    "TB2_Indicator1",          ""
        DlgText    "TB3_Indicator2",          ""
        If DlgValue( "CB_BlankTag" ) = CHECKED Then
            BlankTag = TRUE
            Tag$        = "   "
            Indicators$ = "  "
            If DlgValue( "OBGroup_PasteChoices" ) = 1 Then
                If DlgValue( "OBGroup_ConvertOrAddTag" ) = 0 Then
                    SpaceOrDash% = aSPACE
                  Else
                    SpaceOrDash% = aDASH
                End If
                PreviewString$ = BLANK_TAG_INDICATORS & FieldStore( aSINGLE_FIELD, SpaceOrDash% )
              Else
                For i = 0 To UBound( FieldStore, 2 )
                  TempField$            = BLANK_TAG_INDICATORS & FieldStore( aMULTI_FIELDS, i )
                  MultipleFieldsString$ = MultipleFieldsString$ & TempField$ & CR
                Next i
                If Right$( MultipleFieldsString$, 1 ) = CR Then
                    MultipleFieldsString$ = Left$( MultipleFieldsString$, Len( MultipleFieldsString$ ) - 1 )
                End If
                PreviewString$ = MakeDisplayable( MultipleFieldsString$ )
            End If
          Else
            BlankTag    = FALSE
            Tag$        = ""
            Indicators$ = ""
            InitialDialogSetup( PrevPasteAsChoice% )
        End If

      Case "OB1_PasteAsString"
        InitialDialogSetup( SIMPLE_STRING )
        DlgEnable  "TagPrompt",               DISABLED
        DlgEnable  "TB1_Tag",                 DISABLED
        DlgEnable  "TB2_Indicator1",          DISABLED
        DlgEnable  "TB3_Indicator2",          DISABLED
        PrevPasteAsChoice% = SIMPLE_STRING

      Case "OB2_PasteAsField"
        InitialDialogSetup( SINGLE_FIELD )
        LastValidTag$      = ""
        LastValidInd1$     = ""
        PrevPasteAsChoice% = SINGLE_FIELD

      Case "OB3_PasteFields"
        InitialDialogSetup( MULTI_FIELDS )
        LastValidTag$      = ""
        LastValidInd1$     = ""
        PrevPasteAsChoice% = MULTI_FIELDS

      Case "OB4_ConvertToSpaces"
        SpaceOrDash%   = aSPACE
        PreviewString$ = Tag$ & Indicator1$ & Indicator2$ & FieldStore( aSINGLE_FIELD, SpaceOrDash% )

      Case "OB5_ConvertToDashes"
        SpaceOrDash%   = aDASH
        PreviewString$ = Tag$ & Indicator1$ & Indicator2$ & FieldStore( aSINGLE_FIELD, SpaceOrDash% )

    End Select

    PreviewString$ = MakeDisplayable( PreviewString$ )

    If Tag$ = "" Then LastValidTag$ = ""


  Case FOCUS_CHANGE

' When a text box has the focus, empty any content.

    Select Case Id$

      Case "TB1_Tag"
        DlgText    "TB1_Tag",                 ""
        DlgValue   "CB_BlankTag",             UNCHECKED
        BlankTag = FALSE
        If SValue& > 6 Then LastValidTag$ =   ""

      Case "TB2_Indicator1"
        DlgText    "TB2_Indicator1",          ""

      Case "TB3_Indicator2"
        DlgText    "TB3_Indicator2",          ""

    End Select


  Case IDLE_STATE

' Continuously monitor input in the text boxes to accept only digits and spaces. As valid
' characters are entered in the text boxes, display the results in the preview string.

    ControlWithFocus$ = DlgFocus()

    Select Case ControlWithFocus$

      Case "TB1_Tag"

        CurrVal$ = Trim$( DlgText( "TB1_Tag" ) )
        If CurrVal$ <> "" Then
            If BlankTag Then
                CurrVal$ = "   "
                x        = 3
                BlankTag = TRUE
                DlgEnable  "TB2_Indicator1",          DISABLED
                DlgEnable  "TB3_Indicator2",          DISABLED
              Else
                x = Len( CurrVal$ )
                For i = 1 To x
                  CharT$ = Mid$( CurrVal$, i, 1 )
                  If CharT$ Like "[! 0-9]" Then
                      BadInput = TRUE
                      Exit For
                  End If
                Next i
            End If
        End If
        If x < 4 And BadInput = FALSE Then
            If CurrVal$ <> PrevVal$ Then
                If DlgValue( "OBGroup_PasteChoices" ) = 1 Then
                    If DlgValue( "OBGroup_ConvertOrAddTag" ) = 0 Then
                        SpaceOrDash% = aSPACE
                      Else
                        SpaceOrDash% = aDASH
                    End If
                    TempField$     = FieldStore( aSINGLE_FIELD, SpaceOrDash% )
                    If CurrVal$ <> "" Then
                        TempField$ = CurrVal$ & GetIndicator( "TB2_Indicator1" ) & GetIndicator( "TB3_Indicator2" ) & TempField$
                    End If
                    PreviewString$ = MakeDisplayable( TempField$ )
                  Else
                    If CurrVal$ = "" Then
                        For i = 0 To UBound( FieldStore, 2 )
                          TempField$            = FieldStore( aMULTI_FIELDS, i )
                          MultipleFieldsString$ = MultipleFieldsString$ & TempField$ & CR
                        Next i
                      Else
                        For i = 0 To UBound( FieldStore, 2 )
                          TempField$            = CurrVal$ & GetIndicator( "TB2_Indicator1" ) & GetIndicator( "TB3_Indicator2" ) & FieldStore( aMULTI_FIELDS, i )
                          MultipleFieldsString$ = MultipleFieldsString$ & TempField$ & CR
                        Next i
                    End If
                    If Right$( MultipleFieldsString$, 1 ) = CR Then
                        MultipleFieldsString$ = Left$( MultipleFieldsString$, Len( MultipleFieldsString$ ) - 1 )
                    End If
                    PreviewString$ = MakeDisplayable( MultipleFieldsString$ )
                End If
            End If
          Else
            DlgText    "TB1_Tag",                 PrevVal$
            CurrVal$ = PrevVal$
            x = x - 1
        End If
        If LastValidTag$ = "" Then
            PrevVal$ = CurrVal$
            If x = 3 Then
                Tag$ = CurrVal$
                LastValidTag$ = CurrVal$
                If BlankTag = FALSE Then
                    DlgEnable  "TB2_Indicator1",          ENABLED
                    DlgEnable  "TB3_Indicator2",          ENABLED
                    DlgFocus   "TB2_Indicator1"
                End If
            End If
        End If

      Case "TB2_Indicator1", "TB3_Indicator2"

        If ControlWithFocus$ = "TB2_Indicator1" Then

            CurrVal$ = Trim$( DlgText( "TB2_Indicator1" ) )
            If CurrVal$ Like "[ 0-9]" Then
                Indicator1$ = CurrVal$
              ElseIf CurrVal$ = "" Then
                Indicator1$ = " "
              Else
                Indicator1$ = "#"
            End If
            If Indicator1$ = "#" Then
                DlgText    "TB2_Indicator1",          ""
              Else
                Indicators$ = Indicator1$ & GetIndicator( "TB3_Indicator2" )
                If LastValidInd1$ <> CurrVal$ And CurrVal$ <> "" Then
                    DlgFocus   "TB3_Indicator2"
                End If
                LastValidInd1$ = CurrVal$
            End If

          Else

            CurrVal$ = Trim$( DlgText( "TB3_Indicator2" ) )
            If CurrVal$ Like "[ 0-9]" Then
                Indicator2$ = CurrVal$
              ElseIf CurrVal$ = "" Then
                Indicator2$ = " "
              Else
                Indicator2$ = "#"
            End If
            If Indicator2$ = "#" Then
                DlgText    "TB3_Indicator2",          ""
              Else
                Indicators$ = GetIndicator( "TB2_Indicator1" ) & Indicator2$
                If LastValidInd2$ <> CurrVal$ And CurrVal$ <> "" Then
                    DlgFocus   "OK"
                End If
                LastValidInd1$ = CurrVal$
            End If

        End If

        If DlgValue( "OBGroup_PasteChoices" ) = SINGLE_FIELD Then
            If InStr( Indicators$, "#" ) = 0 Then
                If DlgValue( "OBGroup_ConvertOrAddTag" ) = 0 Then
                    SpaceOrDash% = aSPACE
                  Else
                    SpaceOrDash% = aDASH
                End If
                TempField$     = Tag$ & Indicators$ & FieldStore( aSINGLE_FIELD, SpaceOrDash% )
                PreviewString$ = MakeDisplayable( TempField$ )
              Else
                PreviewString$ = PrevPreviewString$
            End If
          ElseIf DlgValue( "OBGroup_PasteChoices" ) = MULTI_FIELDS Then
            If InStr( Indicators$, "#" ) = 0 Then
               For i = 0 To UBound( FieldStore, 2 )
                 TempField$            = Tag$ & Indicators$ & FieldStore( aMULTI_FIELDS, i )
                 MultipleFieldsString$ = MultipleFieldsString$ & TempField$ & CR
               Next i
               If Right$( MultipleFieldsString$, 1 ) = CR Then
                   MultipleFieldsString$ = Left$( MultipleFieldsString$, Len( MultipleFieldsString$ ) - 1 )
               End If
               PreviewString$ = MakeDisplayable( MultipleFieldsString$ )
             Else
               PreviewString$ = PrevPreviewString$
            End If
        End If

    End Select

    If PreviewString$ <> PrevPreviewString$ Then
        DlgText    "PreviewTextArea",           PreviewString$
        PrevPreviewString$ = PreviewString$
    End If

    Dialog1ControlFunction = KEEP_DLG_OPEN

End Select

End Function
'236488575
