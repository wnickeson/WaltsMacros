'MacroName:SearchAuthority5XX.2023.07
'MacroDescription:Helps search the related headings (5XX fields) in an authority record.
'
' This macro was written by Walter F. Nickeson,
' University of Rochester, Rochester, NY
' wnickeson@library.rochester.edu
'
' Last updated: 19 July 2023.
' Check for the latest versions of this and my other macros at
' https://github.com/wnickeson/WaltsMacros
' Please e-mail me with bug reports or to suggest improvements.
'
' This macro works for me with Connexion client 3.1 and Windows 11 Enterprise & 64-bit
' Windows 10 Pro, but no guarantees are promised or implied.
'
'****************************************************************************************
' How it works: Run this macro while viewing an online authority record (cursor position
' is irrelevant). The macro displays the searchable 5XX fields in the record, grouped by
' type of relationship to the authorized heading; select a heading to retrieve its
' authority record. The display spells out in words the nature of the relationship
' between the headings, which may be helpful if you can't remember the codes.
'
' These are the searchable headings: personal names (500), corporate and meeting names
' (510 and 511), uniform titles (530), topical terms (550), geographic names (551),
' general subject subdivisions (580), and form subdivisions (585). Excluded are genre
' headings (555), named events (547), chronological terms (548), medium of performance
' terms (562), and chronological subdivisions (582). These headings are not searchable
' because the macro language has no provisions for them. In the dialog box, the headings
' are grouped by type, according to the codes in subfield $w or terms in subfield $i. Up
' to three groups are displayed. The most common relationships--earlier and later
' headings for names, broader headings for subjects--are in the first group, if present.
' The second and third groups (if there are that many types of relationships) contain the
' remaining headings, presented in the order in which they appear in the record. Headings
' whose relationship to the 1XX field is not specified appear in the last group. If the
' headings represent more than three types of relationships, the last group consists of
' all the other relationships lumped together as "other."
'
' The search done by the macro is actually an expanded authority browse. This is because
' a search in the Authority File is actually a keyword search, and in the list of
' results, the heading that is the object of the search may be buried several screens
' deep, and must be sought page by page. A browse, on the other hand, produces a list as
' its result, with the searched heading at or near the top, and usually already selected
' for easy retrieval. Because the searched heading may not be the first item in the list,
' the macro searches the list for the matching heading. If the matching item is an
' authority record the macro is finished. Because several authority record windows may be
' opened and closed during the macro's execution, the screen will appear very active.
'
' For consistency's sake, all the browses are expanded, rather than simple, browses, even
' if there is no expanded term to use.
'
' The 5XX fields in authority records for juvenile subject headings (identified by "sj"
' as the LCCN prefix in field 010) are searched just as regular LC subject headings,
' except that only juvenile authority records are retrieved.
'****************************************************************************************

Option Explicit

Declare Sub FillDialogBoxArrays( WhichArray%, InArray() As String, Index%, ArrayLabel$ )

Declare Function AssignLabels( InString$ )                              As String
Declare Function GetHeading$( InString$, Tag$, Reason%, ExpandedTerm$ ) As String
Declare Function GetSubfieldData( n%, FieldData$, SubfieldCode$ )       As String
Declare Function ConvertTo8859( InputString$ )                        As String
Declare Function Normalize( InString$, Tag$ )                           As String
Declare Function Plural( Label$, n% )                                   As String

Declare Function Dialog1ControlFunction( Id$, Action%, SValue& )

Global CS As Object

Global Const aDISPLAY_HEADING As Integer = 3
Global Const aHEADING_TAG     As Integer = 4
Global Const aRAW_HEADING     As Integer = 2
Global Const aRELATIONSHIP    As Integer = 1
Global Const aRELATION_INFO   As Integer = 0
Global Const DISPLAY          As Integer = 0
Global Const SEARCH           As Integer = 1

Global Array1Count%
Global Array2Count%
Global Array3Count%
Global Count5XX%
Global LastSubfield$
Global SearchCount%
Global SearchTerm$
Global WaltsMacros$

Global DELIMITER As String*1

Global Childrens
Global NameAsSubject

Global a5XXFields() As String

'****************************************************************************************

Sub Main

Const CRITICAL_MESSAGE          As Integer = 16
Const DLG_STATEMENT_CANCEL      As Integer = 102

Const AUTHORITY_FILE_BRIEF_LIST As Integer = 10
Const AUTHORITY_RECORD          As Integer = 3
Const SUBSCRIPT_OUT_OF_RANGE    As Integer = 9   'The Error value returned when the upper bound of an uninitialized array is
                                                 ' requested.

On Error Resume Next
Set CS = GetObject( , "Connex.Client" )
On Error GoTo 0
If CS Is Nothing Then Set CS = CreateObject( "Connex.Client" )

DELIMITER = Chr$( 223 )

Dim LINE_FEED  As String*1   : LINE_FEED  = Chr$( 010 )
Dim NO_TAG     As String*3   : NO_TAG     = "000"
Dim SUBFIELD_W As String*2   : SUBFIELD_W = DELIMITER & "w"

Dim Array1Label$
Dim Array2Label$
Dim Array3Label$
Dim ArrayNumber%
Dim EstablishedHeading$
Dim ExpandedTerm$
Dim FieldData$
Dim HeadingTag$
Dim IndexAll5XX%
Dim ListSearchString$
Dim Matches%
Dim RawHeading$
Dim RelatedHeading$
Dim RelationshipInformation$
Dim SearchLabel$
Dim Start%
Dim Tag$
Dim TempString$
Dim Temp_DISPLAY_HEADING$
Dim Temp_HEADING_TAG$
Dim Temp_RAW_HEADING$
Dim Temp_RELATIONSHIP$
Dim Temp_RELATION_INFO$
Dim UnsearchableFields$
Dim UnsearchableFieldsCount%
Dim UnsearchableFieldsTagString%
Dim UnsearchableMessage$

Dim FoundField
Dim ListSearchResults
Dim OpenSelectedItem
Dim Swapped

Dim i As Integer, p As Integer

Dim Array1() As String
Dim Array2() As String
Dim Array3() As String

Childrens     = FALSE
NameAsSubject = FALSE
WaltsMacros$  = "[Walt's macros] Extras1:SearchAuthority5XX"

' First, make sure an online authority record is open.

If CS.ItemType <> AUTHORITY_RECORD Then
    MsgBox "Sorry, this macro works only in an online authority record.", CRITICAL_MESSAGE, WaltsMacros$
    Exit Sub
End If

' Then check if the record is for a children's subject heading.

If CS.GetField( "010", 1, FieldData$ ) Then
    If Mid$( FieldData$, 6, 2 ) = "sj" Then
        Childrens = TRUE
    End If
End If

' Go through the record, line by line, collecting the 5XX headings in the main array.
' This pass also picks up the 1XX heading and fixes it for proper display, by discarding
' or finding substitutes for characters not displayable in dialog boxes.

Count5XX% = -1
i = 1
Do
  FoundField = CS.GetFieldLine( i, FieldData$ )
  If FoundField Then
      Tag$ = Left$( FieldData$, 3 )
      If Left$( Tag$, 1 ) Like "1" Then
          EstablishedHeading$ = Mid$( FieldData$, 6 )
          EstablishedHeading$ = ConvertTo8859( EstablishedHeading$ )
          Start% = 1
          p = InStr( Start%, EstablishedHeading$, "&" )
          If p > 0 Then
              EstablishedHeading$ = Left$( EstablishedHeading$, p ) & "&" & Mid$( EstablishedHeading$, p + 1 )
              Start% = p + 2
          End If
          If Childrens Then
              EstablishedHeading$ = EstablishedHeading$ & "  [CHILDREN'S]"
          End If
      End If

' For each 5XX heading, add a subfield $a at the beginning to ease processing later.
' However, leave 58X subdivisions with their initial subfield alone.

      If Left$( Tag$, 1 ) = "5" Then

' The OCLC macro language can't search genre headings, and there are some other 5XX
' fields defined but not yet implemented. If unsearchable headings comprise the whole set
' of 5XX fields, the macro can't search anything, and must quit. However, if searchable
' headings are also present, the unsearchable ones must be omitted. Keep track of those
' so a note can be provided explaining the omission.

          Select Case Tag$

            Case "547", "548", "555", "562", "582"
              If InStr( UnsearchableFields$, Tag$ ) = 0 Then
                  UnsearchableFields$       = UnsearchableFields$ & Tag$
                  UnsearchableFieldsCount%  = UnsearchableFieldsCount% + 1
              End If

            Case Else
              If Mid$( FieldData$, 6, 1 ) <> DELIMITER Then
                  FieldData$ = DELIMITER & "a " & Mid$( FieldData$, 6 )
                Else
                  FieldData$ = Mid$( FieldData$, 6 )
              End If

' Look for a subfield $w in each 5XX field. If present, it can contain a single-letter
' code or a string of codes. If the single letter is not "r," it is the old code for
' earlier, later, broader, or narrower (this last code provided for but not implemented
' by LC). The code "r" means that the relationship is named in subfield $i. If a string
' of codes is present, it begins with "n" and simply means, for purposes of this macro,
' that the relationship between the headings is not identified.

              If InStr( FieldData$, SUBFIELD_W ) Then
                  RelationshipInformation$ = GetSubfieldData( 1, FieldData$, "w" )
                  If RelationshipInformation$ = "r" Then
                      RelationshipInformation$ = GetSubfieldData( 1, FieldData$, "i" )
                    ElseIf Left$( RelationshipInformation$, 1 ) = "n" Then
                      RelationshipInformation$ = "z"
                  End If
                Else
                  RelationshipInformation$ = "z"
              End If

' Load the main array with the information collected.

              Count5XX%                                 = Count5XX% + 1
              ReDim Preserve a5XXFields( aHEADING_TAG, Count5XX% )
              TempString$                               = AssignLabels( RelationshipInformation$ )
              a5XXFields( aRELATION_INFO, Count5XX% )   = Left$( TempString$, 1 )
              a5XXFields( aRELATIONSHIP, Count5XX% )    = Mid$( TempString$, 2 )
              RelatedHeading$                           = GetHeading( FieldData$, Tag$, DISPLAY, ExpandedTerm$ )
              a5XXFields( aRAW_HEADING, Count5XX% )     = RelatedHeading$
              a5XXFields( aDISPLAY_HEADING, Count5XX% ) = ConvertTo8859( RelatedHeading$ )
              a5XXFields( aHEADING_TAG, Count5XX% )     = Tag$
          End Select
      End If
  End If
  i = i + 1
Loop Until FoundField = FALSE

' The length of the unsearchable fields tag string tells how many unique unsearchable
' fields there are. (UnsearchableFieldsCount% is a count all occurrences of unsearchable
' 5XX fields, unique or not.)

UnsearchableFieldsTagString% = Len( UnsearchableFields$ ) / 3

' Prepare feedback messages. Name any unsearchable 5XX fields as a courtesy. First is the
' case of no searchable 5XX fields.

If Count5XX% < 0 Then

    Select Case UnsearchableFieldsTagString%

      Case 0
        UnsearchableMessage$ = "This authority record contains no 5XX fields to search."

      Case 1
        If UnsearchableFieldsCount% = 1 Then
            UnsearchableMessage$ = "Sorry, this macro can't search the " & UnsearchableFields$ & " field."
          ElseIf UnsearchableFieldsCount% > 1 Then
            UnsearchableMessage$ = "Sorry, this macro can't search the " & UnsearchableFields$ & " fields."
        End If

      Case Else
        UnsearchableMessage$ = "Sorry, this macro can't search the 5XX fields."

    End Select

    MsgBox UnsearchableMessage$, CRITICAL_MESSAGE, WaltsMacros$
    Exit Sub

  Else

' Second is the case of a mix of searchable and unsearchable fields.

    Select Case UnsearchableFieldsTagString%

      Case 1
        UnsearchableMessage$ = "The " & UnsearchableFields$ & " field can't be searched."
      Case 2
        UnsearchableMessage$ = "The " & Left$( UnsearchableFields$, 3 ) & " and " & Mid$( UnsearchableFields$, 4, 3 ) & " fields can't be searched."
      Case 3
        UnsearchableMessage$ = "The " & Left$( UnsearchableFields$, 3 ) & ", " & Mid$( UnsearchableFields$, 4, 3 ) & ", and " & Mid$( UnsearchableFields$, 7, 3 ) & " fields can't be searched."
      Case 4
        UnsearchableMessage$ = "The " & Left$( UnsearchableFields$, 3 ) & ", " & Mid$( UnsearchableFields$, 4, 3 ) & ", " & Mid$( UnsearchableFields$, 7, 3 ) & ", and " & Mid$( UnsearchableFields$, 7, 3 ) & " fields can't be searched."

    End Select

End If

' With the unsearchable headings (if any) taken care of, move on to the ones to search.
' If the main array contains more than one term, sort them so the common terms appear
' first. A simple bubble sort suffices to order them by the single-letter code in the
' first element of each row, which was assigned by the function "AssignLabels." Headings
' with the same code are not further sorted, and because of the type of sort, remain in
' the order in which they appear in the record. Even if the main array contains only one
' term, continue with the macro, rather than searching it immediately, simply so it can
' be displayed and its relationship put into words from a code.

If UBound( a5XXFields, 2 ) > 0 Then
    Do
      Swapped = FALSE
      For i = 0 To Count5XX% - 1
        If a5XXFields( aRELATION_INFO, i ) > a5XXFields( aRELATION_INFO, i + 1 ) Then
            Temp_RELATION_INFO$                   = a5XXFields( aRELATION_INFO, i )
            Temp_RELATIONSHIP$                    = a5XXFields( aRELATIONSHIP, i )
            Temp_RAW_HEADING$                     = a5XXFields( aRAW_HEADING, i )
            Temp_DISPLAY_HEADING$                 = a5XXFields( aDISPLAY_HEADING, i )
            Temp_HEADING_TAG$                     = a5XXFields( aHEADING_TAG, i )
            a5XXFields( aRELATION_INFO, i )       = a5XXFields( aRELATION_INFO, i + 1 )
            a5XXFields( aRELATIONSHIP, i)         = a5XXFields( aRELATIONSHIP, i + 1 )
            a5XXFields( aRAW_HEADING, i )         = a5XXFields( aRAW_HEADING, i + 1 )
            a5XXFields( aDISPLAY_HEADING, i)      = a5XXFields( aDISPLAY_HEADING, i + 1 )
            a5XXFields( aHEADING_TAG, i )         = a5XXFields( aHEADING_TAG, i + 1 )
            a5XXFields( aRELATION_INFO, i + 1 )   = Temp_RELATION_INFO$
            a5XXFields( aRELATIONSHIP, i + 1 )    = Temp_RELATIONSHIP$
            a5XXFields( aRAW_HEADING, i + 1 )     = Temp_RAW_HEADING$
            a5XXFields( aDISPLAY_HEADING, i + 1 ) = Temp_DISPLAY_HEADING$
            a5XXFields( aHEADING_TAG, i + 1 )     = Temp_HEADING_TAG$
            Swapped = TRUE
        End If
      Next i
    Loop Until Swapped = FALSE
End If

' From the main array, fill the three sub-arrays which populate the list boxes in the
' dialog box. Providing three arrays seems to work for most headings to display all the
' relationships: one array for earlier/later/broader/narrower, one for another kind of
' relationship, and the third for other or unspecified relationships. If there are more
' than three kinds of specific relationships, the remaining ones are combined into the
' catchall group of "Other." The relationship itself serves as the label in the dialog
' box.

IndexAll5XX% = 0
For ArrayNumber% = 1 To 3
  If IndexAll5XX% <= Count5XX% Then

      Select Case ArrayNumber%

        Case 1
          Call FillDialogBoxArrays( ArrayNumber%, Array1(), IndexAll5XX%, Array1Label$ )
        Case 2
          Call FillDialogBoxArrays( ArrayNumber%, Array2(), IndexAll5XX%, Array2Label$ )
        Case 3
          Call FillDialogBoxArrays( ArrayNumber%, Array3(), IndexAll5XX%, Array3Label$ )

      End Select

  End If
Next ArrayNumber%

' The count of headings in each of the sub-arrays is necessary to identify the row in the
' main array to search. For example, row 2 in the third sub-array may be row 7 in the
' main array. An unused array is not initialized and throws an error when its upper
' bound is queried, so nothing is counted from that one. If arrays 2 or 3 are left empty,
' their corresponding list boxes in the dialog box are hidden.

On Error Resume Next
Array1Count% = UBound( Array1 )
If Err = SUBSCRIPT_OUT_OF_RANGE Then Array1Count% = -1
Array2Count% = UBound( Array2 )
If Err = SUBSCRIPT_OUT_OF_RANGE Then Array2Count% = -1
Array3Count% = UBound( Array3 )
If Err = SUBSCRIPT_OUT_OF_RANGE Then Array3Count% = -1

' Show the dialog box.

Begin Dialog Dialog1Definition  276, 254, WaltsMacros$, .Dialog1ControlFunction
  PushButton    154, 232,  52,  14, "&Search",             .OK
  CancelButton  214, 232,  52,  14
  ListBox        10,  38, 256,  56, Array1(),              .ListBox1
  ListBox        10, 104, 256,  56, Array2(),              .ListBox2
  ListBox        10, 172, 256,  56, Array3(),              .ListBox3
  Text           14,  90, 240,   8, UnsearchableMessage$,  .Unsearchable1
  Text           14, 158, 240,   8, UnsearchableMessage$,  .Unsearchable2
  Text           14, 226, 128,  16, UnsearchableMessage$,  .Unsearchable3
  Text           10,  28, 256,   8, Array1Label$,          .Legend1
  Text           10,  94, 256,   8, Array2Label$,          .Legend2
  Text           10, 162, 256,   8, Array3Label$,          .Legend3
  Text           10,   8,  72,   8, "Established heading:"
  Text           78,   8, 186,  16, EstablishedHeading$
End Dialog

Dim Dialog1 As Dialog1Definition
On Error Resume Next
Dialog Dialog1
If Err = DLG_STATEMENT_CANCEL Then Exit Sub

' With the row of the main array returned by the dialog box, retrieve the raw heading
' and its tag. The tag of the 5XX heading to be searched is of course simply a number
' greater by 400 than the tag of the heading on its own record. This 1XX tag is necessary
' for searching the results list after the browse. It is placed within square brackets,
' to match the display. The search term, which is returned by the "GetHeading" function,
' must then be normalized for proper browsing.

RawHeading$ = a5XXFields( aRAW_HEADING, SearchCount% )
Tag$        = a5XXFields( aHEADING_TAG, SearchCount% )
HeadingTag$ = " [" & Trim$( Str$( Val( Tag$ ) - 400 ) ) & "]"
SearchTerm$ = GetHeading( RawHeading$, ( Tag$ ), SEARCH, ExpandedTerm$ )
SearchTerm$ = Normalize( SearchTerm$, Tag$ )

' Two more pieces of information are required to complete preparation for the browse: The
' expanded term, and a string with which to search the results list.
'   + An expanded term is required for browsing name/title headings and subject terms
'     with subject subdivisions. If there is such a string, normalize it. However, if
'     there is no expanded term, supply one that consists simply of a space. Conducting
'     an expanded browse with an empty string for the expanded term results in a simple
'     or regular browse, which for consistency's sake this macro does not use. Note that
'     a string of subject subdivisions that follows a name that is not a geographic
'     heading is not an expanded term.
'   + A list search string may be required to retrieve the appropriate heading from the
'     list. For example, a browse on the subdivision "bibliography" retrieves a list in
'     which the first two entries are that term--one as a 180 field, the second as a 185.
'     (Similarly, the first two entries in a list may be the same term but tagged 150 and
'     550.) To select the correct item, it would seem appropriate that the search string
'     used against the results list be the expanded term. However, the presence of a
'     delimiter in an item breaks a search for that item; if the expanded term contains
'     more than one subfield, it is useless as a search string. This macro's solution to
'     the problem is to use only the last subfield of the heading, minus the delimiter,
'     in its search. But since even the last subfield may not be unique (the last
'     subfield may in fact be the whole heading), the tag of the field (calculated above)
'     is added. Formatting of the list search string is critical: If there is no expanded
'     term, the search term must be followed by a line feed character, then seven spaces,
'     then the heading tag; otherwise, the list search string is composed of the last
'     subfield, followed by the heading tag.

If ExpandedTerm$ = "" Then
    ExpandedTerm$     = " "
    If NameAsSubject Then
        ListSearchString$ = Trim$( Mid$( LastSubfield$, 2 ) ) & HeadingTag$
      Else
        ListSearchString$ = Trim$( Mid$( LastSubfield$, 3 ) ) & LINE_FEED & "      " & HeadingTag$
    End If
  Else
    ExpandedTerm$     = Normalize( ExpandedTerm$, NO_TAG )
    ListSearchString$ = Trim$( Mid$( LastSubfield$, 2 ) ) & HeadingTag$
End If

' The tag of the selected field generates the label used in the browse, except for
' children's subjects, which are all subsumed into the label "sj".

If Childrens Then
    SearchLabel$ = "sj"
  Else
    Select Case Tag$

      Case "500"
        SearchLabel$ = "pn"

      Case "510"
        SearchLabel$ = "co"

      Case "511"
        SearchLabel$ = "cn"

      Case "530"
        SearchLabel$ = "ti"

      Case "550"
        SearchLabel$ = "to"

      Case "551"
        SearchLabel$ = "gg"

      Case "580", "585"
        SearchLabel$ = "sb"

    End Select
End If

' The macro browses, rather than searches, because a search actually uses keywords--it's
' not left-anchored--and so may result in more hits than can fit on the screen. For
' example, the heading "United States Congress House" appears after many pages of
' headings in which those keywords appear. A browse will still result in a list, but the
' heading will often be the first entry on the list. To make sure the correct heading is
' opened, the macro searches the list for the last subdivision of the heading as a
' potentially unique identifier.

If CS.BrowseAuthorityExpanded( 0, SearchLabel$, SearchTerm$, ExpandedTerm$ ) Then
    If NameAsSubject = FALSE Then
        ListSearchResults = CS.SearchList( ListSearchString$, "Results", FALSE )

' The match criteria has to be "FALSE" because "TRUE" requires an exact match against a
' whole heading, which is impossible if the heading contains a delimiter. Unfortunately,
' a fuzzy search, one that matches only part of the heading, may result in multiple
' matches, because the search term is limited to the last subfield only. This string may
' not be unique, even though intervening subfields make for a unique item in the list. In
' such a case, the "CS.GetFirstSelectedItem" may not actually open the first selected
' item, but one of the other selected items. To try to not open the wrong item if there
' are multiple matches, simply open the first item on the list. If there is only one
' match from the search, the macro command should execute successfully.

        If ListSearchResults = 1 Then
            OpenSelectedItem = CS.GetFirstSelectedItem
          ElseIf ListSearchResults > 1 Then
            OpenSelectedItem = CS.GetFirstItem
          Else
            OpenSelectedItem = FALSE
        End If
        If OpenSelectedItem Then

' Quite often an LC subject heading browse will result in a brief list that contains two
' matching records, identical except that one of them is an LC Children's Subject Heading
' authority record. The trick is getting the one that is not the children's heading. The
' way the macro goes about this is by once again using the "SearchList" command. The
' search term is "children", and by setting the "ExactMatch" parameter to "FALSE," the
' command can find the term within the larger term "[CHILDREN'S]" that appears in the
' description column. The command also selects the rows that contain the matching search
' term. Use the "GetFirstSelectedItem" to open the first selection. Because it's a
' children's heading, immediately close that record and check for a preceding or
' following heading. In a list of two items, with one having been selected, the other
' heading must be the LCSH sought. If none of the items in a brief list is labeled as a
' children's heading, as in a name search but also in some regular subject searches, then
' just open the first one.

            If CS.ItemType% = AUTHORITY_FILE_BRIEF_LIST Then
                Matches% = CS.SearchList( "children", "Description", FALSE )
                If Matches% = 0 Then
                    If CS.GetFirstItem = FALSE Then
                        GoTo Failure:
                    End If
                  Else
                    If CS.GetFirstSelectedItem Then
                        CS.CloseRecord( FALSE )
                        If CS.GetPrevItem = FALSE Then
                           If CS.GetNextItem = FALSE Then
                               GoTo Failure:
                           End If
                        End If
                      Else
                        GoTo Failure:
                    End If
                End If
            End If
            If CS.ItemType% = AUTHORITY_RECORD Then
                Exit Sub
              Else
                GoTo Failure:
            End If
          Else
            GoTo Failure:
        End If

' A heading that consists of a name (X00 and X10) and subject subdivisions can't be
' directly retrieved by a browse. The result of browsing for a name heading usually
' results in a list in which the first entry is the name in a 1XX field. Authorized
' headings containing subdivisions are contained in that entry, so opening it produces an
' Authority File brief list, consisting of the heading as a subject with subdivisions.
' The desired heading may be anywhere in that list, which could be several pages long--
' the same situation as when searching the Authority File, as opposed to browing. Finding
' that heading requires searching each page of the list with the last subject subdivision
' of the heading. There may be no way around that.

      Else
        ListSearchResults = CS.SearchList( "      " & HeadingTag$, "Results", FALSE )
        If CS.GetFirstSelectedItem Then
            If CS.ItemType = AUTHORITY_FILE_BRIEF_LIST Then
                Do
                  Matches% = CS.SearchList( ListSearchString$, "Description", FALSE)
                  If Matches% = 0 Then
                      If CS.GetNext100Records = FALSE Then
                          GoTo Failure:
                      End If
                    Else
                      If CS.GetFirstSelectedItem Then
                          If CS.ItemType = AUTHORITY_RECORD Then
                              Exit Sub
                          End If
                        Else
                          GoTo Failure:
                      End If
                  End If
                Loop Until CS.ItemType = AUTHORITY_RECORD
            End If
        End If
    End If
End If

Failure:

MsgBox "Sorry, the search failed.", CRITICAL_MESSAGE, WaltsMacros$

End Sub

'****************************************************************************************

Sub FillDialogBoxArrays( WhichArray%, InArray() As String, All5XXIndex%, ArrayLabel$ )

' Given the sub-array to fill (1, 2, or 3, corresponding to the three list boxes in the
' dialog box), and the index of the main array, this routine fills the sub-arrays from
' the main array and selects a relationship term or phrase for the caption of each list
' box.

Dim InitialRelationshipCode$
Dim InitialRelationshipTerm$
Dim SubsequentRelationshipCode$
Dim SubsequentRelationshipTerm$

Dim Mixed                    : Mixed = FALSE

Dim i As Integer, j As Integer

' Starting with the previous sub-array's ending row (which will of course be 0 for the
' first array), add terms to the array if they match what's already in the array (which
' will be nothing if the array is just beginning to be filled). As soon as a new
' relationship is found, it goes into the next sub-array.

For i = All5XXIndex% To Count5XX%
  If j = 0 Then
      InitialRelationshipCode$    = a5XXFields( aRELATION_INFO, All5XXIndex% )
      InitialRelationshipTerm$    = a5XXFields( aRELATIONSHIP, All5XXIndex% )
    Else
      SubsequentRelationshipCode$ = a5XXFields( aRELATION_INFO, i )
      SubsequentRelationshipTerm$ = a5XXFields( aRELATIONSHIP, i )
  End If

' If the relationship code matches, check the relationship term.

  If ( j = 0 ) Or ( SubsequentRelationshipCode$ = InitialRelationshipCode$ Or WhichArray% = 3 ) Then
      If InitialRelationshipTerm$ = "Unspecified relationship:" Then
          Mixed = TRUE
      End If

' If the term matches, add the heading to the array, and set the label for that
' relationship.

      If ( j = 0 ) Or ( SubsequentRelationshipTerm$ = InitialRelationshipTerm$ Or WhichArray% = 3 ) Then
          ReDim Preserve InArray( j )
          InArray( j ) = a5XXFields( aDISPLAY_HEADING, All5XXIndex% )
          j            = j + 1
          All5XXIndex% = All5XXIndex% + 1
        Else
          Exit For
      End If
    Else
      Exit For
  End If
Next i

' If there is more than one term in an array, make its label plural.

If WhichArray% < 3 Then
    ArrayLabel$ = Plural( InitialRelationshipTerm$, j )
    Exit Sub
  Else
    If Mixed Then
        ArrayLabel$ = "Other/Unspecified relationship:"
      Else
        If SubsequentRelationshipTerm$ = "" Or InitialRelationshipTerm$ = SubsequentRelationshipTerm$ Then 'only 1 term processed
            ArrayLabel$ = Plural( InitialRelationshipTerm$, j )
          Else
            ArrayLabel$ = "Other relationship:"
        End If
    End If
End If

End Sub

'****************************************************************************************

Function AssignLabels( InString$ ) As String

' This function pairs the most common relationship designations with alphabetic codes, so
' as to sort the headings into a more desirable order, as well as to provide appropriate
' labels for the listboxes.

Dim TempString$

  Select Case InString$

    Case "a"
      TempString$ = "aEarlier heading:"
    Case "b"
      TempString$ = "bLater heading:"
    Case "g"
      TempString$ = "cBroader term:"
    Case "Predecessor:"
      TempString$ = "cPredecessor:"
    Case "h"
      TempString$ = "dNarrower term:"
    Case "n"
      TempString$ = "nOther heading:"
    Case "t"
      TempString$ = "tHierarchical superior:"
    Case "Hierarchical superior:"
      TempString$ = "tHierarchical superior:"
    Case "Successor:"
      TempString$ = "dSuccessor:"
    Case "z"
      TempString$ = "zUnspecified relationship:"
    Case Else
      TempString$ = "y" & InString$

  End Select

AssignLabels = TempString$

End Function

'****************************************************************************************

Function ConvertTo8859( InputString$ ) As String

' This function converts the MARC21 string to ISO/IEC 8859-1 encoding, to make it
' possibly easier to read in the dialog box. Real normalization of the search strings for
' browsing takes place after the heading has been selected.

Dim Character$               : Character$ = " "
Dim CharNext%
Dim CharRead%
Dim TempString$

Dim i As Integer

InputString$ = InputString$ & Character$
For i = 1 To Len( InputString$ ) - 1
  CharRead% = Asc( Mid$( InputString$, i, 1 ) )
  CharNext% = Asc( Mid$( InputString$, i + 1, 1 ) )

  Select Case CharRead%

    Case 32 To 37, 39 To 64, 66, 68, 70 To 72, 74 To 77, 80 To 82, 84, 86 To 88, 91 To 96
      Character$ = Chr$( CharRead% )

' OCLC-MARC modified characters are turned into precomposed characters, when possible.

    Case 98, 100, 102 To 104, 106 To 109, 112 To 114, 116, 118 To 120, 123 To 128
      Character$ = Chr$( CharRead% )

    Case 65, 97   'A, a
      Select Case CharNext%
        Case 225  'grave
          Character$ = Chr$( CharRead% + 127 ) : i = i + 1
        Case 226  'acute
          Character$ = Chr$( CharRead% + 128 ) : i = i + 1
        Case 227  'circumflex
          Character$ = Chr$( CharRead% + 129 ) : i = i + 1
        Case 228  'tilde
          Character$ = Chr$( CharRead% + 130 ) : i = i + 1
        Case 232  'diaeresis
          Character$ = Chr$( CharRead% + 131 ) : i = i + 1
        Case 234  'ring
          Character$ = Chr$( CharRead% + 132 ) : i = i + 1
        Case 224, 229 To 231, 233, 235 To 251
          Character$ = Chr$( CharRead% ) : i = i + 1
        Case Else
          Character$ = Chr$( CharRead% )
      End Select

    Case 67, 99   'C, c
      Select Case CharNext%
        Case 240  'cedilla
          Character$ = Chr$( CharRead% + 132 ) : i = i + 1
        Case 224 To 239, 241 To 251
          Character$ = Chr$( CharRead% ) : i = i + 1
        Case Else
          Character$ = Chr$( CharRead% )
      End Select

    Case 69, 101  'E, e
      Select Case CharNext%
        Case 225  'grave
          Character$ = Chr$( CharRead% + 131 ) : i = i + 1
        Case 226  'acute
          Character$ = Chr$( CharRead% + 132 ) : i = i + 1
        Case 227  'circumflex
          Character$ = Chr$( CharRead% + 133 ) : i = i + 1
        Case 232  'diaeresis
          Character$ = Chr$( CharRead% + 134 ) : i = i + 1
        Case 224, 228 To 231, 233 To 251
          Character$ = Chr$( CharRead% ) : i = i + 1
        Case Else
          Character$ = Chr$( CharRead% )
      End Select

    Case 73, 105  'I, i
      Select Case CharNext%
        Case 225  'grave
          Character$ = Chr$( CharRead% + 131 ) : i = i + 1
        Case 226  'acute
          Character$ = Chr$( CharRead% + 132 ) : i = i + 1
        Case 227  'circumflex
          Character$ = Chr$( CharRead% + 133 ) : i = i + 1
        Case 232  'diaeresis
          Character$ = Chr$( CharRead% + 134 ) : i = i + 1
        Case 224, 228 To 231, 233 To 251
          Character$ = Chr$( CharRead% ) : i = i + 1
        Case Else
          Character$ = Chr$( CharRead% )
      End Select

    Case 78, 110  'N, n
      Select Case CharNext%
        Case 228  'tilde
          Character$ = Chr$( CharRead% + 131 ) : i = i + 1
        Case 224 To 227, 229 To 251
          Character$ = Chr$( CharRead% ) : i = i + 1
        Case Else
          Character$ = Chr$( CharRead% )
      End Select

    Case 79, 111  'O, o
      Select Case CharNext%
        Case 225  'grave
          Character$ = Chr$( CharRead% + 131 ) : i = i + 1
        Case 226  'acute
          Character$ = Chr$( CharRead% + 132 ) : i = i + 1
        Case 227  'circumflex
          Character$ = Chr$( CharRead% + 133 ) : i = i + 1
        Case 228  'tilde
          Character$ = Chr$( CharRead% + 134 ) : i = i + 1
        Case 232  'diaeresis
          Character$ = Chr$( CharRead% + 135 ) : i = i + 1
        Case 224, 229 To 231, 233 To 251
          Character$ = Chr$( CharRead% ) : i = i + 1
        Case Else
          Character$ = Chr$( CharRead% )
      End Select

    Case 83, 115  'S, s
      Select Case CharNext%
        Case 224 To 251
          Character$ = Chr$( CharRead% ) : i = i + 1
        Case Else
          Character$ = Chr$( CharRead% )
      End Select

    Case 85, 117  'U, u
      Select Case CharNext%
        Case 225  'grave
          Character$ = Chr$( CharRead% + 132 ) : i = i + 1
        Case 226  'acute
          Character$ = Chr$( CharRead% + 133 ) : i = i + 1
        Case 227  'circumflex
          Character$ = Chr$( CharRead% + 134 ) : i = i + 1
        Case 232  'diaeresis
          Character$ = Chr$( CharRead% + 135 ) : i = i + 1
        Case 224, 228 To 231, 233 To 251
          Character$ = Chr$( CharRead% ) : i = i + 1
        Case Else
          Character$ = Chr$( CharRead% )
      End Select

    Case 89, 121  'Y, y
      Select Case CharNext%
        Case 226  'acute
          Character$ = Chr$( CharRead% + 132 ) : i = i + 1
        Case 232  'diaeresis
          If CharRead% = 121 Then
              Character$ = Chr$( 255 )
            Else
              Character$ = Chr$( CharRead% )
          End If
          i = i + 1
        Case 224 To 225, 227 To 231, 233 To 251
          Character$ = Chr$( CharRead% ) : i = i + 1
        Case Else
          Character$ = Chr$( CharRead% )
      End Select

    Case 90, 122  'Z, z
      Select Case CharNext%
        Case 224 To 251
          Character$ = Chr$( CharRead% ) : i = i + 1
        Case Else
          Character$ = Chr$( CharRead% )
      End Select

    Case 158   'Degree sign
      Character$ = Chr$( 176 )
    Case 160   'Euro
      Character$ = Chr$( 128 )
    Case 162   'Crossed O
      Character$ = Chr$( 216 )
    Case 163   'Eth
      Character$ = Chr$( 208 )
    Case 164   'Thorn
      Character$ = Chr$( 222 )
    Case 165   'AE Ligature
      Character$ = Chr$( 198 )
    Case 166   'OE Ligature
      Character$ = "Oe"
    Case 169   'Musical flat
      Character$ = Chr$( 129 )
    Case 170   'registered
      Character$ = Chr$( 174 )
    Case 171   'Plus-minus
      Character$ = Chr$( 177 )
    Case 174, 176   'Alif, Ayn
      Character$ = Chr$( 039 )
    Case 178   'crossed o
      Character$ = Chr$( 248 )
    Case 179   'eth
      Character$ = Chr$( 240 )
    Case 180   'thorn
      Character$ = Chr$( 254 )
    Case 181   'ae ligature
      Character$ = Chr$( 230 )
    Case 182   'oe ligature
      Character$ = "oe"
    Case 185   'Pound
      Character$ = Chr$( 163 )
    Case 202   'Copyright
      Character$ = Chr$( 169 )
    Case 203   'Sound recording copyright
      Character$ = "p"
    Case 204   'Musical sharp
      Character$ = "#"
    Case 223   'Delimiter
      If Character$ = " " And Mid$( InputString$, i + 1, 2 ) Like "[a-z0-9] " Then
          Character$ = "$"
        Else
          Character$ = Chr$( 223 )
      End If
    Case 224 To 251, 254
      Character$ = ""
    Case Else
      Character$ = Chr$( CharRead% )

  End Select

  TempString$ = TempString$ & Character$

Next i

' Omit the initial delimiter if the first subfield is a.

If Left$( TempString$, 2 ) = "$a" Then
    TempString$ = Trim$( Mid$( TempString$, 3 ) )
End If

ConvertTo8859 = TempString$

End Function

'****************************************************************************************

Function GetHeading$( InString$, Tag$, Reason%, ExpandedTerm$ ) As String

' This function is called twice as the macro executes. The first time it is called, it
' simply eliminates subfields that aren't part of the heading, such as the control
' subfields, just for display. The second time it is called, it analyzes the raw heading
' by examining its subfields, one by one, to return the search term, an expanded term,
' and the last subfield.

Dim PrevDelim%
Dim SearchString$
Dim Start%                   : Start% = 1
Dim SubCodePos%
Dim SubfieldCode$
Dim SubfieldCodesString$
Dim SubjectSplit%
Dim SubjSubfieldCodePos%
Dim TempField$
Dim TempString$
Dim TitleSplit%
Dim TitleSubfieldCodePos%

Dim i As Integer, p As Integer

' When formulating a heading for display, all the subfields must be taken into account,
' except for the irrelevant ones. But when formulating a heading for a browse, only the
' subfields indexed for the type of browse matter. This macro considers "geographic
' names" to be simply names (headings in field 151), and "topicals" to be simply LC
' subject headings (field 150).

Select Case Reason%

  Case DISPLAY

    SubfieldCodesString$ = "abcdefghjklmnopqrstuvxyz"

  Case SEARCH

    Select Case Tag$

' The colon in the strings of subfield codes separates the subfields of the main part of
' the heading from those of the title and subject subdivisions, which will probably end
' up being the expanded term.

      Case "500"
        If Childrens Then
            SubfieldCodesString$  = "abcdfhjklmnopqrst:vxyz"
            SubjSubfieldCodePos%  = 18
          Else
            SubfieldCodesString$  = "abcdejq:fhklmnoprst:vxyz"
            TitleSubfieldCodePos% = 8
            SubjSubfieldCodePos%  = 20
        End If

      Case "510"
        If Childrens Then
            SubfieldCodesString$  = "abcdfghjklmnoprst:vxyz"
            SubjSubfieldCodePos%  = 18
          Else
            SubfieldCodesString$  = "abcden:dfghklmnoprst:vxyz"
            TitleSubfieldCodePos% = 7
            SubjSubfieldCodePos%  = 21
        End If

      Case "511"
        If Childrens Then
            SubfieldCodesString$  = "abcdfghjklmnpqst:vxyz"
            SubjSubfieldCodePos%  = 17
          Else
            SubfieldCodesString$  = "abdejnq:dfghklnpst:vxyz"
            TitleSubfieldCodePos% = 8
            SubjSubfieldCodePos%  = 20
        End If

      Case "530"
        SubfieldCodesString$  = "adfghklmnoprst:vxyz"
        SubjSubfieldCodePos%  = 15

      Case "550"
        SubfieldCodesString$  = "ab:vxyz"
        SubjSubfieldCodePos%  = 3

      Case "551"
        SubfieldCodesString$  = "a:vxyz"
        SubjSubfieldCodePos%  = 2

      Case "580", "585"
        SubfieldCodesString$  = "vxyz"

    End Select

End Select

' Add each indexed subfield to the string.

Start% = 1
Do
  p = InStr( Start%, InString$, DELIMITER )
  If p > 0 Then
      SubfieldCode$  = Mid$( InString$, p + 1, 1 )
      SubCodePos%    = InStr( SubfieldCodesString$, SubfieldCode$ )
      If SubCodePos% > 0 Then
          If Reason% <> DISPLAY Then

' Check the subfield code to see if it divides the heading into the main and expanded
' terms. If it does, record its position in the string as it continues to be built.

              Select Case Tag

                Case "500", "510", "511"

                  If SubCodePos% > SubjSubfieldCodePos% Then
                      If SubjectSplit% = 0 Then
                          SubjectSplit% = p
                      End If
                    ElseIf SubCodePos% > TitleSubfieldCodePos% Then
                      If TitleSplit% = 0 Then
                          TitleSplit%   = p
                      End If
                  End If

                Case "550", "551"

                  If SubCodePos% > SubjSubfieldCodePos% Then
                      If SubjectSplit% = 0 Then
                          SubjectSplit% = p
                      End If
                  End If

              End Select

          End If

          TempString$ = GetSubfieldData( Start%, InString$, SubfieldCode$ )
          If TempString$ <> "" Then
              TempString$ = DELIMITER & SubfieldCode$ & " " & TempString$
              TempField$  = TempField$ & " " & TempString$
          End If

      End If
      PrevDelim% = p
  End If
  Start% = p + 1
Loop Until p = 0

TempField$ = Trim$( TempField$ )

If Reason% = DISPLAY Then
    SearchString$ = TempField$
  Else

' The very last subfield of the heading will become the term with which to search the
' results list.

    LastSubfield$ = Mid$( InString$, PrevDelim% )

' Now divide the heading into the primary and expanded terms, and record subject
' subdivisions. For a name, the expanded term is a title. For a topical subject heading,
' the expanded term is any subdivision string. For a name followed by subject
' subdivisions, there is no expanded term; the last subdivision of the string can only
' be the list search term.

    If TitleSplit% = 0 And SubjectSplit% = 0 Then
        SearchString$ = TempField$
        ExpandedTerm$ = ""
      ElseIf TitleSplit% > 0 And SubjectSplit% > 0 Then
        SearchString$ = Trim$( Left$( TempField$, TitleSplit% - 1 ) )
        ExpandedTerm$ = Trim$( Mid$( TempField$, TitleSplit%, SubjectSplit% - TitleSplit% ) )
        NameAsSubject = TRUE
      Else
        If TitleSplit% > 0 Then
            SearchString$ = Trim$( Left$( TempField$, TitleSplit% - 1 ) )
            ExpandedTerm$ = Trim$( Mid$( TempField$, TitleSplit% ) )
          ElseIf SubjectSplit% > 0 Then
            SearchString$ = Trim$( Left$( TempField$, SubjectSplit% - 1 ) )
            ExpandedTerm$ = Trim$( Mid$( TempField$, SubjectSplit% ) )
            If Val( Tag$ ) < 550 Then
                NameAsSubject = TRUE
                ExpandedTerm$ = ""
            End If
        End If
    End If
End If

GetHeading$ = SearchString$

End Function

'****************************************************************************************

Function GetSubfieldData( Start%, InString$, SubfieldCode$ ) As String

' This function gets data from the specified subfield in a string.

Dim p As Integer, q As Integer

p = InStr( Start%, InString$, DELIMITER & SubfieldCode$ )
If p > 0 Then
    q = InStr( p + 1, InString$, DELIMITER )
    If q > 0 Then
        GetSubfieldData = Trim$( Mid$( InString$, p + 2, q - p - 2 ) )
      Else
        GetSubfieldData = Trim$( Mid$( InString$, p + 2 ) )
    End If
End If

Start% = q

End Function

'****************************************************************************************

Function Normalize( InString$, Tag$ ) As String

' This function uses NACO normalization rules to convert the MARC-21 string into a string
' suitable for browsing the Authority File, omitting and converting some characters.

Const ASCII_DIFF_CASE        As Integer = 32  'The difference between ASCII values of upper and lower case of a letter.
Const ASCII_DIFF_SUBSCRIPT   As Integer = 96  'The difference between ASCII values of subscript and normal numbers.
Const ASCII_DIFF_SUPERSCRIPT As Integer = 80  'The difference between ASCII values of superscript and normal numbers.

Dim CharA%
Dim CharT$
Dim Index%
Dim NormalizedString$
Dim TempString$              : TempString$ = InString$
Dim TempStringLength%

Dim CommaFound               : CommaFound  = FALSE

Dim p As Integer

TempStringLength% = Len( TempString$ )
Index%            = 1

Do While Index% <= TempStringLength%
  CharT$ = Mid$( TempString$, Index%, 1 )
  CharA% = Asc( CharT$ )
  Select Case CharA%

' Numbers and text characters: Include; convert lowercase to uppercase.

    Case 48 to 57, 65 to 90
      NormalizedString$ = NormalizedString$ & CharT$

    Case 97 to 122
      NormalizedString$ = NormalizedString$ & Chr$( CharA% - ASCII_DIFF_CASE )

' Special characters to include:

    Case 35 To 36, 38, 43, 64, 169, 185, 204
      NormalizedString$ = NormalizedString$ & CharT$

' Comma: Keep the first comma in browsing a personal name.

    Case 44
      If Tag$ = "500" Then
          If CommaFound = FALSE Then
              NormalizedString$ = NormalizedString$ & CharT$
              CommaFound        = TRUE
            Else
              NormalizedString$ = NormalizedString$ & " "
          End If
      End If

' Characters converted to space:

    Case 32 To 34, 37, 40 To 42, 45 To 47, 58 To 63, 92, 94 To 96, 123 To 125, 126, _
         138 To 141, 154 To 158, 167 To 168, 170 To 171, 174, 183, 200 To 203
      NormalizedString$ = NormalizedString$ & " "

' Superscript, subscript numbers: Convert to normal.

    Case 128 to 137
      CharT$            = Chr$( CharA% - ASCII_DIFF_SUPERSCRIPT )
      NormalizedString$ = NormalizedString$ & CharT$

    Case 144 to 153
      CharT$            = Chr$( CharA% - ASCII_DIFF_SUBSCRIPT )
      NormalizedString$ = NormalizedString$ & CharT$

' Special characters: Substitute.

    Case 159
      NormalizedString$ = NormalizedString$ & "SS"
    Case 161, 177, 190
      NormalizedString$ = NormalizedString$ & "L"
    Case 162, 172, 178, 188
      NormalizedString$ = NormalizedString$ & "O"
    Case 163, 179, 186
      NormalizedString$ = NormalizedString$ & "D"
    Case 164, 180
      NormalizedString$ = NormalizedString$ & "TH"
    Case 165, 181
      NormalizedString$ = NormalizedString$ & "AE"
    Case 166, 182
      NormalizedString$ = NormalizedString$ & "OE"
    Case 173, 189
      NormalizedString$ = NormalizedString$ & "U"
    Case 184
      NormalizedString$ = NormalizedString$ & "I"

' Delimiter: Omit, along with its accompanying subfield code.

    Case 223
      Index%            = Index% + 1

    Case Else

  End Select

  Index% = Index% + 1

Loop

' Remove any introduced double spaces.

Do
  p = InStr( NormalizedString$, "  " )
  If p > 0 Then
      NormalizedString$ = Trim$( Left$( NormalizedString$, p ) ) & " " & Trim$( Mid$( NormalizedString$, p + 1 ) )
  End If
Loop Until p = 0

Normalize = Trim$( NormalizedString$ )

End Function

'****************************************************************************************

Function Plural( Label$, n% ) As String

' Makes the listbox label plural if there is more than one heading in it.

Dim TestString$

If n% = 1 Then
    Plural = Label$
  Else
    TestString$ = Right$( Label$, 4 )
    If TestString$ = "erm:" Or TestString$ = "ing:" Or TestString$ = "hip:" Then
        Plural = Left$( Label$, Len( Label$ ) - 1 ) & "s:"
      Else
        Plural = Label$
    End If
End If

End Function

'****************************************************************************************

Function Dialog1ControlFunction( Id$, Action%, SValue& )

Const CONTROL_CHANGE  As Integer = 2
Const INITIALIZE      As Integer = 1
Const INVISIBLE       As Integer = 0
Const KEEP_DLG_OPEN   As Integer = -1
Const VISIBLE         As Integer = 1
Const WARNING_MESSAGE As Integer = 48

Const NO_SELECTION    As Integer = -1

Select Case Action%

  Case INITIALIZE

' List boxes whose arrays have not been used are made invisible.

    DlgValue   "ListBox1",      0
    DlgValue   "ListBox2",      NO_SELECTION
    DlgValue   "ListBox3",      NO_SELECTION
    DlgVisible "Unsearchable1", INVISIBLE
    DlgVisible "Unsearchable2", INVISIBLE
    DlgVisible "Unsearchable3", INVISIBLE
    If Array2Count% = NO_SELECTION Then
        DlgVisible "ListBox2",      INVISIBLE
        DlgVisible "Legend2",       INVISIBLE
        DlgVisible "Unsearchable1", VISIBLE
      Else
        DlgVisible "Unsearchable1", INVISIBLE
    End If
    If Array3Count% = NO_SELECTION Then
        DlgVisible "ListBox3",      INVISIBLE
        DlgVisible "Legend3",       INVISIBLE
        If DlgVisible( "Unsearchable1" ) Then
            DlgVisible "Unsearchable2", INVISIBLE
        End If
      Else
        DlgVisible "Unsearchable2", INVISIBLE
    End If
    If DlgVisible( "Unsearchable1" ) And DlgVisible( "Unsearchable2" ) Then
        DlgVisible "Unsearchable3", VISIBLE
    End If
    DlgFocus   "ListBox1"


  Case CONTROL_CHANGE

    Select Case Id$

' If a heading in one list box is selected, the other list boxes must be de-selected, as
' only one heading at a time can be searched--but OML allows more than one list box at a
' time to be able to have a selection.

      Case "ListBox1"
        DlgValue   "ListBox2",      NO_SELECTION
        DlgValue   "ListBox3",      NO_SELECTION

      Case "ListBox2"
        DlgValue   "ListBox1",      NO_SELECTION
        DlgValue   "ListBox3",      NO_SELECTION

      Case "ListBox3"
        DlgValue   "ListBox1",      NO_SELECTION
        DlgValue   "ListBox2",      NO_SELECTION

      Case "OK"

' To search the results list, the raw heading must be used (as it preserves all
' diacritical marks and special characters). The index of that heading in the main
' array has to be calculated from which list box is chosen.

        If DlgValue( "ListBox1" ) > NO_SELECTION Then
            SearchTerm$  = DlgText( "ListBox1" )
            SearchCount% = DlgValue( "ListBox1" )
          ElseIf DlgValue( "ListBox2" ) > NO_SELECTION Then
            SearchTerm$  = DlgText( "ListBox2" )
            SearchCount% = DlgValue( "ListBox2" ) + Array1Count% + 1
          ElseIf DlgValue( "ListBox3" ) > NO_SELECTION Then
            SearchTerm$  = DlgText( "ListBox3" )
            SearchCount% = DlgValue( "ListBox3" ) + Array1Count% + Array2Count% + 2
        End If
        If SearchTerm$ = "" Then
            MsgBox "Please select a term to search!", WARNING_MESSAGE, WaltsMacros$
            Dialog1ControlFunction = KEEP_DLG_OPEN
        End If

    End Select

End Select

End Function
'140053293
'
'Macro name: SearchAuthority5XX
'Macro book: C:\Users\wnickeson.UR\AppData\Roaming\OCLC\Connex\Macros\Extras1.mbk
'Saved: 8/22/2023 9:59:47 AM using "MacroBookInspector" macro by Walter F. Nickeson.
