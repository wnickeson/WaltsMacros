'MacroName:MacroIndex.2023.03
'MacroDescription:Lists all the macros and their descriptions in all the macro books in
' the default folder "Macros". Also lists the macros in individual macro books. Offers
' searching for text in macro names and descriptions, and saving of all lists as text
' files.
'
' This macro was written by Walter F. Nickeson,
' University of Rochester, Rochester, NY
' wnickeson@library.rochester.edu
'
' Thanks to Joel Hahn for pointing out that macro books are instances of Microsoft's
' Compound File Binary File Format, the specification for which was last retrieved from
' https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-cfb/53989ce4-7b05-4f8d-829b-d08d6148375b
' on the date below (version 20210625).
'
' The "Quicksort" sorting algorithm is adapted from the example of the same name in
' "General Program Examples" of the documentation for IBM's CognosScript Language, which
' appears to be almost identical to OCLC's Macro Language. That documentation is
' apparently no longer available online.
'
' Last updated: 2 August 2023.
' Check for the latest versions of this and my other macros at
' https://github.com/wnickeson/WaltsMacros
' Please e-mail me with bug reports or to suggest improvements.
'
' This macro works for me with Connexion client 3.1 and Windows 11 Enterprise & 64-bit
' Windows 10 Pro, but no guarantees are promised or implied.
'
'****************************************************************************************
' How it works: Run the macro to view all the macros, in alphabetical order, in all the
' macro books in the default "Macros" folder. Click on a macro in the list to see which
' macro book it is in and to view the macro's description. The description is taken from
' the description box in the organizer windows, rather than from the source code. The
' dialog box can show eight lines of this description at approximately 44 characters per
' line (the actual amount of the description displayed depends largely on where the
' spaces between words allow breaks). Select a macro book to view all the macros, also in
' alphabetical order, in that book. The list of macros (either the whole list or those in
' a single macro book) can be saved to a text file; the default location for this file is
' the "Macros" folder. These saved lists include the macro name, macro book (except if
' the list is of the macros in a single book), and description. The lists can also be
' copied to the Clipboard; however, these lists contain macro names only. Click the
' search button to search for a text string in the macro names and descriptions. The
' search can be narrowed to descriptions only, and can also be forced to match case. The
' search results can be saved to a file or copied to the Clipboard like any other list.
'
' The macro runs very slowly with large numbers of macros. A macro book larger than 4 MB
' won't be included in the index.
'
' This macro is based on my "MacroBookInspector," but is much more limited in scope, as
' it only lists the macros and macro books, giving no other information about either
' besides the descriptions of individual macros. Use "MacroBookInspector" to obtain
' detailed information about the macros and their macro books, and read its code for more
' complete and comprehensive documentation on the inner workings of OCLC's macro book
' files.
'****************************************************************************************

Option Compare Text
Option Explicit

Type Container
 tDesc  As String
 tIndex As Integer
 tName  As String
End Type

Declare Sub CopyList           ( State% )
Declare Sub FillMacroBookMacros( BookIndex% )
Declare Sub GetEnviroVars
Declare Sub GetMacroBookFiles
Declare Sub GetMacroInformation( BookIndex% )
Declare Sub MakeMainList       ( MacroInfo As Container )
Declare Sub ReadFile           ( SelectedMacroBook$ )
Declare Sub SortAllMacros      ( LeftSide%, RightSide% )
Declare Sub WriteFile          ( Selection%, State% )

Declare Function GetDescription( MinistreamStart&, StreamSize&, NextMiniSector& ) As String
Declare Function GetSectorData ( SectorID& ) As String
Declare Function HexVal        ( InBytes$ )  As Long

Declare Function Dialog1ControlFunction( Id$, Action%, SuppVal& )
Declare Function Dialog2ControlFunction( Id$, Action%, SuppVal& )

Global Const CONTROL_CHANGE       As Integer = 2
Global Const DLG_STATEMENT_CANCEL As Integer = 102
Global Const INFORMATION_MESSAGE  As Integer = 64
Global Const INITIALIZE           As Integer = 1
Global Const KEEP_DLG_OPEN        As Integer = -1
Global Const MSGBOX_WARNING       As Integer = 48

Global Const ALL_MACROS           As Integer = 1      'The state of the dialog box when all the macros are shown.
Global Const BOOK_MACROS          As Integer = 2      'The state of the dialog box when the contents of a macro book are shown.
Global Const DWORD                As Integer = 4      'A double word (4 bytes); the length of sector IDs and some other values.
Global Const END_OF_CHAIN         As Integer = -2     'Hex FFFFFFFE, marks the end of a chain of sectors in the FAT.
Global Const MAX_STRING_LENGTH    As Integer = 31744  'The largest even multiple of 512 below 32767, OML's limit on string
                                                      ' length.
Global Const SEARCH_RESULTS       As Integer = 3      'The state of the dialog box when the search results are shown.
Global Const SECTOR_SIZE          As Integer = 512    'The size in bytes of the (large) sectors that make up a file in
                                                      ' Microsoft's Compound File Binary file format.
Global Const STRING1_GREATER_THAN As Integer = 1      'The value of the "StrComp" function when string 1 is greater than string
                                                      ' 2.
Global Const STRING1_LESS_THAN    As Integer = -1     'The value of the "StrComp" function when string 1 is less than string 2.
Global Const STRING_OFFSET        As Integer = 1      'The number to make up the difference between 0-based (file offset) and
                                                      ' 1-based (string offset) counting.

Global DOUBLE_QUOTE As String*1

Global AppDataPath$
Global BaseBookBlock%
Global BookBlockOffset%
Global Description$
Global ErrorMessage$
Global FATString$
Global FileName$
Global MacroDirectoryPath$
Global MiniFATString$
Global PrevBookID%
Global SaveCount%
Global SearchTerm$
Global State%
Global TotalMacroCount%
Global WaltsMacros$

Global FileSections()       As String     'Storage for the 32K pieces of the files.
Global LinkMatchToMain()    As Integer    'Links the search results array to the main macro list array.
Global MacroBookMacros()    As Container  'The macros in a single macro book.
Global MacroBooksList()     As String     'All the macro book files.
Global MacroListByBooks()   As String     'All the macros, arranged by macro book, and alphabetically within each book.
Global MacroListByNames()   As String     'All the macro names, in alphabetical order.
Global MainList()           As Container  'The main list of macros, containing name, macro book (as a number), and description.
Global MainListByBooks()    As Container  'A copy of the main list preserving its original order, which is by book.
Global PrevSearchPaths()    As String     'Records all the filenames used to save lists.
Global SearchMatchDisplay() As String     'The list of macros found by a search, for display in the dialog box.
Global SearchMatches()      As Container  'All the macros found by a search.

'****************************************************************************************

Sub Main

Dim Instructions$
Dim MacroBookCount$
Dim SelectedMacroBook$

Dim i As Integer, x As Integer

DOUBLE_QUOTE = Chr$( 034 )
WaltsMacros$ = "[Walt's macros] MacroTools:MacroIndex"

ReDim MainList( 0 )
ReDim PrevSearchPaths( 0 )

' Get the list of all the macro books in the directory; then, for each file, construct
' the list of macros.

Call GetMacroBookFiles

For i = 0 To UBound( MacroBooksList )
  SelectedMacroBook$ = MacroBooksList( i )
  Call ReadFile( SelectedMacroBook$ )
  Call GetMacroInformation( i )
Next i

x = UBound( MainList )

' Make copies of this original main list for different functions. The first copy is
' "MacroListByBooks", which preserves the main list's original order of macros sorted
' first by macro book and then by name. This array is used to present a list of all the
' macros in a single book.

ReDim MainListByBooks( x - 1 )
For i = 0 To x - 1
  MainListByBooks( i ) = MainList( i + 1 )
Next i

' Sort the original main list of macros alphabetically by macro name.

Call SortAllMacros( 1, x )

' The second copy of the original main list is of the alphabetized names only. This new
' array is the list shown in the dialog box when it opens or when the "View all macros"
' button is clicked.

ReDim MacroListByNames( x - 1 )
For i = 0 To x - 1
  MacroListByNames( i ) = MainList( i + 1 ).tName
Next i

' Display a message about macro books that are too big for this macro to handle, about 4
' MB.

If ErrorMessage$ <> "" Then
    MsgBox ErrorMessage$, MSGBOX_WARNING, WaltsMacros$
End If

Instructions$   = "Select a macro to view its description and which macro book it is in. Select a macro book to view all the macros in that book."
MacroBookCount$ = Trim( Str$( UBound( MacroBooksList ) + 1 ) ) & " macro books:"

' End up by showing the dialog box.

Begin Dialog Dialog1Definition  280, 206, WaltsMacros$, .Dialog1ControlFunction
  CancelButton  218, 184,  54,  14
  PushButton    148, 184,  54,  14, "&Search ...",                     .Search
  PushButton    152,  34, 112,  20, "View macros in this macro &book", .ViewButton
  ListBox         8,  16, 128, 170, MacroListByNames(),                .ListOfMacros
  DropListBox   144,  16, 128, 128, MacroBooksList(),                  .ListOfMacroBooks
  Text            8,   6, 264,   8, "",                                .MacroCount
  Text          144,   6,  56,   8, MacroBookCount$,                   .BookCount
  Text          148,  76, 120,  32, Instructions$,                     .Instruct
  GroupBox      144,  60, 128, 116, "Description of selected macro:",  .DescBox
  Text          148,  70, 120,  64, "",                                .Desc
  PushButton      8, 184,  54,  14, "Sa&ve list ...",                  .Save
  PushButton     78, 184,  54,  14, "&Copy list",                      .Copy
End Dialog

Dim Dialog1 as Dialog1Definition
On Error Resume Next
Dialog Dialog1

End Sub

'****************************************************************************************

Sub CopyList( State% )

Dim CRLF As String*2         : CRLF = Chr$( 013 ) & Chr$( 010 )
Dim TempString$

Dim i as Integer

Select Case State%

  Case ALL_MACROS
    For i = 1 To UBound( MainList )
      TempString$ = TempString$ & MainList( i ).tName & CRLF
    Next i

  Case BOOK_MACROS
    For i = 0 To UBound( MacroBookMacros )
      TempString$ = TempString$ & MacroBookMacros( i ).tName & CRLF
    Next i

  Case SEARCH_RESULTS
    For i = 0 To UBound( SearchMatchDisplay )
      TempString$ = TempString$ & SearchMatches( i ).tName & CRLF
    Next i

End Select

MsgBox "List of macros copied to Clipboard.", INFORMATION_MESSAGE, WaltsMacros$

Clipboard.Clear
Clipboard.SetText TempString$

End Sub

'****************************************************************************************

Sub FillMacroBookMacros( BookIndex% )

' This subprogram creates an array containing all the macros in any single macro book. It
' does this by copying the block of names (including macro book ID and description) from
' the main array. As the macro names there are already in alphabetical order, no
' further sorting need be done.

Dim FoundBook                : FoundBook = FALSE

Dim i As Integer, x As Integer

For i = 0 To UBound( MainListByBooks )
  If BookIndex% = MainListByBooks( i ).tIndex Then
      If FoundBook = FALSE Then

' The "offset" is the distance in the main array from the first element to the
' beginning of the block of macros for any particular macro book.

          BookBlockOffset% = i
          FoundBook        = TRUE
      End If
      ReDim Preserve MacroBookMacros( x )
      MacroBookMacros( x ) = MainListByBooks( i )
      x = x + 1
    Else
      If FoundBook = TRUE Then Exit Sub
  End If
Next i

End Sub

'****************************************************************************************

Sub GetEnviroVars

' This subprogram finds the path of the user's AppData directory, as found in the
' environment table, in order to get to the macro book and options files.

Const MAX_ATTEMPTS_ENVIRON As Integer = 128

Dim EnvironmentString$

Dim i As Integer

For i = 0 To MAX_ATTEMPTS_ENVIRON
  EnvironmentString$ = Environ( i )
  If Left$( EnvironmentString$, 8 ) = "APPDATA=" Then
      AppDataPath$ = Mid$( EnvironmentString$, 9 )
      Exit Sub
  End If
Next i

AppDataPath$ = ""

End Sub

'****************************************************************************************

Sub GetMacroBookFiles

' This macro makes the list of macro book files in the "Macros" folder. The only
' validation it undertakes is checking that the first eight bytes of the candidate files
' are correct: 0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1, the first part of which
' suggests the word "docfile".

Const FILE_EXTENSION As Integer = 4

Dim FileCounter%
Dim FileNumber%
Dim HeaderSignature$
Dim MacroBookFile$
Dim MacroBookName$
Dim MacroDirectoryFiles$
Dim Possibility$

Dim FIRST_8_BYTES As String*8

HeaderSignature$ = Chr$( 208 ) & Chr$( 207 ) & Chr$( 017 ) & Chr$( 224 ) & Chr$( 161 ) & Chr$( 177 ) & Chr$( 026 ) & Chr$( 225 )

' Find the path to OCLC's "Macros" folder and make an array of the macro books it
' contains.

ReDim MacroBooksList( FileCounter% )

Call GetEnviroVars

MacroDirectoryPath$  = "\OCLC\Connex\Macros\"
MacroDirectoryPath$  = AppDataPath$ & MacroDirectoryPath$
MacroDirectoryFiles$ = MacroDirectoryPath$ & "*.mbk"
MacroBookFile$       = Dir( MacroDirectoryFiles$ )

Do While MacroBookFile$ <> ""
  Possibility$ = MacroDirectoryPath$ & MacroBookFile$
  FileNumber%  = Freefile
  Open Possibility$ For Binary As #FileNumber%
  Get #FileNumber%, , FIRST_8_BYTES
  Close #FileNumber%
  Reset
  If FIRST_8_BYTES = HeaderSignature$ Then
      MacroBookName$                 = Left$( MacroBookFile$, Len( MacroBookFile$ ) - FILE_EXTENSION% )
      ReDim Preserve MacroBooksList( FileCounter% )
      MacroBooksList( FileCounter% ) = MacroBookName$
      FileCounter%                   = FileCounter% + 1
  End If
  MacroBookFile$ = Dir
Loop

End Sub

'****************************************************************************************

Sub GetMacroInformation( BookIndex% )

' This subprogram uses information in the file's header to extract the macro names from
' the directory entries and get each macro's description. It uses that information to
' build the entry for each macro for the main macro list.

Const DIR_ENTRY_LENGTH             As Integer = 128  'The length in bytes of a directory entry.
Const FIRST_SECTOR_MINISTREAM      As Integer = 117  'The first sector of the ministream.
Const HEADER_SECTOR                As Long    = -1   'The ID of the sector that precedes sector 0.
Const LENGTH_DIFAT                 As Integer = 436  'The length of the File Allocation Table.
Const MINIFAT_START                As Integer = 61   'The starting sector number of the MiniFAT.
Const MINISTREAM_START             As Integer = 117  'The first sector location if this is a stream object.
Const OFFSET_DIFAT_START           As Integer = 77   'The location of the first entry in the FAT.
Const OFFSET_DIR_START             As Integer = 49   'The starting sector number for the directory stream.
Const OFFSET_FAT_SECTORS_COUNT     As Integer = 45   'The location of the number that tells how many sectors are devoted to the FAT.
Const OFFSET_MINIFAT_SECTORS_COUNT As Integer = 65   'The location of the number that tells how many sectors are devoted to the MiniFAT.
Const OFFSET_SIZE_MINISTREAM       As Integer = 121  'The location of the number giving the length of the ministream.

Dim CandidateEntry$
Dim ExtensionDES$
Dim FATSectorListInHeader$
Dim FileHeader$
Dim FirstSectorOfDirectory&
Dim FirstSectorOfMiniFAT%
Dim Index&
Dim MacroInfo As Container
Dim MacroName$
Dim MinistreamStart&
Dim NextMiniSector&
Dim NextSector&
Dim RootStorageEntry$
Dim SectorData$
Dim SectorID&
Dim SectorQuarter%
Dim StreamSize&
Dim TotalSectorsInFAT%
Dim TotalSectorsInMiniFAT%

Dim Root                     : Root = TRUE

Dim i As Integer, p As Integer

FATString$     = ""
MiniFATString$ = ""
ExtensionDES$  = Chr$( 0 ) & "D" & Chr$( 0 ) & "E" & Chr$( 0 ) & "S" & Chr$( 0 ) & Chr$( 0 )

' Extract fundamental information from the Header.

FileHeader$            = GetSectorData( HEADER_SECTOR )
FATSectorListInHeader$ = Mid$( FileHeader$, OFFSET_DIFAT_START, LENGTH_DIFAT )
TotalSectorsInFAT%     = CInt( HexVal( Mid$( FileHeader$, OFFSET_FAT_SECTORS_COUNT, DWORD ) ) )
TotalSectorsInMiniFAT% = CInt( HexVal( Mid$( FileHeader$, OFFSET_MINIFAT_SECTORS_COUNT, DWORD ) ) )
FirstSectorOfMiniFAT%  = CInt( HexVal( Mid$( FileHeader$, MINIFAT_START, DWORD ) ) )
If FirstSectorOfMiniFAT% = END_OF_CHAIN Then Exit Sub

' Make a single string of the sector contents from the list of FAT sector IDs. This
' string contains the complete FAT array and is an index to the contents of the file.
' Whereas my macro "MacroBookInspector" divides the string into the elements of an array,
' this macro simply reads 4-byte segments of the string as needed to retrieve sector IDs,
' because it uses the FAT only to find data comprising the ministream, which is where the
' macro description is stored. But because the FAT remains a string, rather than being
' transformed into an array, the size of the file that can be analyzed and included in
' the index is limited. The maximum string size this macro can handle (and the OML limit
' is insignificantly higher) is 31744. That size string can contain 7936 4-byte sector
' IDs. A file composed of 7936 sectors, at 512 bytes per sector, is 4063232 bytes in
' size. Therefore, the maximum size of a macro book macro that can be included in the
' index this macro builds is just over 4 MB. The reason I chose to keep the FAT array in
' a single string is to improve performance and keep the macro light. Using multiple
' strings to accommodate larger files would certainly be possible, but would add
' complexity that, in my view, would not be worthwhile. (None of my own macrobooks are
' much over 1 MB.)

For i = 0 To TotalSectorsInFAT% - 1
  SectorID&  = HexVal( Mid$( FATSectorListInHeader$, i * DWORD + STRING_OFFSET, DWORD ) )
  FATString$ = FATString$ & GetSectorData( SectorID& )
  If Len( FATString$ ) > MAX_STRING_LENGTH Then
      ErrorMessage$ = "Sorry, the macro book " & MacroBooksList( BookIndex% ) & " is too large to include in this index."
      Exit Sub
  End If
Next i

' Also make a single string of the sector contents from the list of miniFAT sector IDs.
' The size restriction on the length of the string representing the FAT applies to the
' miniFAT also, although it seems unlikely this limit would ever be reached.

NextSector&    = FirstSectorOfMiniFAT%

MiniFATString$ = GetSectorData( NextSector& )

Do Until NextSector& = END_OF_CHAIN
  Index&      = ( NextSector& * DWORD ) + STRING_OFFSET
  NextSector& = HexVal( Mid$( FATString$, Index&, DWORD ) )
  If NextSector& < 1 Then
      Exit Do
    Else
      MiniFATString$ = MiniFATString$ & GetSectorData( NextSector& )
      If Len( MiniFATString$ ) > MAX_STRING_LENGTH Then
          ErrorMessage$ = "Sorry, the macro book " & MacroBooksList( BookIndex% ) & " is too large to include in this index."
          Exit Sub
      End If
  End If
Loop

' Get the fundamental directory information.

FirstSectorOfDirectory& = HexVal( Mid$( FileHeader$, OFFSET_DIR_START, DWORD ) )
RootStorageEntry$       = Left$( GetSectorData( FirstSectorOfDirectory& ), DIR_ENTRY_LENGTH )
MinistreamStart&        = HexVal( Mid$( RootStorageEntry$, MINISTREAM_START, DWORD ) )

' Start assembling the directory entries. Follow the directory sectors to the end of the
' chain.

Index&      = DWORD + STRING_OFFSET
NextSector& = FirstSectorOfDirectory&
Do Until NextSector& = END_OF_CHAIN

' Macro names may also be stored in the first sector of the directory, which is not part
' of the chain of sector IDs. This root entry is nonetheless included in the processing
' as if it were.

  If Root = TRUE Then
      SectorData$ = GetSectorData( FirstSectorOfDirectory& )
      Root        = FALSE
    Else
      Index&      = ( NextSector& * DWORD ) + STRING_OFFSET
      NextSector& = HexVal( Mid$( FATString$, Index&, DWORD ) )
      If NextSector& < 1 Then
          Exit Do
        Else
          SectorData$ = GetSectorData( NextSector& )
      End If
  End If

' Each directory sector contains four 128-byte strings that contain directory information
' about the macros. There are three entries for every macro, identifying data streams
' containing the textual source code for the macro, the compiled binary executable, and
' the textual description. The streams have the extensions ".src", ".bin", and ".des",
' respectively. Choose the ".des" form for the list and find the description for display.
' This data is in Unicode, so the macro proceeds by finding the first dot, or period, in
' the first 64 bytes of the string, and then checking every other character to match the
' string "D E S  " (where the blank spaces are really the null character).

  For SectorQuarter% = 0 To 3
    CandidateEntry$ = Mid$( SectorData$, ( SectorQuarter% * DIR_ENTRY_LENGTH ) + STRING_OFFSET, DIR_ENTRY_LENGTH )
      p = InStr( Left$( CandidateEntry$, 64 ), "." )
      If p <> 0 Then
          If Mid$( CandidateEntry$, p + 1, 8 ) = ExtensionDES$ Then
              MacroName$      = ""
              For i = 1 To p - 1 Step 2
                MacroName$ = MacroName$ & Mid$( CandidateEntry$, i, 1 )
              Next i

' With the macro name in hand, start building the entry for the main list.

              MacroInfo.tName  = MacroName$
              MacroInfo.tIndex = BookIndex%

' Continue by getting the description.

              StreamSize&     = HexVal( Mid$( CandidateEntry$, OFFSET_SIZE_MINISTREAM, DWORD ) )
              NextMiniSector& = HexVal( Mid$( CandidateEntry$, FIRST_SECTOR_MINISTREAM, DWORD ) )
              Description$    = ""
              Description$    = GetDescription( MinistreamStart&, StreamSize&, NextMiniSector& )

' Finish building the macro entry and ship it off to the subprogram to add it, in
' alphabetical order for whichever macro book is currently being analyzed.

              MacroInfo.tDesc  = Description$
              PrevBookID%     = -1
              Call MakeMainList( MacroInfo )
          End If
      End If
  Next SectorQuarter%
Loop

End Sub

'****************************************************************************************

Sub MakeMainList( MacroInfo As Container )

' When a macro book is selected, only the macros in that book are displayed. This simple
' insertion sort sorts those macros in alphabetical order as they are added to the array.

Dim CurrBookID%
Dim CurrentMacroName$
Dim IncomingMacroName$

Dim i As Integer, j As Integer, z As Integer

IncomingMacroName$ = MacroInfo.tName
CurrBookID%        = MacroInfo.tIndex
If MainList( 0 ).tName = "" Then
    z = 0
  Else
    z = UBound( MainList ) + 1
    ReDim Preserve MainList( z )
    PrevBookID% = MainList( z - 1 ).tIndex
End If

If CurrBookID% <> PrevBookID% Then

' The very first name in each macro book block is added without any more ado.

    MainList( z ) = MacroInfo
    PrevBookID%     = CurrBookID%
    BaseBookBlock%  = z
  Else
    For i = BaseBookBlock% To z
      CurrentMacroName$ = MainList( i ).tName
      Select Case StrComp( IncomingMacroName$, CurrentMacroName$ )

' If the new name files before the name being examined, insert it, bumping all subsequent
' names one position toward the end.

        Case STRING1_LESS_THAN
          For j = z To i + 1 Step -1
            MainList( j ) = MainList( j - 1 )
          Next j
          MainList( j ) = MacroInfo
          Exit For

' If the new name files after the one being examined, continue going up the array,
' comparing new and existing entries--unless the end of the array has been reached, in
' which case, simply add the name.

        Case STRING1_GREATER_THAN
          If i = z Then
              MainList( z ) = MacroInfo
          End If
      End Select
    Next i
End If

End Sub

'****************************************************************************************

Sub ReadFile( SelectedMacroBook$ )

' This subprogram reads the file whose name is passed to it and stores the data in a
' string array for the rest of the macro.

Dim FILE_SECTION_READ As String*MAX_STRING_LENGTH

Dim CountFileSections%
Dim FileDivider&
Dim FileEnd$
Dim FileNumber%
Dim FileSize&
Dim MacroBookFile$
Dim MacroBookName$
Dim Remainder%
Dim TotalFileSections%

MacroBookName$ = SelectedMacroBook$
MacroBookFile$ = MacroDirectoryPath$ & MacroBookName$ & ".mbk"

FileNumber% = Freefile

' Open the selected file. Because of the limitations on string length in OCLC's version
' of BASIC, the file can only be read in chunks of about 32K bytes, so the macro may
' have to loop through it several times to read it all. The chunk size is set at 31744
' bytes, the largest multiple of 512 (the expected sector size) to fit safely under the
' limit.

Open MacroBookFile$ For Binary As #FileNumber%
FileSize&          = FileLen( MacroBookFile$ )
TotalFileSections% = FileSize& \ MAX_STRING_LENGTH
Remainder%         = FileSize& Mod MAX_STRING_LENGTH
FileDivider&       = 1&
CountFileSections% = 0

' Read the file, storing it in "FileSections," a string array whose elements are of
' maximum length 31744, or 62 sectors--so a sector is not broken between strings.

If TotalFileSections% > 0 Then
    For CountFileSections% = 1 To TotalFileSections%
      Get #FileNumber%, FileDivider&, FILE_SECTION_READ
      ReDim Preserve FileSections( CountFileSections% - 1 )
      FileSections( CountFileSections% - 1 ) = FILE_SECTION_READ
      FileDivider& = FileDivider& + MAX_STRING_LENGTH
    Next CountFileSections%
End If
If Remainder% > 0 Then
    Get #FileNumber%, FileDivider&, FILE_SECTION_READ
    FileEnd$ = Left$( FILE_SECTION_READ, Remainder% )
    If CountFileSections% > 0 Then
        CountFileSections% = CountFileSections% - 1
    End If
    ReDim Preserve FileSections( CountFileSections% )
    FileSections( CountFileSections% ) = FileEnd$
End If

Close #FileNumber%
Reset

End Sub

'****************************************************************************************

Sub SortAllMacros( LeftSide%, RightSide% )

' This routine performs an in-place, recursive sorting of the whole macro list using an
' algorithm published by IBM as an example in the documentation for its CognosScript
' Language. IBM calls this example "Quicksort." Sorting is case-insensitive, as specified
' by the Option Compare statement at the very beginning of the macro. This subroutine is
' much quicker than the subroutine that actually constructs the array.

Dim CompPivot$
Dim CompStringI$
Dim CompStringJ$
Dim Pivot As Container
Dim TempContainer As Container

Dim i as integer, j As Integer

If ( RightSide% > LeftSide% ) Then
    i = LeftSide% - 1
    j = RightSide%
    Pivot         = MainList( RightSide% )
    MainList( 0 ) = Pivot

' Making a single string of the macro name and the macro book name ensures complete
' alphabetical sorting.

    CompPivot$    = Pivot.tName & MacroBooksList( Pivot.tIndex )
    Do
      Do
        i  = i + 1
        CompStringI$ = MainList( i ).tName & MacroBooksList( MainList( i ).tIndex )
      Loop Until StrComp( CompStringI$, CompPivot$ ) > STRING1_LESS_THAN
      Do
        j  = j - 1
        CompStringJ$ = MainList( j ).tName & MacroBooksList( MainList( j ).tIndex )
      Loop Until StrComp( CompStringJ$, CompPivot$ ) < STRING1_GREATER_THAN
      TempContainer   = MainList( i )
      MainList( i ) = MainList( j )
      MainList( j ) = TempContainer
    Loop Until j <= i
    MainList( j )          = MainList( i )
    MainList( i )          = MainList( RightSide% )
    MainList( RightSide% ) = TempContainer

    Call SortAllMacros( LeftSide%, i - 1 )
    Call SortAllMacros( i + 1, RightSide% )

End If

End Sub

'****************************************************************************************

Sub WriteFile( Selection%, State% )

' This is the file writing subprogram. The variable "State" tells what list is being
' displayed in the dialog box--all the macros, only those in a specific macro book, or
' those resulting from a search. That determines the file name for the list. A header of
' a few lines is added at the beginning of the list containing some details including the
' date of file production. Tabs are used to separate columns, useful in making tables
' from this text in a word processing program.

Dim TAB_CHAR As String*1     : TAB_CHAR = Chr$( 009 )

Dim Answer%
Dim Credit$        'shameless self-promotion
Dim DateString$
Dim FileAttributes%
Dim FileWrite%
Dim Legend$
Dim MacroBookName$
Dim Scope$

Dim i as Integer

Credit$ = " using " & DOUBLE_QUOTE & "MacroIndex" & DOUBLE_QUOTE & " macro by Walter F. Nickeson."

Select Case State%

  Case ALL_MACROS
    Scope$  = "AllMacros"
    Legend$ = "Save list of macros as:"

  Case BOOK_MACROS
    Scope$  = MacroBooksList( Selection% )
    Legend$ = "Save list of macros in macro book " & DOUBLE_QUOTE & Scope$ & DOUBLE_QUOTE & " as:"

  Case SEARCH_RESULTS
    Scope$  = "SelectedMacros"
    Legend$ = "Save list of macros as:"

End Select

FileName$            = MacroDirectoryPath$ & Scope$ & ".txt"
PrevSearchPaths( 0 ) = FileName$

Begin Dialog Dialog2Definition  320, 58, WaltsMacros$, .Dialog2ControlFunction
  OkButton      260, 36,  52, 14
  CancelButton  200, 36,  52, 14
  PushButton      8, 36,  52, 14, "Clear",           .Clear
  DropComboBox    8, 16, 304, 64, PrevSearchPaths(), .ComboBox
  Text            8,  6, 256,  8, Legend$
End Dialog

Dim Dialog2 As Dialog2Definition
On Error Resume Next
Dialog Dialog2
If Err = DLG_STATEMENT_CANCEL Then Exit Sub

FileName$            = Dialog2.ComboBox

' Replace the default save location (the first element of the array) with the actual
' location entered, and then push all the elements up one to leave an open first element
' for the next save operation.

PrevSearchPaths( 0 ) = FileName$
SaveCount%           = SaveCount% + 1
ReDim Preserve PrevSearchPaths( SaveCount% )
For i = UBound( PrevSearchPaths ) To 0 Step -1
  PrevSearchPaths( i ) = PrevSearchPaths( i - 1 )
Next i

' Check for the existence of the file. If it exists, confirm overwriting.

On Error Resume Next
FileAttributes% = GetAttr( FileName$ )
If Err <> 53 Then      'Error 53 means: File not found.
    If FileAttributes% < 8 Or FileAttributes% > 16 Then
        Answer% = MsgBox( "Replace existing file?", 35, WaltsMacros$ )
        If Answer% = 6 Then
            Kill FileName$
          Else
            Exit Sub
        End If
    End If
End If

DateString$ = Date$ & " " & Time$
DateString$ = Format( DateString$, "General Date" )
FileWrite%  = FreeFile

Open FileName$ For Output As #FileWrite%

' Write to the file, starting with the header.

Select Case State%

  Case ALL_MACROS
    Print #FileWrite%, "Macros in folder " & MacroDirectoryPath$
    Print #FileWrite%,
    Print #FileWrite%, "List created " & DateString$ & Credit$
    Print #FileWrite%,
    Print #FileWrite%, Trim$( Str$( UBound( MainList ) ) ) & " macros in all:"
    Print #FileWrite%,
    Print #FileWrite%, "Macro name" & TAB_CHAR & "Macro book" & TAB_CHAR & "Macro description"
    For i = 1 To UBound( MainList )
      Print #FileWrite%, MainList( i ).tName & TAB_CHAR & Trim$( Str$( MacroBooksList( MainList( i ).tIndex ) ) ) & TAB_CHAR & MainList( i ).tDesc
    Next i

  Case BOOK_MACROS
    Print #FileWrite%, "Macros in macro book " & DOUBLE_QUOTE & MacroBookName$ & DOUBLE_QUOTE & "."
    Print #FileWrite%,
    Print #FileWrite%, "List created " & DateString$ & Credit$
    Print #FileWrite%,
    Print #FileWrite%, Trim$( Str$( UBound( MacroBookMacros ) + 1 ) ) & " macros in " & DOUBLE_QUOTE & MacroBookName$ & DOUBLE_QUOTE & ":"
    Print #FileWrite%,
    Print #FileWrite%, "Macro name" & TAB_CHAR & "Macro description"
    For i = 0 To UBound( MacroBookMacros )
      Print #FileWrite%, MacroBookMacros( i ).tName & TAB_CHAR & MacroBookMacros( i ).tDesc
    Next i

  Case SEARCH_RESULTS
    Print #FileWrite%, "Selected macros in folder " & MacroDirectoryPath$
    Print #FileWrite%,
    Print #FileWrite%, "List created " & DateString$ & Credit$
    Print #FileWrite%,
    Print #FileWrite%, Trim$( Str$( UBound( SearchMatchDisplay ) + 1 ) ) & " macros matching search term " & DOUBLE_QUOTE & SearchTerm$ & DOUBLE_QUOTE & ":"
    Print #FileWrite%,
    Print #FileWrite%, "Macro name" & TAB_CHAR & "Macro book" & TAB_CHAR & "Macro description"
    For i = 0 To UBound( SearchMatchDisplay )
      Print #FileWrite%, SearchMatches( i ).tName & TAB_CHAR & MacroBooksList( SearchMatches( i ).tIndex ) & TAB_CHAR & SearchMatches( i ).tDesc
    Next i

End Select

MsgBox "List of macros saved.", INFORMATION_MESSAGE, WaltsMacros$

Close FileWrite%
Reset

End Sub

'****************************************************************************************

Function GetDescription( MinistreamStart&, StreamSize&, NextMiniSector& ) As String

' This function gets the macro description from the ministream, the array of 64-byte
' sectors used in macro book files for the smaller data streams. This macro can't
' reconcile differences between macro descriptions contained in the ministream and macro
' descriptions contained in the code of the macro as entered in the macro editor.
' However, my macro "MacroBookInspector" is able to detect those differences.

Const MINI_SECTOR_SIZE As Integer = 64  'The size in bytes of minisectors.

Dim MiniSectorData$
Dim NextSector&
Dim Sector8th%
Dim SectorData$
Dim SectorDifference%

Dim i As Integer

' Each minisector is 1/8 of a large sector. Given the large sector in which the
' ministream starts, follow the ministream chain, counting eight minisectors per large
' sector, to get to the large sector in which the next eight ministream sectors can be
' found.

If NextMiniSector& > -1 Then
    SectorDifference% = NextMiniSector& \ 8
    Sector8th%        = NextMiniSector& Mod 8
    NextSector&       = MinistreamStart&
    If SectorDifference% > 0 Then
        For i = 1 To SectorDifference%
          NextSector& = HexVal( Mid$( FATString$, ( NextSector& * DWORD ) + STRING_OFFSET, DWORD ) )
        Next i
    End If
    SectorData$       = GetSectorData( NextSector& )
    MiniSectorData$   = Mid$( SectorData$, ( Sector8th% * MINI_SECTOR_SIZE ) + STRING_OFFSET, MINI_SECTOR_SIZE )
    Description$      = Description$ & MiniSectorData$
    NextMiniSector&   = HexVal( Mid$( MiniFATString$, ( NextMiniSector& * DWORD ) + STRING_OFFSET, DWORD ) )

' Test each subsequent miniFAT sector to see if it marks the end of the description
' stream. If it does not, get the data in that sector of the ministream and add it to the
' existing data stream. Continue getting data from the file by calling the sub again,
' with a new value for the next minisector. Otherwise, trim the string according to the
' stream size. The small size of the Description box when creating a macro suggests a
' short description that might fit into only one minisector, although no limitation to
' the length of the description seems to be given anywhere.

    If NextMiniSector& < 1 Then
        Description$ = Left$( Description$, StreamSize& )
      Else
        Description$ = GetDescription( MinistreamStart&, StreamSize&, NextMiniSector& )
    End If
  Else
    Description$ = "[NO DESCRIPTION PROVIDED]"
End If

GetDescription = Description$

End Function

'****************************************************************************************

Function GetSectorData( SectorID& ) As String

' Given a sector ID from the FAT string, this function retrieves the data in that sector
' of the file. Since the first character in a string is at position 1, but the first
' element of an array is numbered 0, an offset of 1 has to be added.

Dim StartPos&
Dim WhichElement%

StartPos&     = ( SectorID& * SECTOR_SIZE ) + SECTOR_SIZE + STRING_OFFSET
WhichElement% = Int( StartPos& / MAX_STRING_LENGTH )
StartPos&     = StartPos& - ( MAX_STRING_LENGTH * CLng( WhichElement% ) )
GetSectorData = Mid$( FileSections( WhichElement% ), StartPos&, SECTOR_SIZE )

End Function

'****************************************************************************************

Function HexVal( InBytes$ ) As Long

' This function converts the string of bytes to a hex number and then to decimal (thanks
' to Joel Hahn for insight into this function).

Dim ASCIIChar%
Dim Byte$
Dim HexString$

Dim i As Integer

For i = 1 To Len( InBytes$ )
  ASCIIChar% = Asc( Mid$( InBytes$, i, 1 ) )
  Byte$      = Hex$( ASCIIChar% )
  If Len(Byte$) = 1 Then
      Byte$ = "0" & Byte$
  End If
  HexString$ = Byte$ & HexString$
Next i

HexString$ = "&H" & Trim$( UCase$( HexString$ ) )
HexVal     = Val( HexString$ )

End Function

'****************************************************************************************

Function Dialog1ControlFunction( Id$, Action%, SuppVal& )

' The control function for the dialog box.

Const CASE_INSENSITIVE As Integer = 1
Const CASE_SENSITIVE   As Integer = 0
Const DISABLED         As Integer = 0
Const ENABLED          As Integer = 1
Const INVISIBLE        As Integer = 0
Const UNCHECKED        As Integer = 0
Const VISIBLE          As Integer = 1

Dim Candidate$
Dim HitCount%
Dim MacroBookName$
Dim MacroCountLegend$
Dim MatchCase%
Dim Selection%

Dim i As Integer

Dim MacroListBook() As String

Select Case Action%

  Case INITIALIZE

' The opening state of the macro display is the list of all macros with their count and
' the instructions on the operation of the macro.

    State%           = ALL_MACROS
    TotalMacroCount% = UBound( MainList )
    If TotalMacroCount% = 1 Then
        MacroCountLegend$ = Trim$( Str$( TotalMacroCount% ) ) & " macro:"
      Else
        MacroCountLegend$ = Trim$( Str$( TotalMacroCount% ) ) & " macros:"
    End If
    DlgVisible      "BookCount",        VISIBLE
    DlgVisible      "Desc",             INVISIBLE
    DlgVisible      "DescBox",          INVISIBLE
    DlgVisible      "Instruct",         VISIBLE
    DlgValue        "ListOfMacroBooks", MainList( 1 ).tIndex
    DlgFocus        "ListOfMacros"
    DlgText         "MacroCount",       MacroCountLegend$


  Case CONTROL_CHANGE

    Select Case Id$

' When a macro in the list is clicked, its containing macro book appears in the drop-down
' list box, and the description of the macro replaces the instructions.

      Case "ListOfMacros"

        DlgVisible      "Desc",             VISIBLE
        DlgVisible      "DescBox",          VISIBLE
        DlgVisible      "Instruct",         INVISIBLE

        Select Case State%

          Case ALL_MACROS
            Selection% = DlgValue( "ListOfMacros" ) + 1
            DlgText         "Desc",             MainList( Selection% ).tDesc
            DlgValue        "ListOfMacroBooks", MainList( Selection% ).tIndex

          Case BOOK_MACROS
            Selection% = DlgValue( "ListOfMacros" )
            DlgText         "Desc",             MainListByBooks( Selection% + BookBlockOffset% ).tDesc

          Case SEARCH_RESULTS
            Selection% = DlgValue( "ListOfMacros" )
            DlgText         "Desc",             MainList( LinkMatchToMain( Selection% ) ).tDesc
            DlgValue        "ListOfMacroBooks", MainList( LinkMatchToMain( Selection% ) ).tIndex

        End Select

' If a macro book is selected, display only the macros in that book, and change the count
' of macros in the macro list window. Also enable the button to show all the macros.

      Case "ListOfMacroBooks"

        State%           = BOOK_MACROS
        Selection%       = DlgValue( "ListOfMacroBooks" )
        Call FillMacroBookMacros( Selection% )
        ReDim MacroListBook( UBound( MacroBookMacros) )
        For i = 0 To UBound( MacroBookMacros)
          MacroListBook( i ) = MacroBookMacros( i ).tName
        Next i
        MacroBookName$   = MacroBooksList( Selection% )
        TotalMacroCount% = UBound( MacroBookMacros ) + 1
        If TotalMacroCount% = 1 Then
            MacroCountLegend$ = Trim$( Str$( TotalMacroCount% ) ) & " macro in " & DOUBLE_QUOTE & MacroBookName$ & DOUBLE_QUOTE & ":"
          Else
            MacroCountLegend$ = Trim$( Str$( TotalMacroCount% ) ) & " macros in " & DOUBLE_QUOTE & MacroBookName$ & DOUBLE_QUOTE & ":"
        End If
        DlgVisible      "BookCount",        INVISIBLE
        DlgText         "Desc",             MainListByBooks( BookBlockOffset% ).tDesc
        DlgVisible      "Desc",             VISIBLE
        DlgVisible      "DescBox",          VISIBLE
        DlgVisible      "Instruct",         INVISIBLE
        DlgValue        "ListOfMacroBooks", Selection%
        DlgListBoxArray "ListOfMacros",     MacroListBook()
        DlgFocus        "ListOfMacros"
        DlgValue        "ListOfMacros",     0
        DlgText         "MacroCount",       MacroCountLegend$
        DlgText         "ViewButton",       "View &all macros"

' The viewing button determines the state of the dialog box, toggling back and forth
' between the list of all macros and the list of an individual macro book.

      Case "ViewButton"

        If State%           = ALL_MACROS Then
            State%           = BOOK_MACROS
            Selection%       = DlgValue( "ListOfMacroBooks" )
            Call FillMacroBookMacros( Selection% )
            ReDim MacroListBook( UBound( MacroBookMacros) )
            For i = 0 To UBound( MacroBookMacros)
              MacroListBook( i ) = MacroBookMacros( i ).tName
            Next i
            MacroBookName$   = MacroBooksList( Selection% )
            TotalMacroCount% = UBound( MacroBookMacros ) + 1
            If TotalMacroCount% = 1 Then
                MacroCountLegend$ = Trim$( Str$( TotalMacroCount% ) ) & " macro in " & DOUBLE_QUOTE & MacroBookName$ & DOUBLE_QUOTE & ":"
              Else
                MacroCountLegend$ = Trim$( Str$( TotalMacroCount% ) ) & " macros in " & DOUBLE_QUOTE & MacroBookName$ & DOUBLE_QUOTE & ":"
            End If
            DlgVisible      "BookCount",        INVISIBLE
            DlgText         "Desc",             MainListByBooks( BookBlockOffset% ).tDesc
            DlgVisible      "Desc",             VISIBLE
            DlgVisible      "DescBox",          VISIBLE
            DlgVisible      "Instruct",         INVISIBLE
            DlgListBoxArray "ListOfMacros",     MacroListBook()
            DlgFocus        "ListOfMacros"
            DlgValue        "ListOfMacros",     0
            DlgText         "MacroCount",       MacroCountLegend$
            DlgText         "ViewButton",       "View &all macros"
            Dialog1ControlFunction      = KEEP_DLG_OPEN
          Else
            State%           = ALL_MACROS
            TotalMacroCount% = UBound( MainList )
            If TotalMacroCount% = 1 Then
                MacroCountLegend$ = Trim$( Str$( TotalMacroCount% ) ) & " macro:"
              Else
                MacroCountLegend$ = Trim$( Str$( TotalMacroCount% ) ) & " macros:"
            End If
            Selection%       = DlgValue( "ListOfMacroBooks" )
            DlgVisible      "BookCount",        VISIBLE
            DlgText         "Desc",             MainList( 1 ).tDesc
            DlgVisible      "Instruct",         INVISIBLE
            DlgValue        "ListOfMacroBooks", MainList( 1 ).tIndex
            DlgListBoxArray "ListOfMacros",     MacroListByNames()
            DlgFocus        "ListOfMacros"
            DlgValue        "ListOfMacros",     0
            DlgText         "MacroCount",       MacroCountLegend$
            DlgText         "ViewButton",       "View macros in this macro &book"
            Dialog1ControlFunction      = KEEP_DLG_OPEN
        End If

      Case "Save"

        DlgVisible      "Instruct",         INVISIBLE
        If State% = ALL_MACROS Or State% = SEARCH_RESULTS Then
            Selection% = -1
          Else
            Selection% = DlgValue( "ListOfMacroBooks" )
        End If
        Call WriteFile( Selection%, State% )
        Dialog1ControlFunction      = KEEP_DLG_OPEN

      Case "Copy"

        DlgVisible      "Instruct",         INVISIBLE
        Call CopyList( State% )
        Dialog1ControlFunction      = KEEP_DLG_OPEN

      Case "Search"

        DlgVisible      "Instruct",         INVISIBLE
        SearchTerm$ = ""

        Begin Dialog Dialog3Definition  176,  82, WaltsMacros$
          TextBox         8,  28, 160,  12,                             .TextBox
          OkButton       56,  60,  52,  14
          CancelButton  116,  60,  52,  14
          Text            8,   6, 160,  16, "Enter a search term to search all macro names and descriptions:"
          CheckBox       12,  42,  56,  12, "Match case",               .CheckBox1
          CheckBox       76,  42,  92,  12, "Search descriptions only", .CheckBox2
        End Dialog

        Dim Dialog3 As Dialog3Definition
        On Error Resume Next
        Dialog Dialog3
        If Err = DLG_STATEMENT_CANCEL Then GoTo CloseSearch:

        SearchTerm$ = Trim$( Dialog3.TextBox )
        If SearchTerm$ = "" Then
            GoTo CloseSearch:
          Else
            ReDim SearchMatchDisplay( 0 )
            ReDim SearchMatches( 0 )
            ReDim LinkMatchToMain( 0 )
            MatchCase% = Dialog3.CheckBox1
            If MatchCase% = UNCHECKED Then
                MatchCase% = CASE_INSENSITIVE
              Else
                MatchCase% = CASE_SENSITIVE
            End If
            If Dialog3.CheckBox2 = UNCHECKED Then
                Candidate$ = MainList( i ).tName & MainList( i ).tDesc
              Else
                Candidate$ = MainList( i ).tDesc
            End If
            For i = 1 To UBound( MainList )
              Candidate$ = MainList( i ).tName & MainList( i ).tDesc
              If InStr( 1, Candidate$, SearchTerm$, MatchCase% ) Then
                  ReDim Preserve SearchMatchDisplay( HitCount% )
                  ReDim Preserve SearchMatches( HitCount% )
                  ReDim Preserve LinkMatchToMain( HitCount% )
                  SearchMatchDisplay( HitCount% ) = MainList( i ).tName
                  SearchMatches( HitCount% )      = MainList( i )
                  LinkMatchToMain( HitCount% )  = i
                  HitCount%                       = HitCount% + 1
              End If
            Next i
        End If
        If HitCount% = 0 Then
            MsgBox "Sorry, nothing matched your search.", INFORMATION_MESSAGE, WaltsMacros$
            GoTo CloseSearch:
          Else
            DlgListBoxArray "ListOfMacros",     SearchMatchDisplay()
            State%           = SEARCH_RESULTS
            TotalMacroCount% = UBound( SearchMatchDisplay ) + 1
            If TotalMacroCount% = 1 Then
                MacroCountLegend$ = Trim$( Str$( TotalMacroCount% ) ) & " macro matching search term " & DOUBLE_QUOTE & SearchTerm$ & DOUBLE_QUOTE & ":"
              Else
                MacroCountLegend$ = Trim$( Str$( TotalMacroCount% ) ) & " macros matching search term " & DOUBLE_QUOTE & SearchTerm$ & DOUBLE_QUOTE & ":"
            End If
            DlgText         "Desc",             MainList( LinkMatchToMain( 0 ) ).tDesc
            DlgVisible      "Desc",             VISIBLE
            DlgVisible      "DescBox",          VISIBLE
            DlgValue        "ListOfMacroBooks", MainList( LinkMatchToMain( 0 ) ).tIndex
            DlgFocus        "ListOfMacros"
            DlgValue        "ListOfMacros",     0
            DlgText         "MacroCount",       MacroCountLegend$
        End If

CloseSearch:

        Dialog1ControlFunction = KEEP_DLG_OPEN

    End Select

End Select

End Function

'****************************************************************************************

Function Dialog2ControlFunction( Id$, Action%, SuppVal& )

' Controls the saving of the list to a text file.

Dim EntryName$

Select Case Action%

  Case INITIALIZE

    DlgText         "ComboBox",         PrevSearchPaths( 0 )


  Case CONTROL_CHANGE

    Select Case Id$
      Case "Clear"
        DlgText         "ComboBox",         ""
        Dialog2ControlFunction = KEEP_DLG_OPEN

      Case "Ok"
        EntryName$ = DlgText( "ComboBox" )
        If EntryName$ = "" Then
            MsgBox "Please enter a full path!", MSGBOX_WARNING, WaltsMacros$
            DlgText         "ComboBox",         FileName$
            Dialog2ControlFunction = KEEP_DLG_OPEN
          Else
            If Left$( EntryName$, 3 ) Like "[A-Za-z]:\" Then
              Else
                MsgBox "Please enter a valid path!", MSGBOX_WARNING, WaltsMacros$
                DlgText         "ComboBox",         FileName$
                Dialog2ControlFunction = KEEP_DLG_OPEN
            End If
        End If

    End Select

End Select

End Function
'126850730
'
'Macro name: MacroIndex
'Macro book: C:\Users\wnickeson.UR\AppData\Roaming\OCLC\Connex\Macros\MacroTools.mbk
'Saved: 8/22/2023 10:05:02 AM using "MacroBookInspector" macro by Walter F. Nickeson.
