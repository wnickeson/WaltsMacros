'MacroName:CopyFields.2024.01
'MacroDescription:Copies multiple fields from one bibliographic record and returns to
' another to paste them in. The copied fields can be a block of contiguous fields or a
' collection of separate, non-contiguous fields.
'
' This macro was written by Walter F. Nickeson,
' University of Rochester, Rochester, NY
' wnickeson@library.rochester.edu
' https://orcid.org/0000-0003-0484-6938
'
' The dialog box interface was inspired by the macro "CopyMultiple" by Joel Hahn, Niles
' Public Library District, 2007, but all responsibility for the functionality of this
' macro is mine alone.
'
' Last updated: 6 February 2024.
' Check for the latest versions of this and my other macros at
' https://github.com/wnickeson/WaltsMacros
' Please e-mail me with bug reports or to suggest improvements.
'
' This macro works for me with Connexion client 3.1 and Windows 11 Enterprise & 64-bit
' Windows 10 Pro, but no guarantees are promised or implied.
'
'****************************************************************************************
' How it works: This macro copies, in one operation, any number of fields from one
' bibliographic record to another. Select a block of fields in a record with the mouse
' and run the macro to copy the whole block; or run the macro with nothing selected and
' use the dialog box to choose the fields to copy. Using the dialog box to select fields
' means the fields need not be contiguous. In both cases, the macro proceeds by showing
' all open bibliographic records, one at a time, until the correct record is found into
' which the copied fields can be pasted; except that if only a single target record is
' open, the copying is done immediately, without a request for confirmation. Duplicate
' fields are not copied.
'
' Begin with both source and target record(s) open. They may be tiled or pinned, and
' other windows of records and lists may also be open, but the source record must be on
' top--that is, the record being copied from must have the focus. When selecting fields
' before running the macro, click and drag the mouse pointer anwhere in any field and
' drag up or down to select several contiguous fields. (Controlled fields may be somewhat
' resistant to being selected in that manner. Uncontrolling the fields is the best way to
' make them easily selectable; the next best way is to use the [SHIFT] and up and down
' arrow keys; the other way is to click in the tag cell to start the dragging operation,
' rather than in the field data cell.) A field need be only partially selected to be
' included in the group of fields. A single partially selected field will be copied by
' itself, in its entirety. If the macro is run without anything having been selected, it
' displays a dialog box with two windows, one showing the fields of the source record,
' the other--initially empty--showing fields selected for copying. Click on a field in
' the source window to move it to the copy window; click on a field in the copy window to
' move it back to the source window. When selection of fields for copying is complete,
' click the OK button.
'
' No matter how the fields were chosen, the macro continues by either copying the fields
' immediately into the single candidate record, or cycling through all the windows
' containing bibliographic records. For each record displayed, the macro asks if the
' copied fields should be pasted into it. When the copied fields are pasted, each one is
' added as the last field in its tag group. Duplicate fields are excluded from pasting.
'
' A new record (i.e., a workform) is always displayed before other candidate target
' records; the macro assumes that a new record is more likely to be filled with
' information from an existing record than vice versa. But the macro may have trouble
' copying fields from one "NEW" record to another if one of those records hasn't been
' saved first.
'
' To copy fields containing non-Latin scripts, run the macro with no fields selected, so
' as to invoke the dialog box. Selecting those fields with the mouse pointer will not
' work unless the selection is within a field. Apart from this limitation, the macro
' copies fields faithfully by using the "GetFieldUnicode" and "AddField" commands to copy
' and paste. These macro commands bypass the Windows clipboard, which normally can't
' handle all the characters that may be in a MARC record.
'
' Joel Hahn's "CopyMultiple" macro, whose interface inspired the dialog box in this
' macro, does copy fields to the clipboard, and in doing so does preserve special
' characters.
'****************************************************************************************

Option Explicit

Declare Sub MoveFields( Selection%, _
                        FromFieldsArray() As String, _
                        FromLinesArray() As Integer, _
                        ToFieldsArray() As String, _
                        ToLinesArray() As Integer )

Declare Function ConvertTo8859( InputString$ ) As String

Declare Function Dialog1ControlFunction( Id$, Action%, SVal& )
Declare Function Dialog2ControlFunction( Id$, Action%, SVal& )

Global Const CRITICAL_MESSAGE As Integer = 16
Global Const INVISIBLE        As Integer = 0

Global CandidateCount%
Global LastRemoved%
Global WaltsMacros$

Global Unicode

Global FieldsAvailable() As String
Global FieldsSelected()  As String
Global LinesAvailable()  As Integer
Global LinesSelected()   As Integer

'****************************************************************************************

Sub Main

Dim CS As Object
On Error Resume Next
Set CS = GetObject( , "Connex.Client" )
On Error GoTo 0
If CS Is Nothing Then Set CS = CreateObject( "Connex.Client" )

Const CANCEL               As Integer = 102
Const DIALOG_BUTTON_1      As Integer = 1
Const DIALOG_BUTTON_CANCEL As Integer = 0
Const DIALOG_BUTTON_OK     As Integer = -1
Const DISPLAY_FF_AT_TOP    As Integer = 1
Const INFORMATION_MESSAGE  As Integer = 64
Const WINDOW_ID            As Integer = 0
Const WINDOW_OCLC_NO       As Integer = 2
Const WINDOW_TITLE         As Integer = 1

Dim END_OF_FIELD As String*1 : END_OF_FIELD = Chr$( 013 ) & Chr$( 010 )

Dim BeginningRow%
Dim CandidateOCLCCN$
Dim CandidateReplaced$
Dim CountOfCopiedFields%
Dim CountOfWindows%
Dim CurrentColumn%
Dim CurrentRow%
Dim Dialog2Value%
Dim Difference%
Dim DuplicateCount%
Dim EndOfFieldCount%
Dim EndOfFieldFound%
Dim FieldData$
Dim FieldDataConverted$
Dim FieldWord$
Dim FixedFieldData$
Dim Ind1$
Dim Ind2$
Dim Instance%
Dim PosFF%
Dim Query$
Dim RecordCount$
Dim RemoveInstruction$
Dim SelectedText$
Dim SetWindowID%
Dim SourceOCLCCN$
Dim SourceReplaced$
Dim Start%
Dim Tag$
Dim TempString$
Dim TypeOfWindow%
Dim UnicodeWarning$
Dim WindowTitle$

Dim Duplicate
Dim FoundField
Dim SelectedUp               : SelectedUp = FALSE
Dim Selection

Dim FieldsCopied()   As String
Dim FieldsOriginal() As String
Dim WindowIDs()      As String

Dim i As Integer, j As Integer, p As Integer

Unicode      = FALSE
WaltsMacros$ = "[Walt's macros] Essentials:CopyFields"

' First, check to see that some text has been selected. If text has been selected we know
' we are in a record, as opposed to a list. And if text has been selected, keep track of
' where the cursor is, because the test for the window type moves it--but its original
' location is a vital piece of information.

If CS.GetSelectedText( SelectedText$ ) Then
    CurrentColumn% = CS.CursorColumn
    CurrentRow%    = CS.CursorRow
End If

' Before going any further, make sure the fields selected are in a bibliographic, rather
' than an authority, record.

TypeOfWindow% = CS.ItemType

Select Case TypeOfWindow%
  Case -1, 3 To 16, 18, 20 To 26
    MsgBox "Sorry, this macro works only in bibliographic records!", CRITICAL_MESSAGE, WaltsMacros$
    Exit Sub

' Proceed by getting the OCLC number of the record, which is the primary piece of data
' used to to identify records. The date in the fixed field element "Replaced" is used to
' distinguish records when both are NEW.

  Case Else
    PosFF% = CS.FixedFieldPosition
    If PosFF% <> DISPLAY_FF_AT_TOP Then CS.FixedFieldPosition = DISPLAY_FF_AT_TOP
    If CS.GetFixedField( "OCLC", FixedFieldData$ ) Then
        SourceOCLCCN$ = FixedFieldData$
    End If
    If CS.GetFixedField( "Replaced", FixedFieldData$ ) Then
        SourceReplaced$ = FixedFieldData$
    End If
    CS.FixedFieldPosition = PosFF%

End Select

If SelectedText$ <> "" And CurrentColumn% > 1 Then

' A CursorColumn position of 1 means the tag has been selected, which happens when
' clicking on any part of it. This is likely to mean an accidental mouse click and is
' ignored, the macro assuming nothing has actually been selected.

' If the selection has been made by dragging upward, the last characters will be the end-
' of-field marker (ASCII characters 013 + 010).

    If Right$( SelectedText$, 2 ) = END_OF_FIELD Then SelectedUp = TRUE

' The number of end-of-field markers within the selection is the count of how many
' fields have been included. The macro will also work with a selection made within a
' field; in that case, it will copy the whole field.

    Start% = 1
    Do
      EndOfFieldFound% = InStr( Start%, SelectedText$, END_OF_FIELD )
      If EndOfFieldFound% > 0 Then
          Start%           = EndOfFieldFound% + 1
          EndOfFieldCount% = EndOfFieldCount% + 1
      End If
    Loop Until EndOfFieldFound% = 0

    If EndOfFieldCount% = 0 Then
        FieldWord$ = "field"
      Else
        FieldWord$ = "fields"
    End If

' In the case of fields selected by dragging up, we must do some calculations to figure
' out in which row the selection was begun. By counting the number of end-of-field
' markers in the selection, we can work backwards--toward the bottom of the record--to
' find the row where the selection was started.

    If SelectedUp = TRUE Then
        CurrentRow% = CurrentRow% + EndOfFieldCount%
    End If
    Difference%   = CurrentRow% - EndOfFieldCount%
    BeginningRow% = Difference%

' Having established the number of fields selected, we can now copy them. Get each field
' within the selection and store it in an array. Although appending each field to a
' string variable and then sending that whole string to the Windows clipboard for pasting
' would be a simpler solution, that method can't handle many special characters.

    ReDim Preserve FieldsSelected( EndOfFieldCount% )
    For i = 0 To ( EndOfFieldCount% )
      If CS.GetFieldUnicode( "...", BeginningRow%, FieldData$) = FALSE Then
          MsgBox "Sorry, the macro failed to get a field.", CRITICAL_MESSAGE, WaltsMacros$
          Exit Sub
        Else
          FieldsSelected( i ) = FieldData$
      End If
      BeginningRow% = BeginningRow% + 1
    Next i

  Else

    ReDim FieldsSelected( 0 )
    ReDim LinesSelected ( 0 )

' Copy each field from the record into two parallel arrays. "FieldsOriginal" holds the
' raw Unicode data of the fields. "FieldsAvailable" holds the same data converted for
' display; the conversion includes changing delimiters to dollar signs and making some
' other character substitutions. A third array, "LinesAvailable", holds the original
' line number of each field to help keep them in order as they are switched back and
' forth between the windows of the dialog box. The reason for using multiple arrays which
' have to be synchronized, rather than a single array of multiple dimensions, is that in
' this version of BASIC the ListBox control in the dialog box can only display an array
' of one dimension.

    i = 0
    Do While CS.GetFieldUnicode( "...", i + 1, FieldData$ )
      ReDim Preserve FieldsOriginal( i )
      FieldsOriginal( i ) = FieldData$

' Add an extra space for each blank indicator (purely for display, to help things line
' up).

      Ind1$ = Mid$( FieldData$, 4, 1 )
      If Ind1$ = " " Then Ind1$ = "  "
      Ind2$ = Mid$( FieldData$, 5, 1 )
      If Ind2$ = " " Then Ind2$ = "  "
      FieldDataConverted$ = Mid$( FieldData$, 1, 3 ) & " " & Ind1$ & Ind2$ & " " & Mid$( FieldData$, 6 )

' Unicode data won't display in the dialog box. Indicate undisplayable characters with a
' pair of brackets to more or less give the appearance of an empty box. However, do
' convert the delimiter to the dollar sign.

      If InStr( FieldDataConverted$, "&#x" ) Then
          Unicode = TRUE
          Do
            p = InStr( FieldDataConverted$, "&#x01C2;" )
            If p <> 0 Then
                FieldDataConverted$ = Left$( FieldDataConverted$, p - 1 ) & "$" & Mid$( FieldDataConverted$, p + 8 )
            End If
          Loop Until p = 0
          Do
            p = InStr( FieldDataConverted$, "&#x" )
            If p <> 0 Then
                FieldDataConverted$ = Left$( FieldDataConverted$, p - 1 ) & "[]" & Mid$( FieldDataConverted$, p + 8 )
            End If
          Loop Until p = 0
        Else

' It is possible, however, to convert or provide substitutions for some MARC21 characters
' for proper display.

          FieldDataConverted$ = ConvertTo8859( FieldDataConverted$ )
      End If

      ReDim Preserve FieldsAvailable( i )
      FieldsAvailable( i ) = FieldDataConverted$
      ReDim Preserve LinesAvailable( i )
      LinesAvailable( i )  = i
      i = i + 1
    Loop

    RemoveInstruction$ = "These fields will be copied to the chosen record." & Chr$( 013 ) & "Click on a field to remove it from this list:"
    UnicodeWarning$    = "UNICODE DATA FOUND. Undisplayable characters are represented here by empty brackets: []"
    UnicodeWarning$    = UnicodeWarning$ & " but data will be copied correctly into the target record."

' The main dialog box where the action of selecting fields to copy takes place.

    Begin Dialog Dialog1Definition 536, 252, WaltsMacros$, .Dialog1ControlFunction
      OkButton      416, 228,  52,  14
      CancelButton  476, 228,  52,  14
      ListBox         8,  26, 256, 208, FieldsAvailable(),       .SourceFields
      ListBox       272,  26, 256, 208, FieldsSelected(),        .SelectedFields
      Text            8,  16,  80,   8, "Select fields to copy:"
      Text          272,   8, 160,  16, RemoveInstruction$,      .RemoveFields
      Text            8, 224, 256,  16, UnicodeWarning$,         .UnicodeSubstitution
      PushButton    215,  12,  48,  12, "Add all",               .CopyAllFields
      PushButton    479,  12,  48,  12, "Remove all",            .RemoveAllFields
    End Dialog

    Dim Dialog1 as Dialog1Definition
    On Error Resume Next
    Dialog Dialog1
    If Err = CANCEL Then Exit Sub

' For pasting into the target record, use the original fields that were duplicated for
' display and were put into the selection array.

    CountOfCopiedFields% = UBound( FieldsSelected )
    For i = 0 To CountOfCopiedFields%
      FieldsSelected( i ) = FieldsOriginal( LinesSelected( i ) )
    Next i
    If CountOfCopiedFields% = 0 Then
        FieldWord$ = "field"
      Else
        FieldWord$ = "fields"
    End If

End If

' With the copied fields in hand, the next step is to find a record to paste the data
' into. Cycle through all the open windows to find bibliographic records. Store their IDs
' in an array so they can be brought to the top, one by one, to find the one into which
' to paste the copied fields. Exclude the source record.

Start% = 0

Recycle:

ReDim WindowIDs( 2, 0 )
CandidateCount% = 0

CountOfWindows% = CS.WindowCount - 1

For i = 0 To CountOfWindows%
  CS.SetTopWindow( i )
  TypeOfWindow% = CS.ItemType
  Select Case TypeOfWindow%
    Case 0 To 2, 17, 19

' For each bibliographic record found, get information from the window title. Remove
' introductory words preceding the title of the work (taken from the 245 field). Shorten
' the title if it's longer than 80 characters.

      If CS.GetWindowTitle( i, WindowTitle$ ) Then
          If WindowTitle$ <> "" Then
              p = InStr( WindowTitle$, ":" )
              If p <> 0 Then
                  WindowTitle$ = Trim$( Mid$( WindowTitle$, p + 1 ) )
              End If
            Else
              MsgBox "Sorry, an inexplicable error occurred.", CRITICAL_MESSAGE, WaltsMacros$
              Exit Sub
          End If
          If Len( WindowTitle$ ) > 80 Then WindowTitle$ = Left$( WindowTitle$, 80 ) & "..."
      End If

' Get the OCLC number and "Replaced" date from the fixed field, two pieces of data to
' help distinguish between records.

      PosFF% = CS.FixedFieldPosition
      If PosFF% <> DISPLAY_FF_AT_TOP Then CS.FixedFieldPosition = DISPLAY_FF_AT_TOP
      If CS.GetFixedField( "OCLC", FixedFieldData$ ) Then
          If FixedFieldData$ = "" Then
              If TypeOfWindow% = 2 Or TypeOfWindow% = 19 Then
                  CandidateOCLCCN$ = "Constant Data"
              End If
            Else
              CandidateOCLCCN$ = FixedFieldData$
          End If
      End If
      If CS.GetFixedField( "Replaced", FixedFieldData$ ) Then
          CandidateReplaced$ = FixedFieldData$
      End If
      CS.FixedFieldPosition = PosFF%

' Put a NEW record in the first element of the array so it's the first one presented as a
' candidate (the assumption being that fields are being copied from an existing record
' into a new one, rather than vice versa). If fields are being copied from one NEW record
' to another, make sure that they are not the same record by comparing the "Replaced"
' date. Upon creation, a NEW record has a "Replaced" date of eight characters. After
' it has been saved, that string is 17 characters in length, the time of saving having
' been added to it.

      If CandidateOCLCCN$ = "NEW" Then
          If CandidateReplaced$ <> SourceReplaced$ Then
              ReDim Preserve WindowIDs( WINDOW_OCLC_NO, CandidateCount% )
              If CandidateCount% > 0 Then
                  For j = CandidateCount% To 1 Step -1
                    WindowIDs( WINDOW_ID, j )      = WindowIDs( WINDOW_ID, j - 1 )
                    WindowIDs( WINDOW_TITLE, j )   = WindowIDs( WINDOW_TITLE, j - 1 )
                    WindowIDs( WINDOW_OCLC_NO, j ) = WindowIDs( WINDOW_OCLC_NO, j - 1 )
                  Next j
              End If
              WindowIDs( WINDOW_ID, 0 )      = Str$( i )
              WindowIDs( WINDOW_TITLE, 0 )   = WindowTitle$
              WindowIDs( WINDOW_OCLC_NO, 0 ) = CandidateOCLCCN$
              CandidateCount%                = CandidateCount% + 1
          End If
        Else

' Do not add the source window to the array, and do not add authority records. Otherwise,
' add all bibliographic records whose OCLC control number does not match that of the
' source record.

          If CandidateOCLCCN$ <> SourceOCLCCN$ Then
              ReDim Preserve WindowIDs( WINDOW_OCLC_NO, CandidateCount% )
              WindowIDs( WINDOW_ID, CandidateCount% )      = Str$( i )
              WindowIDs( WINDOW_TITLE, CandidateCount% )   = WindowTitle$
              WindowIDs( WINDOW_OCLC_NO, CandidateCount% ) = CandidateOCLCCN$
              CandidateCount%                              = CandidateCount% + 1
          End If
      End If
    Case Else
  End Select
Next i

' If no suitable record window is open for pasting into, exit the macro. If only one
' bibliographic record is found, just add the copied fields.

If CandidateCount% = 0 Then
    CS.SetTopWindow( CountOfWindows% )
    MsgBox "No suitable record was found!", CRITICAL_MESSAGE, WaltsMacros$
    Exit Sub
  ElseIf CandidateCount% = 1 Then
    SetWindowID% = Val( WindowIDs( WINDOW_ID, 0 ) )
    CS.SetTopWindow( SetWindowID% )
End If

' Otherwise, display the record(s) for consideration. Include the window title and the
' OCLC control number to help determine which record is the correct one into which to
' paste the fields. This information is especially useful when the windows are tiled, as
' it's hard then to tell which record has the focus, or when working with several records
' that have the same title. If all the data is the same, as when copying fields from one
' NEW record to another one, use the date in "Replaced" in the fixed field to distinguish
' records.

For i = Start% To CandidateCount%
  SetWindowID%  = Val( WindowIDs( WINDOW_ID, i ) )
  CS.SetTopWindow( SetWindowID% )
  TypeOfWindow% = CS.ItemType

  If CandidateCount% = 1 Then
      Dialog2Value% = DIALOG_BUTTON_OK
    Else
' Set the message in the paste dialog box.

      WindowTitle$     = WindowIDs( WINDOW_TITLE, i )
      CandidateOCLCCN$ = Trim$( WindowIDs( WINDOW_OCLC_NO, i ) )
      If Left$( CandidateOCLCCN$, 1 ) Like "[0-9]" Then
            CandidateOCLCCN$ = "#" & CandidateOCLCCN$
      End If
      Query$           = CandidateOCLCCN$ & " : " & WindowTitle$
      RecordCount$     = "Record " & Trim$( Str$( i + 1 ) ) & " of " & Trim$( Str$( CandidateCount% ) )

      Begin Dialog Dialog2Definition  220,  90, WaltsMacros$, .Dialog2ControlFunction
        Text           12,   6, 144,   8, "Paste copied " & FieldWord$ & " into this record?"
        Text           12,  18, 196,  16, Query$
        OkButton       12,  42,  60,  16
        CancelButton  148,  42,  60,  16
        PushButton     80,  42,  60,  16, "&Next record", .Button1
        CheckBox       88,  60,  44,  12, "Also close",   .CheckBox
        Text           99,  70,  44,   8, "this record.", .CheckBoxText
        Text          164,   6,  48,   8, RecordCount$
      End Dialog

      Dim Dialog2 as Dialog2Definition
      Dialog2Value% = Dialog( Dialog2 )

  End If

  Select Case Dialog2Value%

    Case DIALOG_BUTTON_OK

' Add each copied field as the last (or 99th) field in that tag group, unless it
' duplicates a field already in the target record. Keep track of duplicate fields so a
' summary message can be displayed at the end. A successful paste of all copied records
' is not acknowledged.

OneOnly:

      For j = 0 to UBound( FieldsSelected )
        TempString$ = FieldsSelected( j )
        Tag$        = Left$( TempString$, 3 )
        Instance%   = 1
        Duplicate   = FALSE
        Do
          FoundField = CS.GetField( Tag$, Instance%, FieldData$ )
          If FoundField Then
              If FieldData$       = TempString$ Then
                  Duplicate       = TRUE
                  DuplicateCount% = DuplicateCount% + 1
                  Exit Do
              End If
          End If
          Instance% = Instance% + 1
        Loop Until FoundField = FALSE
        If Duplicate = FALSE Then
            If CS.AddField( 99, TempString$ ) = FALSE Then
                MsgBox "Sorry, could not add a field.", CRITICAL_MESSAGE, WaltsMacros$
                Exit Sub
            End If
        End If
      Next j
      If DuplicateCount% > 0 Then
          If DuplicateCount% = 1 Then
              MsgBox "1 copied field was not added because it duplicated a field already in this record.", INFORMATION_MESSAGE, WaltsMacros$
            Else
              MsgBox Str$( DuplicateCount% ) & " copied fields were not added because they duplicated fields already in this record.", INFORMATION_MESSAGE, WaltsMacros$
          End If
      End If
      Exit Sub

    Case DIALOG_BUTTON_1

' If the last of the candidate records has been presented and is not chosen, start going
' through all the candidates again.

      If Dialog2.CheckBox = 1 Then
          CS.CloseRecord( FALSE )
          If i = CandidateCount% - 1 Then
              Start% = 0
            Else
              Start% = i
          End If
          GoTo Recycle:
      End If

    Case DIALOG_BUTTON_CANCEL
      Exit Sub

  End Select

Next i

End Sub

'****************************************************************************************

Sub MoveFields( Selection%, _
                FromFieldsArray() As String, _
                FromLinesArray() As Integer, _
                ToFieldsArray() As String, _
                ToLinesArray() As Integer )

' This procedure does the work of moving fields between the arrays, in either direction.
' The appropriate arrays are passed as parameters. The fields are kept in order by the
' Lines arrays, so moving them usually requires insertion into the existing order by the
' line numbers.

Dim OriginalLineNumber%
Dim UBToFieldsArray%

Dim i As Integer, j As Integer

OriginalLineNumber% = FromLinesArray( Selection% )
If ToFieldsArray( 0 ) = "" Then

' If the target fields array is empty, put the selected field in it without further ado.
' Put the field's original line number into the target lines array at the same time.

    ToFieldsArray( 0 ) = FromFieldsArray( Selection% )
    ToLinesArray( 0 )  = FromLinesArray( Selection% )
  Else

' If the target arrays are not empty, increase each one's upper bound by 1 to add the new
' field and its original line number.

    UBToFieldsArray% = UBound( ToFieldsArray ) + 1
    ReDim Preserve ToFieldsArray( UBToFieldsArray% )
    ReDim Preserve ToLinesArray ( UBToFieldsArray% )

    For i = 0 To UBToFieldsArray%

' Then, starting with the first element, compare the line number of the selected field
' with the line numbers of the target fields already in the array. For each comparison,
' if the line number is lower, add the new number, moving the current element and all
' the other elements above it (that is, with higher numbers) up one slot to make room. Do
' the same with the field data in the parallel array.

      If OriginalLineNumber% < ToLinesArray( i ) Then
          For j = UBToFieldsArray% To i + 1 Step -1
            ToFieldsArray( j ) = ToFieldsArray( j - 1 )
            ToLinesArray ( j ) = ToLinesArray ( j - 1 )
          Next j
          ToFieldsArray( i ) = FromFieldsArray( Selection% )
          ToLinesArray ( i ) = FromLinesArray ( Selection% )
          Exit For
        Else

' If, after comparing the line number of the selected field to all the other line numbers
' already in the array, it still hasn't been fitted in, then it gets added as the last
' element of the array, holding the highest original line number.

          If i = UBToFieldsArray% Then
              ToFieldsArray( i ) = FromFieldsArray( Selection% )
              ToLinesArray ( i ) = FromLinesArray ( Selection% )
              Exit For
          End If
      End If
    Next i

End If

UBToFieldsArray% = UBound( FromFieldsArray )

' Each field added to the list in the "To" arrays must be removed from the list of fields
' in the "From" arrays.

If UBToFieldsArray% = 0 Then
    FromFieldsArray( 0 ) = ""
    FromLinesArray ( 0 ) = 0
  Else
    For i = Selection% To UBToFieldsArray% - 1
      FromFieldsArray( i ) = FromFieldsArray( i + 1 )
      FromLinesArray ( i ) = FromLinesArray ( i + 1 )
    Next i
    ReDim Preserve FromFieldsArray( UBToFieldsArray% - 1 )
    ReDim Preserve FromLinesArray(  UBToFieldsArray% - 1 )
End If

' Highlight the position of the last field selected for removal, helpful in selecting
' several fields near each other.

If Selection% < UBToFieldsArray% Then
    LastRemoved% = Selection%
  Else
    LastRemoved% = UBToFieldsArray% - 1
End If


End Sub

'****************************************************************************************

Function ConvertTo8859( InputString$ ) As String

' This function converts the MARC21 string to ISO/IEC 8859-1 encoding, to make it
' possibly easier to read in the dialog box.

Dim Character$               : Character$ = " "
Dim CharNext%
Dim CharRead%
Dim TempString$

Dim i As Integer

InputString$ = InputString$ & Character$
For i = 1 To Len( InputString$ ) - 1
  CharRead% = Asc( Mid$( InputString$, i, 1 ) )
  CharNext% = Asc( Mid$( InputString$, i + 1, 1 ) )

  Select Case CharRead%

    Case 32 To 64
      Character$ = Chr$( CharRead% )

' OCLC-MARC modified characters are turned into precomposed characters, when possible.

    Case 32 To 64, 66, 68, 70 To 72, 74 To 77, 80 To 82, 84, 86 To 88, 91 To 96
      Character$ = Chr$( CharRead% )

    Case 98, 100, 102 To 104, 106 To 109, 112 To 114, 116, 118 To 120, 123 To 128
      Character$ = Chr$( CharRead% )

    Case 65, 97   'A, a
      Select Case CharNext%
        Case 225  'grave
          Character$ = Chr$( CharRead% + 127 ) : i = i + 1
        Case 226  'acute
          Character$ = Chr$( CharRead% + 128 ) : i = i + 1
        Case 227  'circumflex
          Character$ = Chr$( CharRead% + 129 ) : i = i + 1
        Case 228  'tilde
          Character$ = Chr$( CharRead% + 130 ) : i = i + 1
        Case 232  'diaeresis
          Character$ = Chr$( CharRead% + 131 ) : i = i + 1
        Case 234  'ring
          Character$ = Chr$( CharRead% + 132 ) : i = i + 1
        Case 224, 229 To 231, 233, 235 To 251
          Character$ = Chr$( CharRead% ) : i = i + 1
        Case Else
          Character$ = Chr$( CharRead% )
      End Select

    Case 67, 99   'C, c
      Select Case CharNext%
        Case 240  'cedilla
          Character$ = Chr$( CharRead% + 132 ) : i = i + 1
        Case 224 To 239, 241 To 251
          Character$ = Chr$( CharRead% ) : i = i + 1
        Case Else
          Character$ = Chr$( CharRead% )
      End Select

    Case 69, 101  'E, e
      Select Case CharNext%
        Case 225  'grave
          Character$ = Chr$( CharRead% + 131 ) : i = i + 1
        Case 226  'acute
          Character$ = Chr$( CharRead% + 132 ) : i = i + 1
        Case 227  'circumflex
          Character$ = Chr$( CharRead% + 133 ) : i = i + 1
        Case 232  'diaeresis
          Character$ = Chr$( CharRead% + 134 ) : i = i + 1
        Case 224, 228 To 231, 233 To 251
          Character$ = Chr$( CharRead% ) : i = i + 1
        Case Else
          Character$ = Chr$( CharRead% )
      End Select

    Case 73, 105  'I, i
      Select Case CharNext%
        Case 225  'grave
          Character$ = Chr$( CharRead% + 131 ) : i = i + 1
        Case 226  'acute
          Character$ = Chr$( CharRead% + 132 ) : i = i + 1
        Case 227  'circumflex
          Character$ = Chr$( CharRead% + 133 ) : i = i + 1
        Case 232  'diaeresis
          Character$ = Chr$( CharRead% + 134 ) : i = i + 1
        Case 224, 228 To 231, 233 To 251
          Character$ = Chr$( CharRead% ) : i = i + 1
        Case Else
          Character$ = Chr$( CharRead% )
      End Select

    Case 78, 110  'N, n
      Select Case CharNext%
        Case 228  'tilde
          Character$ = Chr$( CharRead% + 131 ) : i = i + 1
        Case 224 To 227, 229 To 251
          Character$ = Chr$( CharRead% ) : i = i + 1
        Case Else
          Character$ = Chr$( CharRead% )
      End Select

    Case 79, 111  'O, o
      Select Case CharNext%
        Case 225  'grave
          Character$ = Chr$( CharRead% + 131 ) : i = i + 1
        Case 226  'acute
          Character$ = Chr$( CharRead% + 132 ) : i = i + 1
        Case 227  'circumflex
          Character$ = Chr$( CharRead% + 133 ) : i = i + 1
        Case 228  'tilde
          Character$ = Chr$( CharRead% + 134 ) : i = i + 1
        Case 232  'diaeresis
          Character$ = Chr$( CharRead% + 135 ) : i = i + 1
        Case 224, 229 To 231, 233 To 251
          Character$ = Chr$( CharRead% ) : i = i + 1
        Case Else
          Character$ = Chr$( CharRead% )
      End Select

    Case 83, 115  'S, s
      Select Case CharNext%
        Case 224 To 251
          Character$ = Chr$( CharRead% ) : i = i + 1
        Case Else
          Character$ = Chr$( CharRead% )
      End Select

    Case 85, 117  'U, u
      Select Case CharNext%
        Case 225  'grave
          Character$ = Chr$( CharRead% + 132 ) : i = i + 1
        Case 226  'acute
          Character$ = Chr$( CharRead% + 133 ) : i = i + 1
        Case 227  'circumflex
          Character$ = Chr$( CharRead% + 134 ) : i = i + 1
        Case 232  'diaeresis
          Character$ = Chr$( CharRead% + 135 ) : i = i + 1
        Case 224, 228 To 231, 233 To 251
          Character$ = Chr$( CharRead% ) : i = i + 1
        Case Else
          Character$ = Chr$( CharRead% )
      End Select

    Case 89, 121  'Y, y
      Select Case CharNext%
        Case 226  'acute
          Character$ = Chr$( CharRead% + 132 ) : i = i + 1
        Case 232  'diaeresis
          If CharRead% = 121 Then
              Character$ = Chr$( 255 )
            Else
              Character$ = Chr$( CharRead% )
          End If
          i = i + 1
        Case 224 To 225, 227 To 231, 233 To 251
          Character$ = Chr$( CharRead% ) : i = i + 1
        Case Else
          Character$ = Chr$( CharRead% )
      End Select

    Case 90, 122  'Z, z
      Select Case CharNext%
        Case 224 To 251
          Character$ = Chr$( CharRead% ) : i = i + 1
        Case Else
          Character$ = Chr$( CharRead% )
      End Select

    Case 158   'Degree sign
      Character$ = Chr$( 176 )
    Case 160   'Euro
      Character$ = Chr$( 128 )
    Case 162   'Crossed O
      Character$ = Chr$( 216 )
    Case 163   'Eth
      Character$ = Chr$( 208 )
    Case 164   'Thorn
      Character$ = Chr$( 222 )
    Case 165   'AE Ligature
      Character$ = Chr$( 198 )
    Case 166   'OE Ligature
      Character$ = "Oe"
    Case 169   'Musical flat: does not copy
      Character$ = Chr$( 129 )
    Case 170   'registered
      Character$ = Chr$( 174 )
    Case 171   'Plus-minus
      Character$ = Chr$( 177 )
    Case 178   'crossed o
      Character$ = Chr$( 248 )
    Case 179   'eth
      Character$ = Chr$( 240 )
    Case 180   'thorn
      Character$ = Chr$( 254 )
    Case 181   'ae ligature
      Character$ = Chr$( 230 )
    Case 182   'oe ligature
      Character$ = "oe"
    Case 185   'Pound
      Character$ = Chr$( 163 )
    Case 202   'Copyright
      Character$ = Chr$( 169 )
    Case 203   'Sound recording copyright: does not copy
      Character$ = "p"
    Case 204   'Musical sharp: does not copy
      Character$ = "#"
    Case 223   'Delimiter
      If Character$ = " " And Mid$( InputString$, i + 1, 2 ) Like "[a-z0-9] " Then
          Character$ = "$"
        Else
          Character$ = Chr$( 223 )
      End If
    Case Else
      Character$ = Chr$( CharRead% )

  End Select

  TempString$ = TempString$ & Character$

Next i

ConvertTo8859 = TempString$

End Function

'****************************************************************************************

Function Dialog1ControlFunction( Id$, Action%, SVal& )

' This function controls the dialog box which displays the record's fields.

Const CONTROL_CHANGE  As Integer = 2
Const DISABLED        As Integer = 0
Const ENABLED         As Integer = 1
Const INITIALIZE      As Integer = 1
Const KEEP_DLG_OPEN   As Integer = -1
Const VISIBLE         As Integer = 1
Const WARNING_MESSAGE As Integer = 48

Dim Selection%
Dim UBSourceArray%

Dim i As Integer, j As Integer, k As Integer

Select Case Action%

  Case INITIALIZE

    DlgVisible      "RemoveFields",        INVISIBLE
    If Unicode Then
        DlgVisible      "UnicodeSubstitution", VISIBLE
      Else
        DlgVisible      "UnicodeSubstitution", INVISIBLE
    End If
    DlgEnable       "RemoveAllFields",     DISABLED

  Case CONTROL_CHANGE

    Select Case Id$

' If no fields were selected when the "OK" button is clicked, display a warning message
' and keep the dialog box open.

      Case "OK"

        If FieldsSelected( 0 ) = "" Then
            MsgBox "Please select some fields to copy!", WARNING_MESSAGE, WaltsMacros$
            DlgFocus        "SourceFields"
            Dialog1ControlFunction = KEEP_DLG_OPEN
        End If

      Case "SourceFields", "SelectedFields", "CopyAllFields", "RemoveAllFields"

        Select Case Id$

' For every click on a field, move that field to the other window. Keep all fields in
' their original order.

          Case "SourceFields", "SelectedFields"

            If Id$ = "SourceFields" Then
                Selection% = DlgValue( "SourceFields" )
                Call MoveFields( Selection%, _
                                 FieldsAvailable(), _
                                 LinesAvailable(), _
                                 FieldsSelected(), _
                                 LinesSelected() )
              Else
                Selection% = DlgValue( "SelectedFields" )
                Call MoveFields( Selection%, _
                                 FieldsSelected(), _
                                 LinesSelected(), _
                                 FieldsAvailable(), _
                                 LinesAvailable() )
            End If

' When the "all" buttons are clicked, the MoveFields procedure is called repeatedly until
' the source array is emptied.

          Case "CopyAllFields", "RemoveAllFields"

            If Id$ = "CopyAllFields" Then
                UBSourceArray% = UBound( FieldsAvailable )
                For i = 0 To UBSourceArray%
                  Call MoveFields( 0, _
                                   FieldsAvailable(), _
                                   LinesAvailable(), _
                                   FieldsSelected(), _
                                   LinesSelected() )
                Next i
              Else
                UBSourceArray% = UBound( FieldsSelected )
                For i = 0 To UBSourceArray%
                  Call MoveFields( 0, _
                                   FieldsSelected(), _
                                   LinesSelected(), _
                                   FieldsAvailable(), _
                                   LinesAvailable() )
                Next i
            End If

        End Select

        DlgListBoxArray "SelectedFields",      FieldsSelected
        DlgListBoxArray "SourceFields",        FieldsAvailable

        If FieldsAvailable( 0 ) = "" Then
            DlgEnable       "CopyAllFields",       DISABLED
          Else
            DlgEnable       "CopyAllFields",       ENABLED
        End If
        If FieldsSelected( 0 ) = "" Then
            DlgEnable       "RemoveAllFields",     DISABLED
            DlgVisible      "RemoveFields",        INVISIBLE
          Else
            DlgEnable       "RemoveAllFields",     ENABLED
            DlgVisible      "RemoveFields",        VISIBLE
        End If

' Finish up by highlighting (indicating the default selection) the same row in the dialog
' box windows as had just been clicked on by the mouse. This makes selection of a nearby
' field a little easier.

        If Id$ = "SourceFields" Or Id$ = "SelectedFields" Then
            DlgValue        Id$,                   LastRemoved%
        End If

        Dialog1ControlFunction = KEEP_DLG_OPEN

    End Select

End Select

End Function

'****************************************************************************************

Function Dialog2ControlFunction( Id$, Action%, SVal& )

' This function controls the dialog box about which record into which to paste the copied
' fields.

Const INITIALIZE As Integer = 1
Const INVISIBLE  As Integer = 0
Const UNCHECKED  As Integer = 0

If Action% = INITIALIZE Then
    If CandidateCount% = 1 Then
        DlgVisible      "Button1",             INVISIBLE
        DlgVisible      "CheckBox",            INVISIBLE
        DlgVisible      "CheckBoxText",        INVISIBLE
    End If
    DlgValue        "CheckBox",            UNCHECKED
End If

End Function
'106040123
