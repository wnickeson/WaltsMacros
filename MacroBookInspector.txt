' MacroName:MacroBookInspector.2025.01
' MacroDescription:Lists the macros in a macro book, along with their descriptions and
' other information, and allows saving the list, or the text of an individual macro, to a
' text file.
'
' This macro was written by Walter F. Nickeson and last updated 4 May 2025.
' It was developed in Connexion client 3.1 running in Windows 11 Enterprise and 64-bit
' Windows 10 Pro.
' Walt's macros for the Connexion client: https://github.com/wnickeson/WaltsMacros
' wfnickeson@zohomail.com
'
' Thanks to Joel Hahn for pointing out the file structure of macro books, and for
' instruction afforded by the macros he's shared, and to Harvey Hahn for some inspiration
' in the functionality of this macro with his earlier "MbkTool" macro, although all
' responsibility for this macro is mine alone. Thanks also to Bryan Baldus for feedback
' which helped uncover and overcome a limitation of this macro on the size of macros it
' can deal with.
'
' Copyright 2025 Walter F. Nickeson.
'
' Permission is hereby granted, free of charge, to any person obtaining a copy of this
' software and associated documentation files (the "Software"), to deal in the Software
' without restriction, including without limitation the rights to use, copy, modify,
' merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
' permit persons to whom the Software is furnished to do so, subject to the following
' conditions:
'
' The above copyright notice and this permission notice shall be included in all copies
' or substantial portions of the Software.
'
' THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
' INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
' PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
' HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
' CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
' THE USE OR OTHER DEALINGS IN THE SOFTWARE.
'
'***************************************************************************************#
' How it works: Run the macro to view the macro books in the Connexion "Macros"
' directory. Select a macro book to see a list of the macros in it, its size (in bytes),
' and, for my macros, date of last revision. Select a macro to see some information about
' it: its size in terms of lines (source code) and bytes (for both source and object
' code), and if available, its description, a possible date of revision, and the
' keystroke shortcut or user tool number assigned to it. Its first 25 lines or 1K of
' source code can be displayed separately. The list of macro books and the list of macros
' in the selected macro book can be saved as tab-delimited text files. The text of the
' selected macro may also be saved as a text file. The default save location can be set
' below on line 320. The simple list of macros is placed on the Windows clipboard.
'
' Some simple error checking is done as this macro gathers information: If the length of
' a macro book file is not a multiple of 512, a warning pops up; if the selected macro is
' damaged or corrupt, this program may be able to detect and warn about it; and if the
' name or description of the selected macro differs from what displays in the Connexion
' macro manager, that is noted.
'
' This macro can't analyze macro books larger than 7,143,424 bytes, although that
' capability is possible.
'
' The ability to save the text of a macro directly is useful because the maximum number
' of bytes the Windows clipboard can copy from the macro editor is 65,498. Using this
' macro bypasses that limitation. The reason to save macros as separate text files is, of
' course, as backup, because of the susceptibility of macro books to corruption. The most
' common sign of corruption seems to be in which parts of macros--usually at the end--
' seem to disappear, but macros can also somehow acquire extra text at the end, usually
' of garbled lines of code. The best way to backup a macro is by using a text file,
' because restoring a corrupt macro is then a simple matter of pasting the text into the
' macro editor. (The corruption seems to occur at the moment a macro is closed in the
' macro editor, so it is possible that the macro may actually be corrupt when
' "MacroBookInspector" saves it as a text file.) And the simple need to be able to
' produce a list of macros is what drove the development of this macro in the first
' place.
'
' When a macro book is selected, the program scans the file's internal directory for
' names of macros. In that same initial scan it also retrieves the macro descriptions,
' the size in bytes of each macro's source and compiled code, and the information
' required to assemble the macro from all the pieces in which it is stored within the
' file. It then sorts the macros to display them in alphabetical order. Depending on the
' number and size of the macros in that macro book, it may take several (or many) seconds
' to finish; the macro keeps track of this time. Only when a macro is selected are its
' pieces actually assembled to produce the rest of the information to display: the number
' of lines in the original source code, a possible date of last modification, and the
' first 1K bytes of the source text. This macro attempts to find a revision date by
' searching within the first 25 lines of the selected macro for a word like "revised" or
' "updated" and a string of digits that might represent a date from 1998 on. This is not
' a very precise method, but it works for my macros, in which I put revision dates in a
' standard form. (OCLC has unfortunately chosen not to implement the provision in the
' file format for a time stamp for date of creation or modification, an enhancement I
' believe would be extremely useful.) During this pass through the macro text, this
' program matches "Sub" and "End Sub" and "Function" and "End Function" statements.
' Unmatched statements may indicate corruption, or loss of text, and a message box pops
' up carrying a warning when such a problem is found. Unfortunately, the macro produces
' false positives, so the warning shouldn't cause immediate alarm. Because this part of
' the program can take several seconds for a large macro, it is done only when a macro is
' actually selected, or when a macro book contains only a single macro. The display of
' the description allows for six lines, at approximately 60 characters per line. The
' first 25 lines or so of the selected macro's source code can be displayed. (The limit
' is actually 1024 characters, the limit of the contents of a text area in the dialog
' box, but this macro cuts off the display with a complete line, so fewer than 25 lines
' may actually be given.) To get the keystroke shortcut, the macro attempts to find the
' file "Custom.Keymap.xml" and the macro name in that file. If both attempts are
' successful it extracts the keystrokes for display. Otherwise, it attempts the same
' thing with the "Options.xml" file to get the user tool assignment.
'
' Connexion macro books are instances of the Windows Compound File Binary File Format,
' documentation for which is at <https://learn.microsoft.com/en-us/openspecs/windows_protocols/
' ms-cfb/53989ce4-7b05-4f8d-829b-d08d6148375b>. The "Protocol Revision" is 12.0, dated
' 4/23/2024. Files in this format contain data in a number of virtual streams. In the
' case of macro book files, each macro appears to be stored in three streams (with the
' actual data being dispersed throughout the file): the source, which is the text entered
' in the editor; the macro description, as entered in the macro manager (but which is
' taken from the editor if first created there); and binary data, which is (I think) the
' compiled code.
'
' The file allocates storage space for all its contents in sectors of 512 bytes, with the
' first sector, the Header, containing data about locations within the file and other
' parameters. After opening the selected file, this macro analyzes the Header to extract
' relevant information with which to build the different streams. The first stream that
' must be built is the FAT, the File Allocation Table, which is an array that represents
' the sectors, or units of 512 bytes, that comprise the file. The FAT is the basis for
' constructing all the other streams, a stream being a chain of sectors. The MiniFAT is
' another stream that, as an array, represents the minisectors in the file. Minisectors
' are units of 64 bytes contained within the larger sectors; the complete chain of
' minisectors forms the Ministream. Similarly, the directory is also a stream, and
' contains other crucial location information. To extract macro names and descriptions,
' the macro begins by building the FAT, which is then used to construct the MiniFAT, the
' directory stream, and the Ministream. When these pieces are in place the macro finds
' the names in the directory stream, which is also where the locations of the macro
' descriptions within the Ministream are stored. (It is also where date information may
' be stored, but which OCLC has chosen not to do.) This macro sorts the unique macro
' names and attaches to each the appropriate description. When a macro is selected, its
' source code is reconstructed by starting at the location where it begins (identified in
' the directory) and following the chain of sectors specified in the FAT (or MiniFAT),
' assembling the contents of those sectors until it is complete. In the construction of
' the macro some kinds of corruption may be detected. This step is done only once for
' each macro; the results are stored in an array for recall if the macro is selected
' again.
'****************************************************************************************

Option Compare Text  'Forces case-insensitive string comparison in "InStr" and "StrComp".
Option Explicit

Type MacroRecord
 tDescription              As String  'Macro description
 tDescriptionInSource      As Variant 'Macro description as given in source
 tDisplayName              As String  'Name modified to solve ampersand problem
 tElapsedTime              As Double  'Elapsed time the macro took to perform its calculations
 tLengthOfBinaryStream     As Long    'Length in bytes of the compiled macro
 tLengthOfSourceStream     As Long    'Length in bytes of source data
 tLineCountOfSourceCode    As Long    'Total line count
 tMatchWarning             As String  'Warning about possible macro corruption or other problem
 tName                     As String  'Macro name
 tNameInSource             As String  'Macro name given in source
 tPreview                  As String  'Preview of beginning of macro
 tPreviewLineCount         As Integer 'Number of lines of preview shown
 tRevisionDate             As String  'Date of revision as given in macro
 tSector1BinaryStream      As Long    'First sector of compiled (file) stream
 tSector1DescriptionStream As Long    'First sector of description stream
 tSector1SourceStream      As Long    'First sector of source (data) stream
 tShortcutKey              As String  'Shortcut key assignment
 tFileInfoDate             As String  'Datestamp of file revision
 tMacbkName                As String  'Macro book name
 tStreamTypes              As String
End Type

Declare Sub AssembleMacroInfo    ( Selection% )
Declare Sub BuildDataStream      ( FirstSector&, WhichFAT%, StreamSize& )
Declare Sub BuildFAT             ( TotalSectorsInFAT% )
Declare Sub BuildMiniFAT         ( TotalSectorsInMiniFAT%, FirstSectorOfMiniFAT% )
Declare Sub BuildMinistream      ( MinistreamStart& )
Declare Sub GetDirectoryEntries  ( FirstSectorOfDirectory& )
Declare Sub GetFileInfo          ( SelectedMbkFile$ )
Declare Sub GetMacroBookFiles
Declare Sub GetMacroInfo         ( ThisMacroRecord As MacroRecord )
Declare Sub GetMacroNames
Declare Sub MakeMacroList        ( SelectedMbkFile$ )
Declare Sub ReadFile             ( FileName$ )
Declare Sub SetDialogBox         ( ThisMacroRecord As MacroRecord )
Declare Sub ShowTimes
Declare Sub SortMacroNames       ( NewName As MacroRecord, StreamType$ )
Declare Sub StoreWithTerminator  ( WhichArray% )
Declare Sub WriteFile            ( SaveType% )

Declare Function FindRevisionDate( MacroLine$ )                 As String
Declare Function FormatDuration  ( BeginTime#, EndTime# )       As String
Declare Function FormatTimeButton( TimeString$ )                As String
Declare Function GetKeyAssignment( FullMacroName$ )             As String
Declare Function GetSectorData   ( SectorID&, WhichDataArray% ) As String
Declare Function HexVal          ( InBytes$ )                   As Long
Declare Function MatchCalls      ( MacroLine$, LineCount& )     As String

Declare Function Dialog1ControlFunction( Id$, Action%, SuppVal& )
Declare Function Dialog3ControlFunction( Id$, Action%, SuppVal& )

Global Const DATA_SUBSTRING_64    As Integer = 64     'The number of characters in some of the substrings of the main macro
Global Const DATA_SUBSTRING_8     As Integer = 8      ' information string.
Global Const DIR_ENTRY_LENGTH     As Integer = 128    'The length in bytes of a directory entry.
Global Const DWORD                As Integer = 4      'The length in bytes of sector numbers and some other values.
Global Const END_OF_CHAIN         As Integer = -2     'Hex FFFFFFFE, marks the end of a chain of sectors in the FAT.
Global Const FILE_DATA            As Integer = 1      'The switch to control processing of array to end elements with LF
                                                      'character.
Global Const FILE_EXTENSION       As Integer = 4      'The length of string "dot + filename extension," e.g. ".mbk" = 4
                                                      ' characters.
Global Const MAIN_C               As Integer = 0      'The switch to access main data array or main FAT array.
Global Const MAX_SIZE_MINISTREAM  As Integer = 4096   'The maximum size in bytes of object stored in Ministream.
Global Const MAX_STRING_LENGTH    As Integer = 31744  'The largest even multiple of 512 below 32767, OML's limit on string
                                                      ' length.
Global Const MINI_C               As Integer = 1      'The switch to access Ministream or miniFAT array.
Global Const MINI_SECTOR_SIZE     As Integer = 64     'The size in bytes of minisectors.
Global Const REV_WORDS            As Integer = 7      'The number of words indicating revision.
Global Const SAVE_LIST            As Integer = 0      'The switch to save the list of macros to a file.
Global Const SAVE_MACRO           As Integer = 1      'The switch to save the text of a macro to a file.
Global Const SECTOR_SIZE          As Integer = 512    'The size in bytes of normal or regular sectors.
Global Const STREAM_DATA          As Integer = 0      'The switch to control processing of array to end elements with LF
                                                      ' character.
Global Const STREAM_START         As Integer = 117    'The first sector location for a stream object. This offset is from the
                                                      ' beginning of the directory sector.
Global Const STRING1_EQUAL_TO     As Integer = 0      'The value of the "StrComp" function when strings 1 and 2 are the same.
Global Const STRING1_GREATER_THAN As Integer = 1      'The value of the "StrComp" function when string 1 is greater than string
                                                      ' 2.
Global Const STRING1_LESS_THAN    As Integer = -1     'The value of the "StrComp" function when string 1 is less than string 2.
Global Const STRING_OFFSET        As Integer = 1      'A number to make up the difference between 0-based (file offset) and 1-
                                                      'based (character positions in strings) counting.

Global Const CONTROL_CHANGE       As Integer = 2

Global Const DISABLED             As Integer = 0
Global Const ENABLED              As Integer = 1
Global Const INITIALIZE           As Integer = 1
Global Const INVISIBLE            As Integer = 0
Global Const KEEP_DLG_OPEN        As Integer = -1
Global Const VISIBLE              As Integer = 1
Global Const WARNING_MESSAGE      As Integer = 48

Global CRLF         As String*2
Global DOUBLE_QUOTE As String*1
Global SINGLE_QUOTE As String*1
Global TAB_CHAR     As String*1

Global AppDataPath$
Global DefaultSavePath$
Global FATSectorListInHeader$
Global FileInfo$
Global FileSize&
Global FileSizeKBStr$
Global FullMacroName$
Global MacroBookFile$
Global MacroBookList$
Global MacroBookName$
Global MacroCount%
Global MacroDirectoryPath$
Global MacroRevisionDate$
Global MatchCache$
Global MatchWarning$
Global PreviewLines$
Global PreviousEntry%
Global ProgramFilesPath$
Global SaveCount%
Global SaveFileName$
Global SelectedMacroIndex%
Global SelectedMacroName$
Global SourceName$
Global SummaryMacroCount$
Global TestString$
Global TotalMacroCount%
Global WaltsMacros$
Global WhichFAT%

Global DataStream()             As String
Global DirectoryEntries()       As String
Global EndWithLF()              As String
Global FAT()                    As Long
Global FileSections()           As String
Global FileSectors()            As String
Global MacroBooks()             As String
Global MacroListB()             As MacroRecord
Global MacroListNames()         As String
Global MainMacroArray()         As String
Global MiniFAT()                As Long
Global MinistreamSectors()      As String
Global PreviousSaves()          As String
Global UpdateClues( REV_WORDS ) As String
Global UpdateDate()             As String

Global DifferentDesc
Global InvalidFileLength

' Timing variables to calculate speed of macro TimeButton.

Global BeginBF#   'Elapsed time to build the FAT
Global FinishBF#  ' (Build FAT)
Global TimeBF$
Global BeginBMF#  'Elapsed time to build the MiniFAT
Global FinishBMF# ' (Build Mini FAT)
Global TimeBMF$
Global BeginBMS#  'Elapsed time to build the Ministream
Global FinishBMS# ' (Build Mini Stream)
Global TimeBMS$
Global BeginDS#   'Elapsed time to extract and sort the list of names
Global FinishDS#  ' (Directory Sort)
Global TimeDS$
Global BeginGMI#  'Elapsed time to get information about a single macro
Global FinishGMI# ' (Get Macro Information)
Global TimeGMI$
Global BeginMML#  'Total elapsed time to build the macro list
Global FinishMML# ' (Make Macro List)
Global TimeMML$

'****************************************************************************************

Sub Main

'====  CHANGE THIS FILE PATH IF DESIRED  ================================================
' The file name will be appended to this path as the default option when saving. OML does
' not have the resources to present a proper Save dialog, with the ability to easily
' navigate through directories, so this macro simply offers a text box to enter a
' complete file name. Edit this line to identify the place where macros are most likely
' to be saved, and the Save dialog will use it (but the path can be edited to save files
' anywhere).

DefaultSavePath$ = "C:\Users\[user name]\Documents\"
'========================================================================================

Const CRITICAL_MESSAGE As Integer = 16

Dim MacroYears%

Dim i As Integer

' Initialize some global variables.

CRLF                = Chr$( 013 ) & Chr$( 010 )
DOUBLE_QUOTE        = Chr$( 034 )
MacroCount%         = 0
MacroDirectoryPath$ = "\OCLC\Connex\Macros\"
SINGLE_QUOTE        = Chr$( 039 )
TAB_CHAR            = Chr$( 009 )
WaltsMacros$        = "[Walt's macros] MacroTools:MacroBookInspector"

ReDim PreviousSaves( 0 )

' The catalog of words indicating revision; "updated" is first because that's the term I
' use in my macros.

UpdateClues( 0 ) = "updated"
UpdateClues( 1 ) = "revised"
UpdateClues( 2 ) = "modified"
UpdateClues( 3 ) = "revision"
UpdateClues( 4 ) = "edited"
UpdateClues( 5 ) = "altered"
UpdateClues( 6 ) = "created"
UpdateClues( 7 ) = "adapted"

' The catalog of possible dates of revision of macros--1998 to the present (although what
' macro has survived from 1998????).

MacroYears% = Year( Now() ) - 1998
ReDim UpdateDate( MacroYears% )
For i = 0 To MacroYears%
  UpdateDate( i ) = Trim$( Str$( 1998 + MacroYears% - i ) )
Next i

Call GetMacroBookFiles
If AppDataPath$ = "" Then
    MsgBox "Sorry, this macro could not find the macro files.", CRITICAL_MESSAGE, WaltsMacros$
    Exit Sub
End If

' Variables in Sub Main.

Dim Clipbord$
Dim PreviewMessage$          : PreviewMessage$ = "View first 25 lines or 1K of selected macro."
Dim SelectingBooks$
Dim SelectingMacros$

Clipbord$ = "This list of macros (names only) has been placed on the Windows clipboard. Save the list to a file to include the"
Clipbord$ = Clipbord$ & " descriptions."

' Prepare the legends for the dialog box.

SelectingBooks$  = "<== Select a macro book from the drop-down list to view its macros. Please be patient after making the"
SelectingBooks$  = SelectingBooks$ & " selection. Depending on the size of the macro book file and the number of macros in the"
SelectingBooks$  = SelectingBooks$ & " macro book (among other things), the macro list may take several seconds to load."

SelectingMacros$ = "Select a macro to display information about it. Please be patient with this part of the macro too. It may"
SelectingMacros$ = SelectingMacros$ & " take several seconds to gather information about large macros (those with over about"
SelectingMacros$ = SelectingMacros$ & " 600 lines)."

Begin Dialog Dialog1Definition  342, 226, WaltsMacros$, .Dialog1ControlFunction
  PushButton    268, 200,  64,  16, "Close",            .CloseButton
  PushButton     10, 174,  56,  14, "Save &list...",    .SaveList
  PushButton     82, 174,  56,  14, "Save &macro...",   .SaveMacro
  PushButton    168, 174,  56,  14, "&Preview",         .PreviewButton
  PushButton     10, 206,  24,  10, "",                 .TimeButton
  CancelButton    1,   1,   1,   1
  DropListBox    10,  10, 128, 112, MacroBooks(),       .ListOfMacroBooks
  Text          148,  38, 184,  32, SelectingMacros$,   .SelectMacro
  Text          148,  78, 184,  24, Clipbord$,          .Clipboard
  ListBox        10,  38, 128, 138, MacroListNames(),   .ListOfMacros
  GroupBox      148,  34, 184,  58, "",                 .OutlineInfo
  GroupBox      148, 100, 184,  68, "",                 .OutlineDesc
  Text          148,  10, 176,  52, SelectingBooks$,    .SelectBooks
  Text          148,  12, 136,   8, FileInfo$,          .FileInfo
  Text          286,  12,  48,   8, "",                 .FileKBs
  Text           10,  28,  48,   8, SummaryMacroCount$, .MacroCount
  Text          156,  46, 166,   8, "",                 .RevDate
  Text          156,  56, 166,   8, "",                 .MacroLines
  Text          156,  66, 166,   8, "",                 .MacroSize
  Text          156,  76, 166,   8, "",                 .Shortcut
  Text          156, 112, 166,  48, "",                 .Description
  Text          155,  86, 171,   8, "",                 .NameDiffers
  Text          232, 174, 100,  16, PreviewMessage$,    .PreviewText
  GroupBox      154,  82, 172,  15, "",                 .NameDiffersBox
End Dialog

Dim Dialog1 as Dialog1Definition
On Error Resume Next
Dialog Dialog1

End Sub

'****************************************************************************************

Sub AssembleMacroInfo( Selection% )

' This sub assembles all the bits of macro information into one string for ease of
' insertion into the dialog box display.

Dim DisplayMacroName$
Dim MacroListSelection$

Dim i As Integer, p As Integer, z As Integer

Dim ThisMacroRecord As MacroRecord

ThisMacroRecord = MacroListB( Selection% )

' Because the ampersand tends to disappear in dialog boxes, this loop adds a second
' ampersand to make sure it displays properly.

DisplayMacroName$ = ThisMacroRecord.tName
i = 1
Do
  p = InStr( i, DisplayMacroName$, "&" )
  If p <> 0 Then
      DisplayMacroName$ = Left$( DisplayMacroName$, p ) & "&" & Mid$( DisplayMacroName$, p + 1 )
      i = p + 2
  End If
Loop Until p = 0
ThisMacroRecord.tDisplayName = DisplayMacroName$

' Run the timer to see how long the busy part of the macro takes--the sub that
' reconstructs the text of the macro and checks for some kinds of errors. That sub also
' gets some of the information that is assembled into the main string that contains
' everything necessary to display.

BeginGMI#      = Timer
Call GetMacroInfo( ThisMacroRecord )
FinishGMI#     = Timer
TimeGMI$       = FormatDuration( BeginGMI#, FinishGMI# )
ThisMacroRecord.tElapsedTime = Format( FinishGMI# - BeginGMI#, "#.###" )

FullMacroName$ = MacroBookName$ & "!" & ThisMacroRecord.tName
ThisMacroRecord.tShortcutKey = GetKeyAssignment( FullMacroName$ )

' The first dimension of the main array is the index number of the macro list. The
' second dimension holds the string containing macro information in the first element,
' and the macro text in subsequent elements. The array can expand as much as necessary to
' accommodate large macros.

MacroListB( Selection% ) = ThisMacroRecord
MainMacroArray( SelectedMacroIndex%, 0 ) = ThisMacroRecord.tName
z = UBound( DataStream )
If z >= UBound( MainMacroArray, 2 ) Then
    ReDim Preserve MainMacroArray( TotalMacroCount%, z + 1 )
End If
For i = 0 To z
  MainMacroArray( SelectedMacroIndex%, i + 1 ) = DataStream( i )
Next i

End Sub

'****************************************************************************************

Sub BuildDataStream( FirstSector&, WhichFAT%, StreamSize& )

' Given the first sector of a data stream, whether the stream is in the Ministream or
' not, and how long the stream is, this subprogram builds the data stream from the chain
' of sectors in either the FAT or the MiniFAT.

Dim DataStreamIndex%
Dim DataStreamRemainder%
Dim ExpectedDataStreamRows%  'Zero-based row count
Dim ExpectedSectorCount%
Dim LenthStreamSegment&
Dim NextSector&
Dim PrevSector&
Dim SectorsRead%
Dim StreamSegment$

' Calculate some parameters. Given the length of the data stream, determine how many
' elements in the storage array to allocate, and how many sectors comprise the stream.

ExpectedDataStreamRows% = StreamSize& \ MAX_STRING_LENGTH
DataStreamRemainder%    = StreamSize& Mod MAX_STRING_LENGTH
If DataStreamRemainder% = 0 Then
    ExpectedDataStreamRows% = ExpectedDataStreamRows% - 1
End If

If StreamSize& < MAX_SIZE_MINISTREAM Then
    ExpectedSectorCount% = StreamSize& \ MINI_SECTOR_SIZE
    If StreamSize& Mod MINI_SECTOR_SIZE > 0 Then
        ExpectedSectorCount% = ExpectedSectorCount% + 1
    End If
  Else
    ExpectedSectorCount% = StreamSize& \ SECTOR_SIZE
        If StreamSize& Mod SECTOR_SIZE > 0 Then
        ExpectedSectorCount% = ExpectedSectorCount% + 1
    End If
End If

' ReDim the array according to how many strings of 31744 or fewer bytes are going to be
' stored, and then start reading the stream from the sector given in either the FAT or
' the miniFAT.

ReDim DataStream( ExpectedDataStreamRows% )
PrevSector&    = FirstSector&
StreamSegment$ = GetSectorData( FirstSector&, WhichFAT% )
SectorsRead%   = SectorsRead% + 1

' Keep reading the sectors in the chain from whichever FAT has been declared. When the
' end-of-chain marker has been reached, put the string into the array.

Do
  If WhichFAT% = MAIN_C Then
      NextSector& = FAT( PrevSector& )
    Else
      NextSector& = MiniFAT( PrevSector& )
  End If
  If NextSector& = END_OF_CHAIN Then
      If ExpectedDataStreamRows% = 0 Or LenthStreamSegment& < MAX_STRING_LENGTH Then
          DataStream( DataStreamIndex% ) = Left$( StreamSegment$, DataStreamRemainder% )
        Else
          If DataStreamIndex% <= ExpectedDataStreamRows% Then
              DataStream( DataStreamIndex% ) = Left$( DataStream( DataStreamIndex% ), DataStreamRemainder% )
            Else
              Exit Do
          End If
      End If
      Exit Do
    Else
      StreamSegment$      = StreamSegment$ & GetSectorData( NextSector&, WhichFAT% )
      SectorsRead%        = SectorsRead% + 1
      PrevSector&         = NextSector&
      LenthStreamSegment& = Len( StreamSegment$ )
      If LenthStreamSegment& = MAX_STRING_LENGTH Then
          If LenthStreamSegment& < StreamSize& Then
              DataStream( DataStreamIndex% ) = StreamSegment$
              DataStreamIndex%               = DataStreamIndex% + 1
              StreamSegment$                 = ""
          End If
      End If
  End If
Loop Until NextSector& = END_OF_CHAIN Or SectorsRead% > ExpectedSectorCount%

' This little piece detects some FAT errors but gives only a general warning that the
' expected size of the data does not match the actual size read.

If SectorsRead% <> ExpectedSectorCount% Or ( DataStreamIndex% > ExpectedDataStreamRows% ) Then
    MsgBox "The macro is corrupt!" & CRLF & _
           "StreamSize& = " & Str$(StreamSize&) & CRLF & _
           "ExpectedSectorCount% = " & Str$( ExpectedSectorCount% ) & ", SectorsRead% = " & _
           Str$( SectorsRead% ) & CRLF & Left( DataStream(0), 256 ), WARNING_MESSAGE, WaltsMacros$
End If

End Sub

'****************************************************************************************

Sub BuildFAT( TotalSectorsInFAT% )

' This subprogram builds the FAT, an array that maps the contents of the file. The index
' of the array corresponds to the complete list of 512-byte sectors in the file (starting
' with the sector that follows the Header, sector 0), and each element in the array is
' the ID of the next sector in that particular stream:
'
'           sector ID:    0    1    2    3    4    5    6    7    8    9
'   ID of next sector:   -3    4   63    5    7    6    8   13    9   10
'
' In this file, element 0 of the array, corresponding to sector 0 of the file, or bytes
' 512 to 1023 (character positions 513-1024) of the file, contains a special value that
' identifies it as a sector that contains the FAT. Sector 1 (bytes 1024-1535) contains
' directory data, and was identified as such in the Header (offset 48, stored in the
' variable "FirstSectorOfDirectory%"). The next sector in the directory stream is 4,
' which is chained to sector 7, etc. Sector 2 contains minisector data (this also was
' identified in the Header; see comments in the next Sub). The next sector in the stream,
' therefore also containing minisector data, is 63. Sector 3 contains other data, and the
' sector containing the data that follows it is sector 5, and so on. The special ID
' numbers that carry metadata information are:
'   -3 (hex FFFFFFFD) : sector contains (part of) the FAT
'   -2 (hex FFFFFFFE) : the end of a stream (the last data in the stream was in the previous sector)
'   -1 (hex FFFFFFFF) : an empty, or free, sector.

Dim Break%                   : Break% = 1
Dim FATSectorsCount%
Dim FATSectorString$
Dim Index%
Dim SectorContents&
Dim SectorCount%
Dim SectorID&

Dim FATSectorIDs() As Long

' The first step is to get the sector IDs of the sectors that comprise the FAT. The first
' 109 of those sector IDs, along with their total count, are found in the Header. Put
' those sector IDs into an array that might look like this:
'
'          index of array:    0    1    2    3    4
'   ID of next FAT sector:    0  128  256  384  512

For FATSectorsCount% = 0 To TotalSectorsInFAT% - 1
  SectorID& = HexVal( Mid$( FATSectorListInHeader$, FATSectorsCount% * DWORD + 1, DWORD ) )
  ReDim Preserve FATSectorIDs( FATSectorsCount% )
  FATSectorIDs( FATSectorsCount% ) = SectorID&
Next FATSectorsCount%

' Each sector named in the array just assembled consists entirely of a list of sector IDs
' (128 sector IDs at 4 bytes each = 512 bytes = 1 sector). The next step is to
' concatenate all those lists into a single string. Finally, finish building the FAT by
' breaking the string into the 4-byte elements of the FAT array.

For SectorCount% = 0 To TotalSectorsInFAT% - 1
  FATSectorString$ = GetSectorData( FATSectorIDs( SectorCount% ), MAIN_C )
  Do While Break% < Len( FATSectorString$ )
    SectorContents& = HexVal( Mid$( FATSectorString$, Break%, DWORD ) )
    ReDim Preserve FAT( Index% )
    FAT( Index% )   = SectorContents&
    Break%          = Break% + DWORD
    Index%          = Index% + 1
  Loop
  Break% = 1
Next SectorCount%

End Sub

'****************************************************************************************

Sub BuildMiniFAT( TotalSectorsInMiniFAT%, FirstSectorOfMiniFAT% )

' This subprogram builds the MiniFAT, an array that parallels the FAT, except that it
' maps not the sectors of the file, but minisectors--sectors of 64 bytes, or 1/8 of a
' sector. Otherwise, it works the same way, with the index of the array corresponding to
' the cardinal number of those minisectors, and the elements of the array indicating the
' next segment in the appropriate stream. This array might look like this:
'
'           mini sector ID:    0    1    2    3    4    5    6    7    8    9
'   ID of next mini sector:  268    2   35   -2    5    6    7    8    9   10
'
' Here, data in the first minisector is followed by data in the minisector whose ID is
' 268. Data in minisector 1 is followed by data in minisector 2, and then data in
' minisector 35. Minisector 3 contains the metadata value that indicates that the stream
' that it terminates (wherever that stream started) is complete.

Dim Break%                   : Break% = 1
Dim FATSectorString$
Dim Index%
Dim MiniFATSectorsCount%
Dim SectorContents&
Dim SectorCount%
Dim SectorID&

Dim MiniFATSectorIDs() As Long

' Begin by getting the sector IDs (as listed in the FAT) of those sectors containing data
' about minisectors (as opposed to the data contained in the minisectors). This
' intermediate array is a list of sector IDs; each of the named sectors contains 128 IDs
' of minisectors:
'
'   index of array:    0    1    2    3    4    5
'     ID of sector:    2   63   80  294  588  613
'
' This tells us that sector 2 contains the beginning of the list of minisectors (this
' sector was identified in the Header by bytes 60-63, read into the variable
' "FirstSectorOfMiniFAT%"), and is continued by the 128 minisector IDs contained in
' sector 63, then those in sector 80, and so on.

If FirstSectorOfMiniFAT% <> END_OF_CHAIN Then
    SectorID&                                = FirstSectorOfMiniFAT%
    ReDim MiniFATSectorIDs( MiniFATSectorsCount% )
    MiniFATSectorIDs( MiniFATSectorsCount% ) = FirstSectorOfMiniFAT%
    For MiniFATSectorsCount% = 1 To TotalSectorsInMiniFAT% - 1
      ReDim Preserve MiniFATSectorIDs( MiniFATSectorsCount% )
      MiniFATSectorIDs( MiniFATSectorsCount% ) = FAT( SectorID& )
      SectorID&                                = FAT( SectorID& )
    Next MiniFATSectorsCount%

' Each sector named in the array just assembled consists entirely of a list of sector IDs
' (128 sector IDs at 4 bytes each = 512 bytes = 1 sector). The next step is to
' concatenate all those lists into a single string. Finally, finish building the MiniFAT
' by breaking the string into the 4-byte elements of the MiniFAT array.

    For SectorCount% = 0 To TotalSectorsInMiniFAT% - 1
      FATSectorString$ = GetSectorData( MiniFATSectorIDs( SectorCount% ), MAIN_C )
      Do While Break% < Len( FATSectorString$ )
        SectorContents&   = HexVal( Mid$( FATSectorString$, Break%, DWORD ) )
        ReDim Preserve MiniFAT( Index% )
        MiniFAT( Index% ) = SectorContents&
        Break%            = Break% + DWORD
        Index%            = Index% + 1
      Loop
      Break% = 1
   Next SectorCount%
End If

End Sub

'****************************************************************************************

Sub BuildMinistream( MinistreamStart& )

' This subprogram creates an array containing the contents of the minisectors,
' parallelling the array that contains the contents of the file ("FileSectors"). The
' minisectors contain data in 64-byte chunks, and any particular ministream may contain
' up to 64 minisectors, for a maximum size of 4096 bytes. (Longer streams are stored in
' regular, or normal, 512-byte sectors with no maximum length.) The Connexion client
' stores macro descriptions (as well as short macros) in these ministreams. Note that
' when considering regular or normal 512-byte sectors, sector 0 always starts at byte 512
' of the file, but that when considering minisectors, the beginning of the stream of
' minisectors may be located anywhere in the file; its location is identified in the root
' entry in the directory. In the macro book files, the Ministreams seem to begin most
' often in sector 3.

Dim MiniSecID%
Dim MinistreamPortion$
Dim NextSector&

Dim MinistreamSectorIDs() As Long

Dim i As Integer, j As Integer

' The root entry of the directory tells which sector contains the first data of the Mini-
' stream and how long the whole Ministream is. With this information an array can be
' built which lists the sectors that contain data in the Ministream:
'
'   index of array:    0    1    2    3    4    5    6    7    8    9
'     ID of sector:   73  127  129  130  131  132  133  143  144  145
'
' Sector 73 (beginning at byte 37888) contains the beginning of the Ministream (that is,
' the first eight minisectors, as there are eight minisectors of 64 bytes in a 512-byte
' sector), which is continued in sectors 127, 129, and so on. This sequence is copied
' from the FAT.

ReDim Preserve MinistreamSectorIDs( 0 )
MinistreamSectorIDs( 0 ) = MinistreamStart&
MiniSecID%               = 1

Do
  NextSector& = FAT( MinistreamSectorIDs( MiniSecID% - 1 ) )
  If NextSector& = END_OF_CHAIN Then
      Exit Do
    Else
      ReDim Preserve MinistreamSectorIDs( MiniSecID% )
      MinistreamSectorIDs( MiniSecID% ) = NextSector&
      MiniSecID% = MiniSecID% + 1
  End If
Loop Until NextSector& = END_OF_CHAIN

' Store the contents of each of the sectors listed in MinistreamSectorIDs in an array
' whose elements are strings with maximum length 31744. Thus, each element of this array
' holds the data of up to 496 minisectors.

For i = 0 To UBound( MinistreamSectorIDs )
  MinistreamPortion$ = MinistreamPortion$ & GetSectorData( MinistreamSectorIDs( i ), MAIN_C )
  If Len( MinistreamPortion$ ) = MAX_STRING_LENGTH Then
      ReDim Preserve MinistreamSectors( j )
      MinistreamSectors( j ) = MinistreamPortion$
      MinistreamPortion$     = ""
      j = j + 1
    Else
      If i = UBound( MinistreamSectorIDs ) Then
          ReDim Preserve MinistreamSectors( j )
          MinistreamSectors( j ) = MinistreamPortion$
      End If
  End If
Next i

End Sub

'****************************************************************************************

Sub GetDirectoryEntries( FirstSectorOfDirectory& )

' Given the ID of the first sector containing directory data, this subprogram follows the
' chain of directory sectors as given in the FAT to create an array of all the directory
' entries in the macro book. Invalid entries will be rejected later.

Dim DirectoryEntry$
Dim DirectorySector$
Dim EntryCount%
Dim NextSector&
Dim PrevSector&
Dim SectorQuarter%

NextSector& = FirstSectorOfDirectory&

Do
  If NextSector& = END_OF_CHAIN Then
      Exit Do
    Else
      DirectorySector$ = GetSectorData( NextSector&, MAIN_C )

' Each 512-byte sector contains four 128-byte directory entries, so fill the array four
' elements at a time by breaking up the sector into its quarters.

      For SectorQuarter% = 0 To 3
        DirectoryEntry$ = Mid$( DirectorySector$, ( SectorQuarter% * DIR_ENTRY_LENGTH + STRING_OFFSET ), DIR_ENTRY_LENGTH )
        If Left$( DirectoryEntry$, 1 ) <> Chr$( 0 ) Then
            ReDim Preserve DirectoryEntries( EntryCount% )
            DirectoryEntries( EntryCount% ) = DirectoryEntry$
            EntryCount%      = EntryCount% + 1
        End If
      Next SectorQuarter%
      PrevSector& = NextSector&
      NextSector& = FAT( PrevSector& )
  End If
Loop Until NextSector& = END_OF_CHAIN

End Sub

'****************************************************************************************

Sub GetFileInfo( SelectedMbkFile$ )

' This subprogram gets important information about the selected macro book file.

Dim FileSectionsArraySize%

Dim i As Integer

InvalidFileLength = FALSE

MacroBookName$ = SelectedMbkFile$
MacroBookFile$ = MacroDirectoryPath$ & MacroBookName$ & ".mbk"
FileInfo$      = "File last updated: " & FileDateTime( MacroBookFile$ )
FileSize&      = FileLen( MacroBookFile$ )

' A file whose length is NOT a multiple of 512 is corrupt in some way, even though its
' macros may display (and even execute) correctly.

If FileSize& Mod SECTOR_SIZE <> 0 Then
    InvalidFileLength = TRUE
End If
FileSizeKBStr$ = Format$( FileSize&, "#,#," )

Call ReadFile( MacroBookFile$ )

FileSectionsArraySize% = UBound( FileSections )
ReDim FileSectors( FileSectionsArraySize% )
For i = 0 To FileSectionsArraySize%
  FileSectors( i ) = FileSections( i )
Next i
Erase FileSections

End Sub

'****************************************************************************************

Sub GetMacroBookFiles

' This macro makes the list of macro book files in the "Macros" folder, checking all
' candidates for both the proper extension and also the correct first eight bytes.

Dim FileCounter%
Dim FileNumber%
Dim First8Bytes As String*DATA_SUBSTRING_8
Dim HeaderSignature$
Dim MacroDirectoryFiles$
Dim Possibility$

' Test that the file is really a macrobook file, no matter its extension.

HeaderSignature$ = Chr$( 208 ) & Chr$( 207 ) & Chr$( 017 ) & Chr$( 224 ) & Chr$( 161 ) & Chr$( 177 ) & Chr$( 026 ) & Chr$( 225 )

' Find the path to OCLC's "Macros" folder and make an array of the macro books it
' contains to display in a drop list box in the dialog box. Also build a string of macro
' book names, along with file modification dates, for saving.

ReDim MacroBooks( FileCounter% )
MacroBooks( FileCounter% ) = "Select a macro book:"
FileCounter%               = FileCounter% + 1
AppDataPath$               = Environ( "APPDATA" )
If AppDataPath$ = "" Then
    Exit Sub
  Else
    MacroDirectoryPath$ = AppDataPath$ & MacroDirectoryPath$
End If
MacroDirectoryFiles$       = MacroDirectoryPath$ & "*.mbk"
MacroBookFile$             = Dir( MacroDirectoryFiles$ )
MacroBookList$             = ""

Do While MacroBookFile$ <> ""
  Possibility$   = MacroDirectoryPath$ & MacroBookFile$
  FileNumber%    = Freefile
  Open Possibility$ For Binary As #FileNumber%
  Get #FileNumber%, , First8Bytes
  Close #FileNumber%
  Reset
  If First8Bytes = HeaderSignature$ Then
      MacroBookName$             = Left$( MacroBookFile$, Len( MacroBookFile$ ) - FILE_EXTENSION% )
      ReDim Preserve MacroBooks( FileCounter% )
      MacroBooks( FileCounter% ) = MacroBookName$
      MacroBookList$             = MacroBookList$ & MacroBookName$ & TAB_CHAR & FileDateTime( Possibility$ ) & CRLF
      FileCounter%               = FileCounter% + 1
  End If
  MacroBookFile$ = Dir
Loop
MacroBookList$ = Left$( MacroBookList$, Len( MacroBookList$ ) - 2 )

End Sub

'****************************************************************************************

Sub GetMacroInfo( ThisMacroRecord As MacroRecord )

' This subprogram gets the text (source data) of the selected macro. This supplies a line
' count, which gives an idea of the size of the macro, and also enables some checking of
' the integrity of the macro. The first 25 lines are examined to look for a revision
' date, and are stored (up to 1024 bytes) to display in a dialog box.

Dim FirstSector&
Dim LineBegin$
Dim LineCount&
Dim LineFound%
Dim LinesShown%
Dim MacroChunks&
Dim MacroLine$
Dim MacroLineLength%
Dim Start%
Dim StreamSize&
Dim StringToCheck$
Dim TestDesc$
Dim TextDesc$
Dim TextName$

Dim MaxPreview               : MaxPreview = FALSE

Dim i As Integer, p As Integer, x As Integer
Dim n As Long

Dim SelectedMacro%

MacroRevisionDate$ = ""
MatchCache$        = " "
MatchWarning$      = ""
PreviewLines$      = ""
TestString$        = "0000 "

DifferentDesc      = FALSE

FirstSector& = ThisMacroRecord.tSector1SourceStream
StreamSize&  = ThisMacroRecord.tLengthOfSourceStream
If StreamSize& = 0 Then
    MatchWarning$ = "This macro has been incompletely deleted!"
    Exit Sub
End If

' Build the macro.

If StreamSize& < MAX_SIZE_MINISTREAM Then
    Call BuildDataStream( FirstSector&, MINI_C, StreamSize& )
  Else
    Call BuildDataStream( FirstSector&, MAIN_C, StreamSize& )
End If

Call StoreWithTerminator( STREAM_DATA )

' Read and count the lines in the macro. (A line is defined as text between two carriage
' return/line feed combinations, that is, a string of characters with the character pair
' "[CR][LF]" or "0D0A" at each end. Connexion macros also work with only a line feed
' character ("0A") as a line terminator. However, I have chosen not to try to make this
' macro able to deal with both styles of line ending; thus macros lacking carriage
' returns ("0D") won't have their information display properly.) The line count gives an
' idea of the size of the macro. As lines are counted and read, check:
'  1) that the macro name in the source code matches what is in the directory;
'  2) that the first line of the macro description in the source code matches what was
'     entered in the macro manager (subsequent lines used for a lengthier description
'     have to be ignored);
'  3) in the first 25 lines, for a possible revision date;
'  4) throughout, for matching subroutine openings and closings.
' Store the first 25 lines, or 1024 bytes (whichever comes first), for display.

MacroChunks& = UBound( EndWithLF)
For n = 0 To MacroChunks&
  StringToCheck$ = EndWithLF( n )
  Start% = 1
  Do
    LineFound% = InStr( Start%, StringToCheck$, CRLF )
    If LineFound% <> 0 Then
        LineCount& = LineCount& + 1
        MacroLine$ = Mid$( StringToCheck$, Start%, LineFound% - Start% )
        MacroLineLength% = Len( MacroLine$ )
        If LineCount& < 26 Then
            If MaxPreview = FALSE Then
                If Len( PreviewLines$ ) + MacroLineLength% < 1024 Then
                    PreviewLines$ = PreviewLines$ & MacroLine$ & CRLF
                    LinesShown%   = LineCount&
                  Else
                    PreviewLines$ = Left$( PreviewLines$, Len( PreviewLines$ ) - 1 )
                    MaxPreview    = TRUE
                End If
            End If
        End If
        ThisMacroRecord.tPreview = PreviewLines$
        If MacroLineLength% > 0 Then
            If Left$( MacroLine$, 1 ) = SINGLE_QUOTE Then
                If LineCount& < 26 Then
                    If TextName = "" Then

' Look for the macro name, which must appear exactly as the macro editor enters it (that
' is, the line must be a comment line, and the macro's name must follow the text
' "MacroName:"), and check it against the macro name as stored in the directory and
' displayed in the macro manager.

                        p = InStr( MacroLine$, "MacroName:" )
                        If p <> 0 Then
                            p = p + 9
                            If MacroLineLength% > p Then
                                TextName$ = Trim$( Mid$( MacroLine$, p + 1 ) )
                                If TextName$ <> ThisMacroRecord.tName Then
                                    SourceName$ = TextName$
                                  Else
                                    SourceName$ = ""
                                End If
                              Else
                                SourceName$ = ""
                                TextName$   = "[NOT FOUND]"
                            End If
                            ThisMacroRecord.tNameInSource = SourceName$
                        End If
                    End If

' Also look for the macro description, and check it against the description stored in the
' macro's ".DES" stream (the text entered in the macro manager). As with the name, the
' description must appear in a comment line. The description entered here may be
' formatted so it spans multiple lines, but the macro can't tell which might be the last
' line; therefore, only the first line is considered. If this first line does not match
' the official description, a flag is set to display a warning. If a mismatch occurs
' after the first line of the description, the macro can't detect that.

                    If TextDesc$ = "" Then
                        p = InStr( MacroLine$, "MacroDescription:" )
                        If p <> 0 Then
                            p = p + 16
                            If MacroLineLength% > p Then
                                TextDesc$ = Trim$( Mid$( MacroLine$, p + 1 ) )
                                TestDesc$ = ThisMacroRecord.tDescription
                                If TextDesc$ = "" And TestDesc$ = "" Then
                                    DifferentDesc = FALSE
                                  ElseIf TextDesc$ = "" And TestDesc$ <> "" Then
                                    DifferentDesc = TRUE
                                  ElseIf TextDesc$ <> "" And TestDesc$ = "" Then
                                    DifferentDesc = TRUE
                                  Else
                                    If TestDesc$ <> "[NO DESCRIPTION PROVIDED]" Then
                                        x = InStr( 1, TestDesc$, TextDesc$, 0 )
                                        If x = 0 Then
                                            DifferentDesc = TRUE
                                          Else
                                            DifferentDesc = FALSE
                                        End If
                                    End If
                                End If
                              Else
                                TextDesc$ = "[NOT FOUND]"
                            End If
                        End If
                    End If
                    ThisMacroRecord.tDescriptionInSource = DifferentDesc

' Check for a revision date.

                    If MacroRevisionDate$ = "" Then
                        If LineCount& > 2 Then
                            MacroRevisionDate$ = FindRevisionDate( MacroLine$ )
                        End If
                    End If
                End If
              Else

' Check for matching subroutine and function calls and ends.

                LineBegin$ = LCase$( Left$( Trim$( MacroLine$ ), 4 ) )
                If LineBegin$ = "end " Or LineBegin$ = "sub " Or LineBegin$ = "func" Or LineBegin$ = "priv" Or LineBegin$ = "stat" Then
                    If MatchWarning$ = "" Then
                        MatchWarning$ = MatchCalls( MacroLine$, LineCount& )
                    End If
                End If
            End If
        End If
    End If
    Start% = LineFound% + 2
  Loop While LineFound% > 0
Next n

ThisMacroRecord.tLineCountOfSourceCode = LineCount&
If LinesShown% > 25 Then
    LinesShown% = 0
End If
ThisMacroRecord.tPreviewLineCount = LinesShown%

' Format the revision date statement.

If MacroRevisionDate$ = "" Then
    MacroRevisionDate$ = "[No revision date found]"
  Else
    MacroRevisionDate$ = DOUBLE_QUOTE & MacroRevisionDate$ & DOUBLE_QUOTE
End If
ThisMacroRecord.tRevisionDate = MacroRevisionDate$

' If the last called "Sub" or "Function" was not closed:

Select Case Left$( MatchCache$, 1 )
  Case "S"
    MatchWarning$ = DOUBLE_QUOTE & "Sub" & DOUBLE_QUOTE & " called on line " & Mid$( MatchCache$, 2 ) & ", but no " & DOUBLE_QUOTE & "End Sub" & DOUBLE_QUOTE & " was found."
  Case "F"
    MatchWarning$ = DOUBLE_QUOTE & "Function" & DOUBLE_QUOTE & " called on line " & Mid$( MatchCache$, 2 ) & ", but no " & DOUBLE_QUOTE & "End Function" & DOUBLE_QUOTE & " was found."
End Select

If MatchWarning$ <> "" Then
    MatchWarning$ = "Probably corrupt macro! " & MatchWarning$
End If
ThisMacroRecord.tMatchWarning = MatchWarning$

End Sub

'****************************************************************************************

Sub GetMacroNames

' This subprogram runs through all the directory entries previously extracted to get the
' macro names, which it pulls out, along with information about each macro.

Const DIR_ENTRY_NAME_LENGTH As Integer = 65   'The location of the value for the length of a directory entry name.
Const OBJECT_TYPE           As Integer = 67   'The location of the value of a type of object (0, 1, 2, or 5).
Const STREAM_SIZE           As Integer = 121  'The size of the user-defined data, if this is a stream object.
Const VALID_STREAM          As Integer = 2    'The value for a valid stream object in a directory entry.

Dim DirectoryEntry$
Dim DirEntryCount%
Dim DirEntryName$
Dim DirName$
Dim FirstSector&
Dim LenDirEntryName%
Dim MacroDescription$
Dim MacroName$
Dim NameChar%
Dim StreamSize&
Dim StreamType$
Dim TypeOfDirEntry%

Dim i As Integer, j As Integer
Dim ThisMacroRecord As MacroRecord

Dim TempMacroStore() As MacroRecord

For DirEntryCount% = 0 To UBound( DirectoryEntries )
  DirectoryEntry$ = DirectoryEntries( DirEntryCount% )
  TypeOfDirEntry% = CInt( HexVal( Mid$( DirectoryEntry$, OBJECT_TYPE, 1 ) ) )

' Only valid entries referring to stream objects are needed. Other entries, if present,
' are ignored, and data in the root directory entry have already been obtained. For each
' entry, get the name and convert it to ASCII (i.e., strip it of null characters). Also
' get the sector number of the beginning of the associated data stream and its length.

  If TypeOfDirEntry% = VALID_STREAM Then
      LenDirEntryName% = CInt( HexVal( Mid$( DirectoryEntry$, DIR_ENTRY_NAME_LENGTH, 2 ) ) )
      DirEntryName$    = Left$( DirectoryEntry$, LenDirEntryName% )
      DirName$         = ""
      For NameChar% = 1 To Len( DirEntryName$ ) - 2 Step 2
        DirName$ = DirName$ & Mid$( DirEntryName$, NameChar%, 1 )
      Next NameChar%
      DirName$         = Trim$( DirName$ )
      FirstSector&     = HexVal( Mid$( DirectoryEntry$, STREAM_START, DWORD ) )

' The stream size field is eight bytes, containing a 64-bit integer. However, in this
' version (3) of the compound file format, the most significant 32 bits must be zero,
' and can be ignored. Therefore, read only the first four bytes (a double word) of the
' field to get the size of the data stream.

      StreamSize&      = HexVal( Mid$( DirectoryEntry$, STREAM_SIZE, DWORD ) )

' Convert the starting sector ID and the stream size to a string to pass along.

      StreamType$      = Right$( DirName$, 3 )
      ThisMacroRecord.tStreamTypes = StreamType$

      MacroName$       = Left$( DirName$, Len( DirName$ ) - FILE_EXTENSION% )

      Select Case StreamType$

' Each macro appears within the file in three streams, represented in the directory with
' the macro name to which the extensions ".SRC," ".DES," and ".BIN" have been appended.
' The directory entries for the first two streams contain information to asemble the text
' of the macro and the macro description, respectively. To prepare the entries for the
' list of macros, data from the three streams must be isolated and then merged. After
' identifying the stream by the extension, strip the extension from the macro name, and
' add appropriate values from the directory entry. For the ".SRC" entry, add the ID of
' the first sector of the source data, and the stream length of that data, as 8-character
' strings; if they are needed to display the source code, the strings will be converted
' back to numbers later. The result will be a string of 44 characters.

        Case "SRC"
          ThisMacroRecord.tLengthOfSourceStream = StreamSize&
          ThisMacroRecord.tSector1SourceStream = FirstSector&

' Extract also the name from the ".DES" stream, but to it add a blank string of 24
' spaces. Use the directory entry data to get the description (if any) from the
' Ministream, and add that, or else a note about the description not being found, to the
' end of the string, starting at position 53.

        Case "DES"
          If FirstSector& > END_OF_CHAIN Then
              Call BuildDataStream( FirstSector&, MINI_C, StreamSize& )
              MacroDescription$ = DataStream( 0 )
            Else
              MacroDescription$ = "[NO DESCRIPTION PROVIDED]"
          End If
          ThisMacroRecord.tDescription              = MacroDescription$
          ThisMacroRecord.tSector1DescriptionStream = FirstSector&

' For the ".BIN" stream, after processing the name, add only the length of the stream
' that contains the compiled binary, resulting in a string of 36 characters.

        Case "BIN"
          ThisMacroRecord.tLengthOfBinaryStream = StreamSize&
          ThisMacroRecord.tSector1BinaryStream  = FirstSector&

      End Select
      ThisMacroRecord.tName = Left$( DirName$, Len( DirName$ ) - FILE_EXTENSION% )

' Send the newest macro name to the subprogram for insertion or merging into the list of
' macros.

      Call SortMacroNames( ThisMacroRecord, StreamType$ )

  End If
Next DirEntryCount%

End Sub

'****************************************************************************************

Sub MakeMacroList( SelectedMbkFile$ )

' This subprogram extracts information required for constructing the list of macros in
' the selected macro book. That information is also used by other subprograms to display
' information about individual macros.

' These constants are offsets in the file (character offsets, starting at 1).

Const DIRECTORY_STREAM_START As Integer = 49   'The starting sector number for the directory stream.
Const FAT_DIRECTORY          As Integer = 77   'The first 109 FAT sector locations of the compound file.
Const FAT_SECTOR_COUNT       As Integer = 45   'The count of the number of FAT sectors in the compound file.
Const HEADER_SECTOR_ID       As Long    = -1&  'The ID of the sector that precedes sector 0.
Const MINI_FAT_SECTOR_COUNT  As Integer = 65   'The count of the number of mini FAT sectors in the compound file.
Const MINI_FAT_START         As Integer = 61   'The starting sector number for the mini FAT.

Dim FileHeader$
Dim FirstSectorOfDirectory&
Dim FirstSectorOfMiniFAT%
Dim MacroListString$
Dim MinistreamStart&
Dim NextMiniSecData$
Dim RootStorageEntry$
Dim TotalSectorsInFAT%
Dim TotalSectorsInMiniFAT%

Dim i As Integer, j As Integer

' Get important values from the Header and the Directory.

FileHeader$             = GetSectorData( HEADER_SECTOR_ID, MAIN_C )

' FAT information:
TotalSectorsInFAT%      = CInt( HexVal( Mid$( FileHeader$, FAT_SECTOR_COUNT, DWORD ) ) )
FATSectorListInHeader$  = Mid$( FileHeader$, FAT_DIRECTORY, 436 )

' Directory information:
FirstSectorOfDirectory& = HexVal( Mid$( FileHeader$, DIRECTORY_STREAM_START, DWORD ) )
RootStorageEntry$       = Left$( GetSectorData( FirstSectorOfDirectory&, MAIN_C ), DIR_ENTRY_LENGTH )
MinistreamStart&        = HexVal( Mid$( RootStorageEntry$, STREAM_START, DWORD ) )

' MiniFAT information:
FirstSectorOfMiniFAT%   = CInt( HexVal( Mid$( FileHeader$, MINI_FAT_START, DWORD ) ) )
TotalSectorsInMiniFAT%  = CInt( HexVal( Mid$( FileHeader$, MINI_FAT_SECTOR_COUNT, DWORD ) ) )

' Build the two FATs, the Ministream, and the Directory entries array.

BeginBF#  = Timer
Call BuildFAT( TotalSectorsInFAT% )
FinishBF# = Timer
TimeBF$   = FormatDuration( BeginBF#, FinishBF# )

BeginBMF#  = Timer
Call BuildMiniFAT( TotalSectorsInMiniFAT%, FirstSectorOfMiniFAT% )
FinishBMF# = Timer
TimeBMF$   = FormatDuration( BeginBMF#, FinishBMF# )

If MinistreamStart& > END_OF_CHAIN Then
    BeginBMS#   = Timer
    Call BuildMinistream( MinistreamStart& )
    FinishBMS#  = Timer
    TimeBMS$    = FormatDuration( BeginBMS#, FinishBMS# )
End If

Call GetDirectoryEntries( FirstSectorOfDirectory& )

' Build the array of macro names.

BeginDS# = Timer

MacroCount% = 0

Call GetMacroNames

' Cleanup the macro name array. Remove entries that don't have all three streams (source,
' description, and binary), as they are invalid, and remove empty rows.

i = 0
Do
  If Len( MacroListB( i ).tStreamTypes ) < 9 Or MacroListB( i ).tName = "" Then
      If i = UBound( MacroListB) Then
          ReDim Preserve MacroListB( i - 1 )
        Else
          For j = ( i + 1 ) To UBound( MacroListB )
            MacroListB( j - 1 ) = MacroListB( j )
          Next j
          ReDim Preserve MacroListB( UBound( MacroListB ) - 1 )
      End If
  End If
  i = i + 1
Loop Until i > UBound( MacroListB)

TotalMacroCount% = UBound( MacroListB)

' Prepare values for the dialog box. First, reDim the link array to the number of macros
' in the book.

ReDim LinkingArray( TotalMacroCount%, 1 )

' Set the text for the count of macros.

If TotalMacroCount% = 0 Then
    SummaryMacroCount$ = "One macro:"
  Else
    SummaryMacroCount$ = Trim$( Str$( TotalMacroCount% + 1 ) ) & " macros:"
End If

' The display list is the names only, shorn of the other data.

For i = 0 To TotalMacroCount%
  ReDim Preserve MacroListNames( i )
  MacroListNames( i ) = MacroListB( i ).tName
Next i

FinishDS# = Timer
TimeDS$   = FormatDuration( BeginDS#, FinishDS# )

' Place the list on the clipboard.

MacroListString$ = "Macro book name: " & MacroBookName$ & CRLF
For i = 0 To TotalMacroCount%
  MacroListString$ = MacroListString$ & MacroListNames( i ) & CRLF
Next i
MacroListString$ = Left$( MacroListString$, Len( MacroListString$ ) - 2 )
Clipboard.Clear
Clipboard.SetText MacroListString$

End Sub

'****************************************************************************************

Sub ReadFile( FileName$ )

' This subprogram reads the file whose name is passed to it and stores the data in a
' string array for the rest of the macro.

Dim CountFileSections%
Dim FileDivider&
Dim FileEnd$
Dim FileNumber%
Dim FileSectionRead As String*MAX_STRING_LENGTH
Dim Remainder%
Dim TotalFileSections%

FileNumber% = Freefile

' Open the selected file. Because of the limitations on string length in OCLC's version
' of BASIC, the file can only be read in chunks of about 32K bytes, so the macro may
' have to loop through it several times to read it all. The chunk size is set at 31744
' bytes, the largest multiple of 512 (the expected sector size) to fit safely under the
' limit.

Open FileName$ For Binary As #FileNumber%
FileSize&          = FileLen( FileName$ )
TotalFileSections% = Int( FileSize& / MAX_STRING_LENGTH )
Remainder%         = FileSize& Mod MAX_STRING_LENGTH
FileDivider&       = 1&
CountFileSections% = 0

' Read the file, storing it in a string array whose elements are of maximum length 31744
' (62 sectors).

If TotalFileSections% > 0 Then
    For CountFileSections% = 1 To TotalFileSections%
      Get #FileNumber%, FileDivider&, FileSectionRead
      ReDim Preserve FileSections( CountFileSections% - 1 )
      FileSections( CountFileSections% - 1 ) = FileSectionRead
      FileDivider& = FileDivider& + MAX_STRING_LENGTH
    Next CountFileSections%
End If
If Remainder% > 0 Then
    Get #FileNumber%, FileDivider&, FileSectionRead
    FileEnd$ = Left$( FileSectionRead, Remainder% )
    If CountFileSections% > 0 Then
        CountFileSections% = CountFileSections% - 1
    End If
    ReDim Preserve FileSections( CountFileSections% )
    FileSections( CountFileSections% ) = FileEnd$
End If

Close #FileNumber%
Reset

End Sub

'****************************************************************************************

Sub SetDialogBox( ThisMacroRecord As MacroRecord )

Dim InfoBoxLegend$
Dim SrcName$
Dim MacroDesc$

InfoBoxLegend$    = "Information about " & DOUBLE_QUOTE & ThisMacroRecord.tDisplayName & DOUBLE_QUOTE
DlgVisible          "Clipboard",        INVISIBLE
MacroDesc$        = ThisMacroRecord.tDescription
DlgText             "Description",      MacroDesc$
DlgVisible          "Description",      VISIBLE
DlgText             "FileInfo",         FileInfo$
DlgFocus            "ListOfMacros"
DlgText             "MacroLines",       "Number of lines in macro: " & Trim$( Str$( ThisMacroRecord.tLineCountOfSourceCode ) )
DlgVisible          "MacroLines",       VISIBLE
DlgText             "MacroSize",        "Size of macro source/binary: " & Trim$( Str$( ThisMacroRecord.tLengthOfSourceStream) ) & "/" & Trim$( Str$( ThisMacroRecord.tLengthOfBinaryStream) )
DlgVisible          "MacroSize",        VISIBLE
If ThisMacroRecord.tDescriptionInSource = "0" Then
    DlgText             "OutlineDesc",      "Description:"
  Else
    DlgText             "OutlineDesc",      "Description (differs in source):"
End If
DlgVisible          "OutlineDesc",      VISIBLE
SrcName$          = ThisMacroRecord.tNameInSource
DlgVisible          "OutlineInfo",      VISIBLE
If SrcName$ = "" Then
    DlgText             "OutlineInfo",      InfoBoxLegend$ & ": "
    DlgVisible          "NameDiffers",      INVISIBLE
    DlgVisible          "NameDiffersBox",   INVISIBLE
  Else

' The limit on the length of a macro name is 27 characters. If the name as given in the
' source is longer, it must be abbreviated to fit into the text box. Keep characters from
' the beginning and the end of the name to try to keep it recognizable.

    If Len( SrcName$ ) > 30 Then
        SrcName$ = Left$( SrcName$, 16 ) & " ... " & Right$( SrcName$, 12 )
    End If
    DlgText             "OutlineInfo",      InfoBoxLegend$ & "*: "
    DlgText             "NameDiffers",      " *Name in source: " & DOUBLE_QUOTE & SrcName$ & DOUBLE_QUOTE
    DlgVisible          "NameDiffers",      VISIBLE
    DlgVisible          "NameDiffersBox",   VISIBLE
End If
DlgVisible          "PreviewButton",    VISIBLE
DlgVisible          "PreviewText",      VISIBLE
DlgText             "RevDate",          ThisMacroRecord.tRevisionDate
DlgVisible          "RevDate",          VISIBLE
DlgEnable           "SaveList",         ENABLED
DlgEnable           "SaveMacro",        ENABLED
DlgVisible          "SelectBooks",      INVISIBLE
DlgVisible          "SelectMacro",      INVISIBLE
DlgText             "Shortcut",         ThisMacroRecord.tShortcutKey
DlgVisible          "Shortcut",         VISIBLE
If ThisMacroRecord.tMatchWarning<> "" Then
    MsgBox MatchWarning$, WARNING_MESSAGE, WaltsMacros$
End If

End Sub

'****************************************************************************************

Sub ShowTimes

' This subprogram displays time elapsed for the various routines of the macro.

Dim ProcRate!
Dim ProcRateStr$
Dim TotalString$             : TotalString$ = "Total time to build macro list: " & TimeMML$

ProcRate!    = FileSize& / Val( TimeMML$ )
ProcRateStr$ = Format$( ProcRate!, "#,#,.##" )

Begin Dialog Dialog2Definition 168, 172, WaltsMacros$
  OkButton       28, 140,  48, 16
  CancelButton   92, 140,  48, 16
  Text           16,   8, 128,  8, "All times given in seconds."
  GroupBox       16,  22, 136, 58, TotalString$
  Text           26,  34,  80,  8, "Time to build FAT:"
  Text          114,  34,  36,  8, TimeBF$
  Text           26,  44,  80,  8, "Time to build MiniFAT:"
  Text          114,  44,  36,  8, TimeBMF$
  Text           26,  54,  80,  8, "Time to build Ministream:"
  Text          114,  54,  36,  8, TimeBMS$
  Text           26,  64,  80,  8, "Time to sort list of names:"
  Text          114,  64,  36,  8, TimeDS$
  Text           16,  86,  82,  8, "Time to build macro data:"
  Text          104,  86,  60,  8, TimeGMI$
  Text           16, 100,  60,  8, "Number of macros:"
  Text          104, 100,  24,  8, Trim$( Str$( TotalMacroCount% + 1 ) )
  Text           16, 110,  60,  8, "File size in KB:"
  Text          104, 110,  48,  8, FileSizeKBStr$
  Text           16, 120,  84,  8, "KB processed per second:"
  Text          104, 120,  48,  8, ProcRateStr$
End Dialog

Dim Dialog2 As Dialog2Definition
On Error Resume Next
Dialog Dialog2

End Sub

'****************************************************************************************

Sub SortMacroNames( NewName As MacroRecord, StreamType$ )

' This subprogram builds the main array of unique macro names, alphabetizing it along the
' way. It compares each new macro name to the other names in the array (disregarding
' case, although it probably doesn't matter--but why is the ".BIN" name sometimes in
' inverted case?). Each name should appear three times, associated with the three types
' of data streams, ".SRC", ".DES", and ".BIN". The order in which these streams appear in
' the directory is inconsistent. If the names are the same, the routine merges the
' entries; otherwise, it either goes back to the first entry or on to the next one, and
' then compares the incoming macro name to each subsequent entry in the array until its
' proper place is found and it is inserted. A macro that does not have all three data
' streams is invalid, and will be removed later in this macro's execution.

Const BIN_ENTRY     As Integer = 36  'The length of the macro name string from the ".BIN" stream.
Const BIN_SRC_ENTRY As Integer = 52  'The length of the string resulting from merging the ".BIN" and ".SRC" streams.
Const SRC_ENTRY     As Integer = 44  'The length of the macro name string from the ".SRC" stream.

Dim ExistingName$
Dim IncomingName$
Dim Incumbent As MacroRecord
Dim IncumbentName$
Dim Start%
Dim TempString$

Dim j As Integer, k As Integer

' For sorting, consider only the leftmost 28 characters.

IncomingName$ = NewName.tName

ReDim Preserve MacroListB( MacroCount% )
If MacroCount% = 0 Then

' The very first name is added without any more ado.

    MacroListB( MacroCount% ) = NewName
    PreviousEntry% = 0

' For the second and subsequent entries in the array, the new name is compared to the
' previously added name. If it is the same, their information is merged; if not, this
' step may reduce the sorting time, as it may be appropriate to start comparison with the
' other entries in the array from the next entry, rather than starting at 0.

  Else
    ExistingName$ = MacroListB( PreviousEntry% ).tName
    Select Case StrComp( IncomingName$, ExistingName$ )
      Case STRING1_LESS_THAN   'new name less than last name added: start comparing at entry 0 in array.
        Start% = 0
      Case Else               'otherwise, start comparing with last name added.
        Start% = PreviousEntry%
    End Select
    For j = Start% To MacroCount%
      Incumbent     = MacroListB( j )
      ExistingName$ = Incumbent.tName
      Select Case StrComp( IncomingName$, ExistingName$ )

' In the merge process, always replace (or simply don't add) the ".BIN" name as its case
' may not be correct, but keep the length of its data stream as the fourth element in the
' string. Otherwise, data may be added to the ".SRC" string or inserted into the ".DES"
' string. Distinguish between the different strings by their lengths, which are constant.
' Don't increase the count of macros for a replacement!

        Case STRING1_EQUAL_TO

          Select Case StreamType$

            Case "BIN"                 'Always replace an existing ".BIN" name
              MacroListB( j ).tLengthOfBinaryStream = NewName.tLengthOfBinaryStream
              MacroListB( j ).tSector1BinaryStream  = NewName.tSector1BinaryStream

            Case "SRC"
              MacroListB( j ).tName    = IncomingName$
              MacroListB( j ).tLengthOfSourceStream = NewName.tLengthOfSourceStream
              MacroListB( j ).tSector1SourceStream  = NewName.tSector1SourceStream

            Case "DES"
              MacroListB( j ).tDescription              = NewName.tDescription
              MacroListB( j ).tSector1DescriptionStream = NewName.tSector1DescriptionStream

          End Select

' To flag invalid entries, keep track of which streams have been merged. Those macros
' which don't have all three streams, in whichever order ("BINDESSRC" or "SRCBINDES",
' etc.) will be removed from the array later.

          TempString$ = MacroListB( j ).tStreamTypes
          If InStr( TempString$, StreamType$ ) = 0 Then
              MacroListB( j ).tStreamTypes = TempString$ & StreamType$
          End If
          MacroCount%    = MacroCount% - 1
          PreviousEntry% = j
          Exit For

' If the newest macro name files before the one in this position in the array, insert it,
' bumping all subsequent names one position toward the end.

        Case STRING1_LESS_THAN
          For k = MacroCount% To j + 1 Step -1
            MacroListB( k ) = MacroListB( k - 1 )
          Next k
          MacroListB( j ) = NewName
          PreviousEntry%  = j
          Exit For

' If the newest macro name files after the one with which it has just been compared,
' recycle to continue comparing--unless the end of the array has been reached, in which
' case the name is simply added.

        Case STRING1_GREATER_THAN
          If j = MacroCount% Then
              MacroListB( MacroCount% ) = NewName
              PreviousEntry%            = j
          End If

      End Select

    Next j
End If

MacroCount% = MacroCount% + 1

End Sub

'****************************************************************************************

Sub StoreWithTerminator( WhichArray% )

' Since the routines that look for shortcut keys or user tool assignments depend on
' finding line terminators, this subprogram adjusts the elements of the storage array so
' each one ends with ASCII 10, the line feed character.

Const LINE_FEED As Integer = 10

Dim CurrString$
Dim CurrStringLen&
Dim PrevString$
Dim PrevStringLen&
Dim TempString$
Dim TestChar%
Dim TwoStrings&

Dim j As Integer, z As Integer
Dim i As Long, n As Long

Dim TempStorage() As String

If WhichArray% = 0 Then      'DataStream
    For i = 0 To UBound( DataStream )
      ReDim Preserve TempStorage( i )
      TempStorage( i ) = DataStream( i )
    Next i
  Else                       'File stream
    For i = 0 To UBound( FileSections )
      ReDim Preserve TempStorage( i )
      TempStorage( i ) = FileSections( i )
    Next i
End If

i = 0
n = 0

Do
  CurrString$    = TempStorage( i )
  CurrStringLen& = Len( CurrString$ )
  PrevStringLen& = Len( PrevString$ )
  TwoStrings&    = CurrStringLen& + PrevStringLen&
  If TwoStrings& >= MAX_STRING_LENGTH Then
      z = MAX_STRING_LENGTH - PrevStringLen&
      For j = z To 1 Step -1
        TestChar% = Asc( Mid$( CurrString$, j, 1 ) )
        If TestChar% = LINE_FEED Then
            Exit For
        End If
      Next j
      If j = 0 Then
          TempString$ = PrevString$
          PrevString$ = ""
          i           = i - 1
        Else
          TempString$ = PrevString$ & Left$( CurrString$, j )
          PrevString$ = Mid$( CurrString$, j + 1 )
      End If
    Else
      TempString$ = PrevString$ & CurrString$
  End If
  ReDim Preserve EndWithLF( n )
  EndWithLF( n ) = TempString$
  n = n + 1
  i = i + 1
Loop Until i > UBound( TempStorage )

End Sub

'****************************************************************************************

Sub WriteFile( SaveType% )

' This is the writing subprogram. After receiving the desired file name, it checks for
' the existence of that file, asking for confirmation of an overwrite. It writes data to
' the file according to what the data is. A list is prefixed with a header of a few lines
' containing a date of file production and other data; a macro's text has a footer with
' that same information. Tabs are used to separate macro names and descriptions, as well
' as to separate macro book file names and date/time of modification of those files.

Const INFORMATION_MESSAGE As Integer = 64

Dim Answer%
Dim Attributes%
Dim CharT$
Dim Credit$        'shameless self-promotion
Dim CurrentDirectory$
Dim DateString$
Dim Drive$
Dim FileAttributes%
Dim FileWrite%
Dim Legend$
Dim NewDir$
Dim Start%
Dim TempString$

Dim i as Integer, p As Integer

Credit$ = " using " & DOUBLE_QUOTE & "MacroBookInspector" & DOUBLE_QUOTE & " macro by Walter F. Nickeson."

' Since OML can't present a typical Save dialog, the next best thing is to offer a string
' that might need no, or only a little, editing to specify the file location. The first
' time the Save sub is called, the default save file name and path (defined on line 284
' above) is offered. On subsequent Saves, the last used path is the basis on which to
' build the complete file name. The previous path is constructed by removing the last
' element (the file name).

If SaveCount% > 0 Then
    TempString$ = PreviousSaves( 0 )
    For i = Len( TempString$ ) To 1 Step -1
      CharT$ = Mid$( TempString$, i, 1 )
      If CharT$ = "\" Then
          DefaultSavePath$ = Left$( TempString$, i )
          Exit For
      End If
    Next i
End If

' The default file name is the default directory path plus either the macro book name or
' the macro name, with the appropriate suffix.

If Right$( DefaultSavePath$, 1 ) <> "\" Then
    DefaultSavePath$ = DefaultSavePath$ & "\"
End If

If SaveType% = SAVE_LIST Then
    Legend$       = "Save list as:"
    SaveFileName$ = DefaultSavePath$ & MacroBookName$ & ".mbk.txt"
  Else
    Legend$       = "Save text of macro as:"
    SaveFileName$ = DefaultSavePath$ & SelectedMacroName$ & ".txt"
End If

Redo:

PreviousSaves( 0 ) = SaveFileName$

Begin Dialog Dialog3Definition  320, 58, WaltsMacros$, .Dialog3ControlFunction
  OkButton      260, 36,  52, 14
  CancelButton  200, 36,  52, 14
  PushButton      8, 36,  52, 14, "Clear",         .Clear
  DropComboBox    8, 16, 304, 64, PreviousSaves(), .ComboBox
  Text            8,  6, 256,  8, Legend$
End Dialog

Dim Dialog3 As Dialog3Definition
On Error Resume Next
Dialog Dialog3
If Err = 102 Then Exit Sub

SaveFileName$ = Trim$( Dialog3.ComboBox)

' On the assumption that subsequent Saves will take place in the same location, use the
' last save path as the basis for the new default location. Put the actual path entered
' in the dialog box into the first element of the array, pushing every previous element
' (if any) up one slot to leave an open first element for the next Save. That will be
' filled the next time around before the dialog box appears.

PreviousSaves( 0 ) = SaveFileName$
SaveCount%         = SaveCount% + 1
ReDim Preserve PreviousSaves( SaveCount% )
For i = UBound( PreviousSaves ) To 0 Step -1
  PreviousSaves( i ) = PreviousSaves( i - 1 )
Next i

' Check to see if the file exists.

On Error Resume Next
FileAttributes% = GetAttr( SaveFileName$ )
Select Case Err
  Case 53

' If the file does not exist, it can be created. But first check that the directory
' structure is in place to receive it. Note that "MkDir" cannot create subdirectories
' more than one level below the parent. If the path given to the function has more
' levels, this loop adds one subdirectory at a time, then changes the default directory
' to the newly added subdirectory. Repeat as necessary.

    For i = Len( SaveFileName$ ) To 1 Step -1
      CharT$ = Mid$( SaveFileName$, i, 1 )
      If CharT$ = "\" Then
          NewDir$ = Left$( SaveFileName$, i - 1 )
          Attributes% = GetAttr( NewDir$ )
          If Attributes% < 16 Then
              Answer% = MsgBox( "The path " & DOUBLE_QUOTE & NewDir$ & DOUBLE_QUOTE & " does not exist! Create new directories?", 35, WaltsMacros$ )
              Select Case Answer
                Case 2
                  Exit Sub
                Case 6
                  Exit For
                Case 7
                  GoTo Redo:
              End Select
            Else
              Exit For
          End If
      End If
    Next i
    CurrentDirectory$ = CurDir$
    Start%            = 1
    Do
      p = InStr( Start%, SaveFileName$, "\" )
      If p <> 0 Then
          If Start% = 1 Then

' If an incorrect drive is specified, this sub can't proceed.

              Drive$      = Left$( SaveFileName$, p )
              Attributes% = GetAttr( Drive$ )
              If Attributes% <> 16 And Attributes% <> 22 And Attributes% <> 48 Then
                  MsgBox "Please enter a valid filename with complete path!", WARNING_MESSAGE, WaltsMacros$
                  Exit Sub
              End If
            Else
              NewDir$     = Left$( SaveFileName$, p - 1 )
              Attributes% = GetAttr( NewDir$ )
              If Attributes% < 16 Then
                  MkDir NewDir$
              End If
              ChDir NewDir$
          End If
        Else
          ChDir CurrentDirectory$
      End If
      Start% = p + 1
    Loop Until p = 0
  Case 52, 64
    MsgBox "Please check the file name!", WARNING_MESSAGE, WaltsMacros$
    Exit Sub
  Case 61
    MsgBox "Sorry, there is no more room on the disk!", WARNING_MESSAGE, WaltsMacros$
    Exit Sub
  Case 68, 71
    MsgBox "Sorry, the device is unavailable!", WARNING_MESSAGE, WaltsMacros$
    Exit Sub
  Case Else     'File exists; confirm replacement
    If FileAttributes% < 8 Or FileAttributes% > 16 Then
        Answer% = MsgBox( "Replace existing file?", 35, WaltsMacros$ )
        If Answer% = 6 Then
            Kill SaveFileName$
          Else
            Exit Sub
        End If
    End If
End Select

DateString$ = Date$ & " " & Time$
DateString$ = Format( DateString$, "General Date" )
FileWrite%  = FreeFile
Open SaveFileName$ For Output As #FileWrite%

If SaveType% = SAVE_LIST Then
    Print #FileWrite%, "Macros in macro book: " & MacroBookName$
    Print #FileWrite%, "File: " & MacroBookFile$
    Print #FileWrite%, FileInfo$
    Print #FileWrite%,
    Print #FileWrite%, "List created " & DateString$ & Credit$
    Print #FileWrite%,
    Print #FileWrite%, Left$( SummaryMacroCount$, Len( SummaryMacroCount$ ) - 1 ) & " (" & FileSizeKBStr$ & " KB):"
    For i = 0 To UBound( MacroListB)
      Print #FileWrite%, MacroListB( i ).tName & TAB_CHAR & MacroListB( i ).tDescription
    Next i
  Else
    For i = 1 To UBound( MainMacroArray, 2 )
      TempString$ = MainMacroArray( SelectedMacroIndex%, i )
      If TempString$ <> "" Then
          Print #FileWrite%, TempString$;
      End If
    Next i
    Print #FileWrite%, SINGLE_QUOTE
    Print #FileWrite%, SINGLE_QUOTE & "Macro name: " & SelectedMacroName$
    Print #FileWrite%, SINGLE_QUOTE & "Macro book: " & MacroBookFile$
    Print #FileWrite%, SINGLE_QUOTE & "Saved: " & DateString$ & Credit$
End If

Close FileWrite%
Reset

FileAttributes% = -1
FileAttributes% = GetAttr( SaveFileName$ )
If FileAttributes% = -1 Then
    MsgBox "Sorry, the file could not be created.", WARNING_MESSAGE, WaltsMacros$
  Else
    If SaveType% = SAVE_LIST Then
        MsgBox "List of macros saved.", INFORMATION_MESSAGE, WaltsMacros$
      Else
        MsgBox "Text of macro saved.",  INFORMATION_MESSAGE, WaltsMacros$
    End If
End If

End Sub

'****************************************************************************************

Function FindRevisionDate( MacroLine$ ) As String

' This function attempts to find a date of revision in the first 25 lines of a macro.

Const STRING_CHOMPER As Integer = 8

Dim DateFound$
Dim FirstChar%
Dim RevDate%
Dim RevWord%
Dim TempString$

Dim j As Integer, k As Integer

TempString$ = MacroLine$

For j = 0 To UBound( UpdateDate )
  RevDate% = InStr( TempString$, UpdateDate( j ) )
  If RevDate% <> 0 Then

' If a date (that is, a year; searching for month and date also would be a big task and
' so is not implemented here) is found, isolate it for easier comparison. Compare it with
' any date found in a previous line and discard the earlier date (that is, earlier in
' terms of the year; assume that the same year found on a later line represents a later
' revision).

      DateFound$ = Mid$( TempString$, RevDate%, 4 )
      If StrComp( DateFound$, Left$( TestString$, 4 ) ) = STRING1_LESS_THAN Then
          Exit For
        Else

' If a lot of text follows or precedes the date, discard it.

          If Len( TempString$ ) - RevDate% > STRING_CHOMPER Then
              TempString$ = Trim$( Left$( TempString$, RevDate% + STRING_CHOMPER ) ) & "..."
          End If
          If RevDate% > 40 Then
              TempString$ = "..." & Trim$( Mid$( TempString$, RevDate% - 28 ) )
          End If

' Now look for a word indicating revision.

          For k = 0 To UBound( UpdateClues )
            RevWord% = InStr( TempString$, UpdateClues( k ) )
            If RevWord% <> 0 Then             'a revision word is found
                If RevWord% > 7 Then          'if the word is far enough along in the string, check for "Last" preceding it
                    If Mid$( TempString$, RevWord% - 4, 4 ) = "ast " Then   'if "Last" is found before the revision word,
                        If RevWord% > 10 Then                               'chop off all preceding it
                            TempString$ = Mid$( TempString$, RevWord% - 6 )
                        End If
                      Else
                        TempString$ = Mid$( TempString$, RevWord% - 1 )
                    End If
                End If
                j = UBound( UpdateDate )
                Exit For
            End If
          Next k
          If RevWord% > 0 Then
              TestString$ = DateFound$ & TempString$
            Else         'Date found, but no revision word: Accept it anyway
              TestString$ = "    " & TempString$
              Exit For
          End If
      End If
  End If
Next j

TempString$ = Mid$( TestString$, 5 )
If TempString$ = " " Then
    FindRevisionDate = ""
  Else
    If Left$( TempString$, 1 ) = "'" Then
        TempString$ = Trim$( Mid$( TempString$, 2 ) )
    End If
    FirstChar% = Asc( Left$( TempString$, 1 ) )
    If FirstChar% > 96 And FirstChar% < 123 Then
        FirstChar% = FirstChar% - 32
        Mid( TempString$, 1, 1 ) = Chr$( FirstChar% )
    End If
    FindRevisionDate = Trim$( TempString$ )
End If

End Function

'****************************************************************************************

Function FormatDuration( BeginTime#, EndTime# ) As String

' This function is used when timing macros to (arbitrarily) reduce significant digits
' after the decimal to three.

Const DECIMAL_PLACES As Integer = 3

Dim TempTime#
Dim TimeString$

Dim i As Integer, j As Integer

TempTime#   = Format( EndTime# - BeginTime#, "#.###" )
TimeString$ = Trim$( Str$( TempTime# ) )
i           = InStr( TimeString$, "." )
If i = 0 Then
    TimeString$ = TimeString$ & ".000"
  Else
    j = DECIMAL_PLACES - ( Len( TimeString$ ) - i )
    If j < 3 Then
        TimeString$ = TimeString$ & String$( j, 48 )
    End If
    If i = 1 Then
        TimeString$ = "0" & TimeString$
    End If
End If

FormatDuration = TimeString$

End Function

'****************************************************************************************

Function FormatTimeButton( TimeString$ ) As String

' This little function adds an ampersand to make the decimal point on the elapsed time
' button the hotkey.

Dim p As Integer

p = InStr( TimeString$, "." )
If p < 2 Then
    FormatTimeButton = "&" & TimeString$
  Else
    FormatTimeButton = Left$( TimeString$, p - 1 ) & "&" & Mid$( TimeString$, p )
End If

End Function

'****************************************************************************************

Function GetKeyAssignment( FullMacroName$ )

' To find a keystroke shortcut assigned to a selected macro, this subprogram first looks
' for the file "Custom.Keymap.xml," usually stored in "[main drive letter]:\Users\[user
' name]\AppData\Roaming\OCLC\Connex\Profiles\MyProfile\". If the file is found, it is
' searched for the macro name, and if that is found, the keystroke shortcut is extracted.
' If no keystroke sequence has been assigned, the subprogram then looks for a user tool
' assignment. This is stored in the "Options.xml" file in the same directory. If the
' macro name is found in this file, the user tool assignation is extracted.

Const CASE_SENSITIVE As Integer = 0

Dim NULL_CHAR As String*1    : NULL_CHAR = Chr$( 0 )

Dim Attributes%
Dim CustomKeymapFile$
Dim FileNum%
Dim KeyString$
Dim KeyStringEnd%
Dim KeyStringStart%
Dim OptionsFile$
Dim Start%                   : Start%    = 1
Dim TempString$
Dim TestChar%
Dim UnicodeMacroName$
Dim KeyFileSize&

Dim i As Integer, p As Integer, q As Integer

' First, get to the keymap file; if not in the expected place, no key assignment can be
' displayed. Prior to Windows 7, the file was stored in the path defined by the
' AppDataPath$ variable and "\OCLC\Connex\Profiles\MyProfile\Custom.Keymap.xml".

CustomKeymapFile$ = AppDataPath$ & "\OCLC\Connex\Profiles\MyProfile\Custom.Keymap.xml"
On Error GoTo Done:
Attributes% = GetAttr( CustomKeymapFile$ )
If Attributes% = 0 Or Attributes% = 32 Then
    On Error GoTo NoFile:
    Call ReadFile ( CustomKeymapFile$ )
    Call StoreWithTerminator( FILE_DATA )

' If the file is found, search in it for the macro name. This is a Unicode rather than a
' text file, so null characters must be added to the macro name to make it look like
' Unicode in order to match. In this case, the comparison must be by byte, not by
' character.

    For p = 1 To Len( FullMacroName$ )
      UnicodeMacroName$ = UnicodeMacroName$ & Mid$( FullMacroName$, p, 1 ) & NULL_CHAR
    Next p
    For i = 0 To UBound( EndWithLF )
      KeyString$ = EndWithLF( i )
      p = InStr( Start%, KeyString$, UnicodeMacroName$, CASE_SENSITIVE )
      If p <> 0 Then

' If the name is found, step backward in the string to the end of the previous line
' (marked by the line feed character, ASCII 10), and then jump forward to the beginning
' of the keystroke string.

          KeyStringEnd% = p - 18
          q = KeyStringEnd%
          Do
            q = q - 2
            TestChar% = Asc( Mid$( KeyString$, q ) )
          Loop Until TestChar% = 10
          KeyStringStart% = q + 32
          TempString$     = Mid$( KeyString$, KeyStringStart%, KeyStringEnd% - KeyStringStart% - 1 )

' Take out the null characters from the keystroke string.

          Do
            p = InStr( TempString$, NULL_CHAR )
            If p <> 0 Then
                TempString$ = Left( TempString$, p - 1 ) & Mid$( TempString$, p + 1 )
            End If
          Loop Until p = 0

' Microsoft says to developers: "Don't use the following characters for shortcut keys: @
' ? $ {} [] \ ~ | ^ ' < >. These characters require different key combinations across
' languages or are locale specific." So the following substitutions may not work on every
' computer.

          p = InStr( TempString$, "Oem" )
          If p <> 0 Then
              Select Case Mid$( TempString$, p + 3 )
                Case "1"
                  TempString$ = Left$( TempString$, p - 1 ) & "Semicolon"
                Case "5"
                  TempString$ = Left$( TempString$, p - 1 ) & "Backslash"
                Case "6"
                  TempString$ = Left$( TempString$, p - 1 ) & "CloseBrackets"
                Case "7"
                  TempString$ = Left$( TempString$, p - 1 ) & "Quotes"
              End Select
          End If
          TempString$ = "Shortcut keystrokes: " & TempString$
          GoTo Done:
      End If
    Next i
End If

' If the macro has not been assigned to a keystroke, check for assignation to a user
' tool.

OptionsFile$ = AppDataPath$ & "\OCLC\Connex\Profiles\MyProfile\Options.xml"
On Error GoTo NoFile:
Attributes%  = GetAttr( OptionsFile$ )
If Attributes% = 0 Or Attributes% = 32 Then
    Call ReadFile (OptionsFile$)
    On Error GoTo NoFile:
    Call StoreWithTerminator( FILE_DATA% )
    For i = 0 To UBound( EndWithLF )
      KeyString$ = EndWithLF( i )
      Do
        p = InStr( Start%, KeyString$, FullMacroName$ )
        If p <> 0 Then

' The macro name appears in this file twice, once as the value for item key "Tool X" and
' also as the value for item key "UserToolTipX". Thus, when the name is found, check
' which item key it is for.

            If Mid$( KeyString$, p - 21, 5 ) = "Tool " Then
                TempString$ = Mid$( KeyString$, p - 21, 7 )
                If Right$( TempString$, 1 ) = DOUBLE_QUOTE Then
                    TempString$ = Left$( TempString$, Len( TempString$ ) - 1 )
                End If
                TempString$ = "User tool: " & TempString$
                GoTo Done:
              Else
                Start% = p + 4
            End If
        End If
        i = i + 1
      Loop Until p = 0
    Next i
End If

Done:

GetKeyAssignment = TempString$

NoFile:

End Function

'****************************************************************************************

Function GetSectorData( SectorID&, WhichDataArray% ) As String

' Given a sector ID and the appropriate array (that containing file data or that
' containing Ministream data), this function retrieves the data in that sector. Since the
' first character in a string is at position 1, but the first element of an array is
' numbered 0, an offset of 1 has to be added.

Dim StartPos&
Dim WhichElement%

If WhichDataArray% = MAIN_C Then
    StartPos&     = ( SectorID& * SECTOR_SIZE ) + SECTOR_SIZE + STRING_OFFSET
    WhichElement% = Int( StartPos& / MAX_STRING_LENGTH )
    StartPos&     = StartPos& - ( MAX_STRING_LENGTH * CLng( WhichElement% ) )
    GetSectorData = Mid$( FileSectors( WhichElement% ), StartPos&, SECTOR_SIZE )
  Else
    StartPos&     = ( SectorID& * MINI_SECTOR_SIZE ) + STRING_OFFSET
    WhichElement% = Int( StartPos& / MAX_STRING_LENGTH )
    StartPos&     = StartPos& - ( MAX_STRING_LENGTH * CLng( WhichElement% ) )
    GetSectorData = Mid$( MinistreamSectors( WhichElement% ), StartPos&, MINI_SECTOR_SIZE )
End If

End Function

'****************************************************************************************

Function HexVal( InBytes$ ) As Long

' This function converts the string of bytes to a hex number and then to decimal (thanks
' to Joel Hahn for insight into this function). It perhaps is not strictly necessary, but
' the raw bytes must be manipulated anyway, as they are in little-endian order, and for
' this non-programmer, decimal is much easier to read than hex.

Dim ASCIIChar%
Dim Byte$
Dim HexString$

Dim i As Integer

For i = 1 To Len( InBytes$ )
  ASCIIChar% = Asc( Mid$( InBytes$, i, 1 ) )
  Byte$      = Hex$( ASCIIChar% )
  If Len(Byte$) = 1 Then
      Byte$ = "0" & Byte$
  End If
  HexString$ = Byte$ & HexString$
Next i

HexString$ = "&H" & Trim$( UCase$( HexString$ ) )
HexVal     = Val( HexString$ )

End Function

'****************************************************************************************

Function MatchCalls( MacroLine$, LineCount& ) As String

' This routine checks for matching Sub...End Sub and Function...End Function statements
' (including those called with the "Private" or "Static" keywords) as a clue to macro
' corruption.

Const LEN_TEST_STRING As Integer = 12  'Arbitrary limit to how much of the line to read looking for
                                       ' "Function" and "Sub" words.

Dim CurrentLine$
Dim TestString As String*LEN_TEST_STRING
Dim Warning$

TestString   = LCase$( Trim$( MacroLine$ ) )
CurrentLine$ = Trim$( Str$( LineCount& ) )

' If a sub is invoked, see if there is a previous "Sub" still open (the first character
' in "MatchCache$" should be a space, indicating a previous subprogram or function has
' been closed). If no "Sub" is open, reset the first character in "MatchCache$" to show a
' "Sub" was found; otherwise build the warning that an "End" is missing.

If Left$( TestString, 4 ) = "sub " Or TestString = "private sub " Or Left$( TestString, 11 ) = "static sub " Then
    If Left$( MatchCache$, 1 ) = "S" Then
        Warning$ = "Closing " & DOUBLE_QUOTE & "End Sub" & DOUBLE_QUOTE & " lacking."
      ElseIf Left$( MatchCache$, 1 ) = "F" Then
        Warning$ = "Closing " & DOUBLE_QUOTE & "End Function" & DOUBLE_QUOTE & " lacking."
      Else
        MatchCache$ = "S" & CurrentLine$
    End If

' Similarly for a function:

  ElseIf Left$( TestString, 9 ) = "function " Or TestString = "private func" Or TestString = "static funct" Then
    If Left$( MatchCache$, 1 ) = "S" Then
        Warning$ = "Closing " & DOUBLE_QUOTE & "End Sub" & DOUBLE_QUOTE & " lacking."
      ElseIf Left$( MatchCache$, 1 ) = "F" Then
        Warning$ = "Closing " & DOUBLE_QUOTE & "End Function" & DOUBLE_QUOTE & " lacking."
      Else
        MatchCache$ = "F" & CurrentLine$
    End If

' If a sub is ended, see if there is an open sub (the first character in "MatchCache$"
' should be "S"); if so, reset the first character in "MatchCache$" to a space. If not,
' construct the warning, including the line number of the "End".

  ElseIf Left$( TestString, 7 ) = "end sub" Then
    If Left$( MatchCache$, 1 ) = "S" Then
        MatchCache$ = " "
      Else
        Warning$ = "Unexpected " & DOUBLE_QUOTE & "End Sub" & DOUBLE_QUOTE & " found on line " & CurrentLine$ & "."
    End If

' Similarly for a function:

  ElseIf TestString = "end function" Then
    If Left$( MatchCache$, 1 ) = "F" Then
        MatchCache$ = " "
      Else
        Warning$ = "Unexpected " & DOUBLE_QUOTE & "End Function" & DOUBLE_QUOTE & " found on line " & CurrentLine$ & "."
    End If
End If

MatchCalls = Warning$

End Function

'****************************************************************************************

Function Dialog1ControlFunction( Id$, Action%, SuppVal& )

' This function controls the initial setup and subsequent behavior of the main dialog
' box. The box remains open until the "Close" button is clicked, so several lists or
' macros can be saved.

Dim Header$
Dim LineCountReport$
Dim LinesShown%
Dim MaxPreview$
Dim SelectedFile%
Dim SelectedMbkFile$
Dim TotalTime$

Static ThisMacroRecord As MacroRecord

Dim ListChoosing( 1 ) As String
ListChoosing( 0 ) = "Macros are listed in this box. Click on a"
ListChoosing( 1 ) = "macro name for more information."

Select Case Action%

' For the initial setup, hide most of the labels and data; they'll reappear when a macro
' book has been chosen and there is a list of macros to display. Show the warning about a
' possible delay if a macro is large. The beginning save option is for the macro book
' list.

  Case INITIALIZE

    DlgVisible          "Cancel",           INVISIBLE
    DlgVisible          "Clipboard",        INVISIBLE
    DlgVisible          "Description",      INVISIBLE
    DlgValue            "ListOfMacroBooks", 0
    DlgFocus            "ListOfMacroBooks"
    DlgVisible          "FileInfo",         INVISIBLE
    DlgVisible          "FileKBs",          INVISIBLE
    DlgListBoxArray     "ListOfMacros",     ListChoosing()
    DlgVisible          "MacroCount",       INVISIBLE
    DlgVisible          "MacroLines",       INVISIBLE
    DlgVisible          "MacroSize",        INVISIBLE
    DlgVisible          "NameDiffers",      INVISIBLE
    DlgVisible          "NameDiffersBox",   INVISIBLE
    DlgVisible          "OutlineDesc",      INVISIBLE
    DlgVisible          "OutlineInfo",      INVISIBLE
    DlgVisible          "PreviewButton",    INVISIBLE
    DlgVisible          "PreviewText",      INVISIBLE
    DlgVisible          "RevDate",          INVISIBLE
    DlgEnable           "SaveList",         DISABLED
    DlgEnable           "SaveMacro",        DISABLED
    DlgVisible          "SelectBooks",      VISIBLE
    DlgVisible          "SelectMacro",      INVISIBLE
    DlgVisible          "Shortcut",         INVISIBLE
    DlgVisible          "TimeButton",       INVISIBLE


  Case CONTROL_CHANGE

    Select Case Id$

' When a macro book is selected, make the list of its macros, but stop there unless the
' macro book contains a single macro--in which case continue with getting its
' information. Otherwise, wait until a macro is selected, because analysis of a large
' macro (although there is no way to know how large a macro is until it's analyzed) added
' to analysis of a large macro book may cause excessive delay in displaying anything.
' Time the exection of the macro, just for fun. Show or hide dialog box controls as
' appropriate.

      Case "ListOfMacroBooks"

        SelectedFile% = DlgValue( "ListOfMacroBooks" )
        If SelectedFile% > 0 Then
            SelectedMbkFile$ = MacroBooks( SelectedFile% )
            BeginMML#        = Timer
            Call GetFileInfo( SelectedMbkFile$ )
            Call MakeMacroList( SelectedMbkFile$ )
            FinishMML#       = Timer
            TimeMML$         = FormatDuration( BeginMML#, FinishMML# )
            TotalTime$       = FormatTimeButton( TimeMML$ )
            If InvalidFileLength = TRUE Then
                MsgBox "This is a corrupt file! Its length is invalid. Some or all of its macros may not work, even though they display correctly.", WARNING_MESSAGE, WaltsMacros$
            End If
            DlgListBoxArray     "ListOfMacros",     MacroListNames()
            DlgValue            "ListOfMacros",     0
            DlgText             "FileInfo",         FileInfo$
            DlgVisible          "FileInfo",         VISIBLE
            DlgText             "FileKBs",          Space$( 12 - Len( FileSizeKBStr$ ) ) & FileSizeKBStr$ & " KB"
            DlgVisible          "FileKBs",          VISIBLE
            DlgText             "MacroCount",       SummaryMacroCount$
            DlgVisible          "MacroCount",       VISIBLE
            DlgText             "TimeButton",       TotalTime$
            DlgVisible          "TimeButton",       VISIBLE
            ReDim MainMacroArray( TotalMacroCount%, 0 )

' Only one macro in macro book: get its information immediately. The default save option
' is to save the macro text.

            If TotalMacroCount% = 0 Then
                SelectedMacroIndex% = DlgValue( "ListOfMacros" )
                Call AssembleMacroInfo( SelectedMacroIndex% )
                ThisMacroRecord = MacroListB( SelectedMacroIndex% )
                Call SetDialogBox( ThisMacroRecord )
                DlgVisible          "SelectBooks",      INVISIBLE

' More than one macro: focus on the list of macros for selection of one of them to
' process. Set the default save option to be to save the whole list.

              Else

                SelectedMacroName$ = ""
                DlgVisible          "Clipboard",        VISIBLE
                DlgVisible          "Description",      INVISIBLE
                DlgVisible          "MacroLines",       INVISIBLE
                DlgVisible          "MacroSize",        INVISIBLE
                DlgVisible          "NameDiffers",      INVISIBLE
                DlgVisible          "NameDiffersBox",   INVISIBLE
                DlgVisible          "OutlineDesc",      INVISIBLE
                DlgVisible          "OutlineInfo",      INVISIBLE
                DlgVisible          "PreviewButton",    INVISIBLE
                DlgVisible          "PreviewText",      INVISIBLE
                DlgVisible          "RevDate",          INVISIBLE
                DlgEnable           "SaveList",         ENABLED
                DlgEnable           "SaveMacro",        DISABLED
                DlgVisible          "SelectBooks",      INVISIBLE
                DlgVisible          "SelectMacro",      VISIBLE
                DlgVisible          "Shortcut",         INVISIBLE
                TimeGMI$           = "NA"
            End If

' No macro selected: send the focus of the dialog box back to the macro book list. Set
' the default save option to be to save the directory list.

          Else

            DlgListBoxArray     "ListOfMacros",     ListChoosing$()
            DlgFocus            "ListOfMacroBooks"
            DlgVisible          "Clipboard",        INVISIBLE
            DlgVisible          "Description",      INVISIBLE
            DlgVisible          "FileInfo",         INVISIBLE
            DlgVisible          "FileKBs",          INVISIBLE
            DlgVisible          "MacroCount",       INVISIBLE
            DlgVisible          "MacroLines",       INVISIBLE
            DlgVisible          "MacroSize",        INVISIBLE
            DlgVisible          "NameDiffers",      INVISIBLE
            DlgVisible          "NameDiffersBox",   INVISIBLE
            DlgVisible          "OutlineDesc",      INVISIBLE
            DlgVisible          "OutlineInfo",      INVISIBLE
            DlgVisible          "PreviewButton",    INVISIBLE
            DlgVisible          "PreviewText",      INVISIBLE
            DlgVisible          "RevDate",          INVISIBLE
            DlgEnable           "SaveList",         ENABLED
            DlgEnable           "SaveMacro",        DISABLED
            DlgVisible          "SelectBooks",      VISIBLE
            DlgVisible          "SelectMacro",      INVISIBLE
            DlgVisible          "Shortcut",         INVISIBLE
            DlgVisible          "TimeButton",       INVISIBLE

        End If

' A macro is selected.

      Case "ListOfMacros"

        If DlgValue( "ListOfMacroBooks" ) = 0 Then   'No macrobook is selected: do nothing
            DlgFocus            "ListOfMacroBooks"
          Else
            SelectedMacroIndex% = DlgValue( "ListOfMacros" )
            If MainMacroArray( SelectedMacroIndex%, 0 ) = "" Then
                Call AssembleMacroInfo( SelectedMacroIndex% )
            End If
            ThisMacroRecord     = MacroListB( SelectedMacroIndex% )

' Whenever a macro is selected, show its information.

            Call SetDialogBox( ThisMacroRecord )
        End If

' If the radio buttons are clicked to change what to save, change the string supplied to
' the text box and set the focus to the "Save" button, assuming an immediate save is
' desired.

      Case "SaveList"

        SelectedMacroName$     = ThisMacroRecord.tName
        Call WriteFile( SAVE_LIST )
        Dialog1ControlFunction = KEEP_DLG_OPEN
        DlgFocus            "CloseButton"

      Case "SaveMacro"

        SelectedMacroName$     = ThisMacroRecord.tName
        Call WriteFile( SAVE_MACRO )
        Dialog1ControlFunction = KEEP_DLG_OPEN
        DlgFocus            "CloseButton"

' If the "Preview" button is clicked, display the window showing the first bit of the
' macro.

      Case "PreviewButton"

        MaxPreview$ = ThisMacroRecord.tPreview
        LinesShown% = ThisMacroRecord.tPreviewLineCount
        If LinesShown% < 0 Then
            LineCountReport$ = "Complete macro:"
          Else
            LineCountReport$ = "First " & Trim$( Str$( LinesShown% ) ) & " lines of macro:"
        End If
        Header$     = LineCountReport$ & " " & FullMacroName$

        Begin Dialog Dialog4Definition 400, 262, WaltsMacros$
          CancelButton  168, 238,  64,  16
          Text            8,   8, 384,   8, Header$
          GroupBox        8,  18, 384, 212, ""
          Text           16,  26, 368, 200, MaxPreview$
        End Dialog

        Dim Dialog4 As Dialog4Definition
        On Error Resume Next
        Dialog Dialog4

        Dialog1ControlFunction = KEEP_DLG_OPEN
        DlgFocus            "CloseButton"

' When the button showing the elapsed time is clicked, call the subprogram to display it.
' The text of the button doesn't change even when the time to assemble a macro is added
' to the dialog box.

      Case "TimeButton"

        Call ShowTimes
        Dialog1ControlFunction = KEEP_DLG_OPEN
        DlgFocus            "CloseButton"

    End Select

End Select

End Function

'****************************************************************************************

Function Dialog3ControlFunction( Id$, Action%, SuppVal& )

Select Case Action%

  Case INITIALIZE

    DlgValue            "ComboBox",         0


  Case CONTROL_CHANGE
    If Id$ = "Clear" Then
        DlgText             "ComboBox",         ""
        Dialog3ControlFunction = KEEP_DLG_OPEN
    End If

End Select

End Function
'2625110002
